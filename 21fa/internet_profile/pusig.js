async function PUSIG(custom_text = Math.random().toString()) {
    /* UAParser v0.7.28 */ (function (window, undefined) { "use strict"; var LIBVERSION = "0.7.28", EMPTY = "", UNKNOWN = "?", FUNC_TYPE = "function", UNDEF_TYPE = "undefined", OBJ_TYPE = "object", STR_TYPE = "string", MAJOR = "major", MODEL = "model", NAME = "name", TYPE = "type", VENDOR = "vendor", VERSION = "version", ARCHITECTURE = "architecture", CONSOLE = "console", MOBILE = "mobile", TABLET = "tablet", SMARTTV = "smarttv", WEARABLE = "wearable", EMBEDDED = "embedded", UA_MAX_LENGTH = 255; var AMAZON = "Amazon", APPLE = "Apple", ASUS = "ASUS", BLACKBERRY = "BlackBerry", BROWSER = "Browser", CHROME = "Chrome", EDGE = "Edge", FIREFOX = "Firefox", GOOGLE = "Google", HUAWEI = "Huawei", LG = "LG", MICROSOFT = "Microsoft", MOTOROLA = "Motorola", OPERA = "Opera", SAMSUNG = "Samsung", SONY = "Sony", XIAOMI = "Xiaomi", ZEBRA = "Zebra"; var extend = function (regexes, extensions) { var mergedRegexes = {}; for (var i in regexes) { if (extensions[i] && extensions[i].length % 2 === 0) { mergedRegexes[i] = extensions[i].concat(regexes[i]) } else { mergedRegexes[i] = regexes[i] } } return mergedRegexes }, enumerize = function (arr) { var enums = {}; for (var i in arr) { enums[arr[i].toUpperCase()] = arr[i] } return enums }, has = function (str1, str2) { return typeof str1 === STR_TYPE ? lowerize(str2).indexOf(lowerize(str1)) !== -1 : false }, lowerize = function (str) { return str.toLowerCase() }, majorize = function (version) { return typeof version === STR_TYPE ? version.replace(/[^\d\.]/g, EMPTY).split(".")[0] : undefined }, trim = function (str, len) { if (typeof str === STR_TYPE) { str = str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, EMPTY); return typeof len === UNDEF_TYPE ? str : str.substring(0, UA_MAX_LENGTH) } }; var rgxMapper = function (ua, arrays) { var i = 0, j, k, p, q, matches, match; while (i < arrays.length && !matches) { var regex = arrays[i], props = arrays[i + 1]; j = k = 0; while (j < regex.length && !matches) { matches = regex[j++].exec(ua); if (!!matches) { for (p = 0; p < props.length; p++) { match = matches[++k]; q = props[p]; if (typeof q === OBJ_TYPE && q.length > 0) { if (q.length == 2) { if (typeof q[1] == FUNC_TYPE) { this[q[0]] = q[1].call(this, match) } else { this[q[0]] = q[1] } } else if (q.length == 3) { if (typeof q[1] === FUNC_TYPE && !(q[1].exec && q[1].test)) { this[q[0]] = match ? q[1].call(this, match, q[2]) : undefined } else { this[q[0]] = match ? match.replace(q[1], q[2]) : undefined } } else if (q.length == 4) { this[q[0]] = match ? q[3].call(this, match.replace(q[1], q[2])) : undefined } } else { this[q] = match ? match : undefined } } } } i += 2 } }, strMapper = function (str, map) { for (var i in map) { if (typeof map[i] === OBJ_TYPE && map[i].length > 0) { for (var j = 0; j < map[i].length; j++) { if (has(map[i][j], str)) { return i === UNKNOWN ? undefined : i } } } else if (has(map[i], str)) { return i === UNKNOWN ? undefined : i } } return str }; var oldSafariMap = { "1.0": "/8", 1.2: "/1", 1.3: "/3", "2.0": "/412", "2.0.2": "/416", "2.0.3": "/417", "2.0.4": "/419", "?": "/" }, windowsVersionMap = { ME: "4.90", "NT 3.11": "NT3.51", "NT 4.0": "NT4.0", 2e3: "NT 5.0", XP: ["NT 5.1", "NT 5.2"], Vista: "NT 6.0", 7: "NT 6.1", 8: "NT 6.2", 8.1: "NT 6.3", 10: ["NT 6.4", "NT 10.0"], RT: "ARM" }; var regexes = { browser: [[/\b(?:crmo|crios)\/([\w\.]+)/i], [VERSION, [NAME, "Chrome"]], [/edg(?:e|ios|a)?\/([\w\.]+)/i], [VERSION, [NAME, "Edge"]], [/(opera mini)\/([-\w\.]+)/i, /(opera [mobiletab]{3,6})\b.+version\/([-\w\.]+)/i, /(opera)(?:.+version\/|[\/ ]+)([\w\.]+)/i], [NAME, VERSION], [/opios[\/ ]+([\w\.]+)/i], [VERSION, [NAME, OPERA + " Mini"]], [/\bopr\/([\w\.]+)/i], [VERSION, [NAME, OPERA]], [/(kindle)\/([\w\.]+)/i, /(lunascape|maxthon|netfront|jasmine|blazer)[\/ ]?([\w\.]*)/i, /(avant |iemobile|slim)(?:browser)?[\/ ]?([\w\.]*)/i, /(ba?idubrowser)[\/ ]?([\w\.]+)/i, /(?:ms|\()(ie) ([\w\.]+)/i, /(flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser|quark|qupzilla|falkon|rekonq|puffin|brave|whale|qqbrowserlite|qq)\/([-\w\.]+)/i, /(weibo)__([\d\.]+)/i], [NAME, VERSION], [/(?:\buc? ?browser|(?:juc.+)ucweb)[\/ ]?([\w\.]+)/i], [VERSION, [NAME, "UC" + BROWSER]], [/\bqbcore\/([\w\.]+)/i], [VERSION, [NAME, "WeChat(Win) Desktop"]], [/micromessenger\/([\w\.]+)/i], [VERSION, [NAME, "WeChat"]], [/konqueror\/([\w\.]+)/i], [VERSION, [NAME, "Konqueror"]], [/trident.+rv[: ]([\w\.]{1,9})\b.+like gecko/i], [VERSION, [NAME, "IE"]], [/yabrowser\/([\w\.]+)/i], [VERSION, [NAME, "Yandex"]], [/(avast|avg)\/([\w\.]+)/i], [[NAME, /(.+)/, "$1 Secure " + BROWSER], VERSION], [/\bfocus\/([\w\.]+)/i], [VERSION, [NAME, FIREFOX + " Focus"]], [/\bopt\/([\w\.]+)/i], [VERSION, [NAME, OPERA + " Touch"]], [/coc_coc\w+\/([\w\.]+)/i], [VERSION, [NAME, "Coc Coc"]], [/dolfin\/([\w\.]+)/i], [VERSION, [NAME, "Dolphin"]], [/coast\/([\w\.]+)/i], [VERSION, [NAME, OPERA + " Coast"]], [/miuibrowser\/([\w\.]+)/i], [VERSION, [NAME, "MIUI " + BROWSER]], [/fxios\/([-\w\.]+)/i], [VERSION, [NAME, FIREFOX]], [/\bqihu|(qi?ho?o?|360)browser/i], [[NAME, "360 " + BROWSER]], [/(oculus|samsung|sailfish)browser\/([\w\.]+)/i], [[NAME, /(.+)/, "$1 " + BROWSER], VERSION], [/(comodo_dragon)\/([\w\.]+)/i], [[NAME, /_/g, " "], VERSION], [/(electron)\/([\w\.]+) safari/i, /(tesla)(?: qtcarbrowser|\/(20\d\d\.[-\w\.]+))/i, /m?(qqbrowser|baiduboxapp|2345Explorer)[\/ ]?([\w\.]+)/i], [NAME, VERSION], [/(metasr)[\/ ]?([\w\.]+)/i, /(lbbrowser)/i], [NAME], [/((?:fban\/fbios|fb_iab\/fb4a)(?!.+fbav)|;fbav\/([\w\.]+);)/i], [[NAME, "Facebook"], VERSION], [/safari (line)\/([\w\.]+)/i, /\b(line)\/([\w\.]+)\/iab/i, /(chromium|instagram)[\/ ]([-\w\.]+)/i], [NAME, VERSION], [/\bgsa\/([\w\.]+) .*safari\//i], [VERSION, [NAME, "GSA"]], [/headlesschrome(?:\/([\w\.]+)| )/i], [VERSION, [NAME, CHROME + " Headless"]], [/ wv\).+(chrome)\/([\w\.]+)/i], [[NAME, CHROME + " WebView"], VERSION], [/droid.+ version\/([\w\.]+)\b.+(?:mobile safari|safari)/i], [VERSION, [NAME, "Android " + BROWSER]], [/(chrome|omniweb|arora|[tizenoka]{5} ?browser)\/v?([\w\.]+)/i], [NAME, VERSION], [/version\/([\w\.]+) .*mobile\/\w+ (safari)/i], [VERSION, [NAME, "Mobile Safari"]], [/version\/([\w\.]+) .*(mobile ?safari|safari)/i], [VERSION, NAME], [/webkit.+?(mobile ?safari|safari)(\/[\w\.]+)/i], [NAME, [VERSION, strMapper, oldSafariMap]], [/(webkit|khtml)\/([\w\.]+)/i], [NAME, VERSION], [/(navigator|netscape\d?)\/([-\w\.]+)/i], [[NAME, "Netscape"], VERSION], [/mobile vr; rv:([\w\.]+)\).+firefox/i], [VERSION, [NAME, FIREFOX + " Reality"]], [/ekiohf.+(flow)\/([\w\.]+)/i, /(swiftfox)/i, /(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror|klar)[\/ ]?([\w\.\+]+)/i, /(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([-\w\.]+)$/i, /(firefox)\/([\w\.]+)/i, /(mozilla)\/([\w\.]+) .+rv\:.+gecko\/\d+/i, /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir|obigo|mosaic|(?:go|ice|up)[\. ]?browser)[-\/ ]?v?([\w\.]+)/i, /(links) \(([\w\.]+)/i], [NAME, VERSION]], cpu: [[/(?:(amd|x(?:(?:86|64)[-_])?|wow|win)64)[;\)]/i], [[ARCHITECTURE, "amd64"]], [/(ia32(?=;))/i], [[ARCHITECTURE, lowerize]], [/((?:i[346]|x)86)[;\)]/i], [[ARCHITECTURE, "ia32"]], [/\b(aarch64|armv?8e?l?)\b/i], [[ARCHITECTURE, "arm64"]], [/\b(arm(?:v[67])?ht?n?[fl]p?)\b/i], [[ARCHITECTURE, "armhf"]], [/windows (ce|mobile); ppc;/i], [[ARCHITECTURE, "arm"]], [/((?:ppc|powerpc)(?:64)?)(?: mac|;|\))/i], [[ARCHITECTURE, /ower/, EMPTY, lowerize]], [/(sun4\w)[;\)]/i], [[ARCHITECTURE, "sparc"]], [/((?:avr32|ia64(?=;))|68k(?=\))|\barm(?:64|(?=v(?:[1-7]|[5-7]1)l?|;|eabi))|(?=atmel )avr|(?:irix|mips|sparc)(?:64)?\b|pa-risc)/i], [[ARCHITECTURE, lowerize]]], device: [[/\b(sch-i[89]0\d|shw-m380s|sm-[pt]\w{2,4}|gt-[pn]\d{2,4}|sgh-t8[56]9|nexus 10)/i], [MODEL, [VENDOR, SAMSUNG], [TYPE, TABLET]], [/\b((?:s[cgp]h|gt|sm)-\w+|galaxy nexus)/i, /samsung[- ]([-\w]+)/i, /sec-(sgh\w+)/i], [MODEL, [VENDOR, SAMSUNG], [TYPE, MOBILE]], [/\((ip(?:hone|od)[\w ]*);/i], [MODEL, [VENDOR, APPLE], [TYPE, MOBILE]], [/\((ipad);[-\w\),; ]+apple/i, /applecoremedia\/[\w\.]+ \((ipad)/i, /\b(ipad)\d\d?,\d\d?[;\]].+ios/i], [MODEL, [VENDOR, APPLE], [TYPE, TABLET]], [/\b((?:agr|ags[23]|bah2?|sht?)-a?[lw]\d{2})/i], [MODEL, [VENDOR, HUAWEI], [TYPE, TABLET]], [/huawei([-\w ]+)[;\)]/i, /\b(nexus 6p|vog-[at]?l\d\d|ane-[at]?l[x\d]\d|eml-a?l\d\da?|lya-[at]?l\d[\dc]|clt-a?l\d\di?|ele-l\d\d)/i, /\b(\w{2,4}-[atu][ln][01259][019])[;\) ]/i], [MODEL, [VENDOR, HUAWEI], [TYPE, MOBILE]], [/\b(poco[\w ]+)(?: bui|\))/i, /\b; (\w+) build\/hm\1/i, /\b(hm[-_ ]?note?[_ ]?(?:\d\w)?) bui/i, /\b(redmi[\-_ ]?(?:note|k)?[\w_ ]+)(?: bui|\))/i, /\b(mi[-_ ]?(?:a\d|one|one[_ ]plus|note lte)?[_ ]?(?:\d?\w?)[_ ]?(?:plus)?) bui/i], [[MODEL, /_/g, " "], [VENDOR, XIAOMI], [TYPE, MOBILE]], [/\b(mi[-_ ]?(?:pad)(?:[\w_ ]+))(?: bui|\))/i], [[MODEL, /_/g, " "], [VENDOR, XIAOMI], [TYPE, TABLET]], [/; (\w+) bui.+ oppo/i, /\b(cph[12]\d{3}|p(?:af|c[al]|d\w|e[ar])[mt]\d0|x9007)\b/i], [MODEL, [VENDOR, "OPPO"], [TYPE, MOBILE]], [/vivo (\w+)(?: bui|\))/i, /\b(v[12]\d{3}\w?[at])(?: bui|;)/i], [MODEL, [VENDOR, "Vivo"], [TYPE, MOBILE]], [/\b(rmx[12]\d{3})(?: bui|;)/i], [MODEL, [VENDOR, "Realme"], [TYPE, MOBILE]], [/\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\b[\w ]+build\//i, /\bmot(?:orola)?[- ](\w*)/i, /((?:moto[\w\(\) ]+|xt\d{3,4}|nexus 6)(?= bui|\)))/i], [MODEL, [VENDOR, MOTOROLA], [TYPE, MOBILE]], [/\b(mz60\d|xoom[2 ]{0,2}) build\//i], [MODEL, [VENDOR, MOTOROLA], [TYPE, TABLET]], [/((?=lg)?[vl]k\-?\d{3}) bui| 3\.[-\w; ]{10}lg?-([06cv9]{3,4})/i], [MODEL, [VENDOR, LG], [TYPE, TABLET]], [/(lm-?f100[nv]?|nexus [45])/i, /\blg[-e;\/ ]+((?!browser|netcast)\w+)/i, /\blg(\-?[\d\w]+) bui/i], [MODEL, [VENDOR, LG], [TYPE, MOBILE]], [/(ideatab[-\w ]+)/i, /lenovo ?(s[56]000[-\w]+|tab(?:[\w ]+)|yt[-\d\w]{6}|tb[-\d\w]{6})/i], [MODEL, [VENDOR, "Lenovo"], [TYPE, TABLET]], [/(?:maemo|nokia).*(n900|lumia \d+)/i, /nokia[-_ ]?([-\w\.]*)/i], [[MODEL, /_/g, " "], [VENDOR, "Nokia"], [TYPE, MOBILE]], [/(pixel c)\b/i], [MODEL, [VENDOR, GOOGLE], [TYPE, TABLET]], [/droid.+; (pixel[\daxl ]{0,6})(?: bui|\))/i], [MODEL, [VENDOR, GOOGLE], [TYPE, MOBILE]], [/droid.+ ([c-g]\d{4}|so[-l]\w+|xq-a\w[4-7][12])(?= bui|\).+chrome\/(?![1-6]{0,1}\d\.))/i], [MODEL, [VENDOR, SONY], [TYPE, MOBILE]], [/sony tablet [ps]/i, /\b(?:sony)?sgp\w+(?: bui|\))/i], [[MODEL, "Xperia Tablet"], [VENDOR, SONY], [TYPE, TABLET]], [/ (kb2005|in20[12]5|be20[12][59])\b/i, /\ba000(1) bui/i, /oneplus (a\d{4})[) ]/i], [MODEL, [VENDOR, "OnePlus"], [TYPE, MOBILE]], [/(alexa)webm/i, /(kf[a-z]{2}wi)( bui|\))/i, /(kf[a-z]+)( bui|\)).+silk\//i], [MODEL, [VENDOR, AMAZON], [TYPE, TABLET]], [/((?:sd|kf)[0349hijorstuw]+)( bui|\)).+silk\//i], [[MODEL, /(.+)/g, "Fire Phone $1"], [VENDOR, AMAZON], [TYPE, MOBILE]], [/(playbook);[-\w\),; ]+(rim)/i], [MODEL, VENDOR, [TYPE, TABLET]], [/\b((?:bb[a-f]|st[hv])100-\d)/i, /\(bb10; (\w+)/i], [MODEL, [VENDOR, BLACKBERRY], [TYPE, MOBILE]], [/(?:\b|asus_)(transfo[prime ]{4,10} \w+|eeepc|slider \w+|nexus 7|padfone|p00[cj])/i], [MODEL, [VENDOR, ASUS], [TYPE, TABLET]], [/ (z[es]6[027][01][km][ls]|zenfone \d\w?)\b/i], [MODEL, [VENDOR, ASUS], [TYPE, MOBILE]], [/(nexus 9)/i], [MODEL, [VENDOR, "HTC"], [TYPE, TABLET]], [/(htc)[-;_ ]{1,2}([\w ]+(?=\)| bui)|\w+)/i, /(zte)-(\w*)/i, /(alcatel|geeksphone|nexian|panasonic|sony)[-_ ]?([-\w]*)/i], [VENDOR, [MODEL, /_/g, " "], [TYPE, MOBILE]], [/droid.+; ([ab][1-7]-?[0178a]\d\d?)/i], [MODEL, [VENDOR, "Acer"], [TYPE, TABLET]], [/droid.+; (m[1-5] note) bui/i, /\bmz-([-\w]{2,})/i], [MODEL, [VENDOR, "Meizu"], [TYPE, MOBILE]], [/(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron)[-_ ]?([-\w]*)/i, /(hp) ([\w ]+\w)/i, /(asus)-?(\w+)/i, /(microsoft); (lumia[\w ]+)/i, /(lenovo)[-_ ]?([-\w]+)/i, /(jolla)/i, /(oppo) ?([\w ]+) bui/i], [VENDOR, MODEL, [TYPE, MOBILE]], [/(archos) (gamepad2?)/i, /(hp).+(touchpad(?!.+tablet)|tablet)/i, /(kindle)\/([\w\.]+)/i, /(nook)[\w ]+build\/(\w+)/i, /(dell) (strea[kpr\d ]*[\dko])/i, /(le[- ]+pan)[- ]+(\w{1,9}) bui/i, /(trinity)[- ]*(t\d{3}) bui/i, /(gigaset)[- ]+(q\w{1,9}) bui/i, /(vodafone) ([\w ]+)(?:\)| bui)/i], [VENDOR, MODEL, [TYPE, TABLET]], [/(surface duo)/i], [MODEL, [VENDOR, MICROSOFT], [TYPE, TABLET]], [/droid [\d\.]+; (fp\du?) b/i], [MODEL, [VENDOR, "Fairphone"], [TYPE, MOBILE]], [/(u304aa)/i], [MODEL, [VENDOR, "AT&T"], [TYPE, MOBILE]], [/\bsie-(\w*)/i], [MODEL, [VENDOR, "Siemens"], [TYPE, MOBILE]], [/\b(rct\w+) b/i], [MODEL, [VENDOR, "RCA"], [TYPE, TABLET]], [/\b(venue[\d ]{2,7}) b/i], [MODEL, [VENDOR, "Dell"], [TYPE, TABLET]], [/\b(q(?:mv|ta)\w+) b/i], [MODEL, [VENDOR, "Verizon"], [TYPE, TABLET]], [/\b(?:barnes[& ]+noble |bn[rt])([\w\+ ]*) b/i], [MODEL, [VENDOR, "Barnes & Noble"], [TYPE, TABLET]], [/\b(tm\d{3}\w+) b/i], [MODEL, [VENDOR, "NuVision"], [TYPE, TABLET]], [/\b(k88) b/i], [MODEL, [VENDOR, "ZTE"], [TYPE, TABLET]], [/\b(nx\d{3}j) b/i], [MODEL, [VENDOR, "ZTE"], [TYPE, MOBILE]], [/\b(gen\d{3}) b.+49h/i], [MODEL, [VENDOR, "Swiss"], [TYPE, MOBILE]], [/\b(zur\d{3}) b/i], [MODEL, [VENDOR, "Swiss"], [TYPE, TABLET]], [/\b((zeki)?tb.*\b) b/i], [MODEL, [VENDOR, "Zeki"], [TYPE, TABLET]], [/\b([yr]\d{2}) b/i, /\b(dragon[- ]+touch |dt)(\w{5}) b/i], [[VENDOR, "Dragon Touch"], MODEL, [TYPE, TABLET]], [/\b(ns-?\w{0,9}) b/i], [MODEL, [VENDOR, "Insignia"], [TYPE, TABLET]], [/\b((nxa|next)-?\w{0,9}) b/i], [MODEL, [VENDOR, "NextBook"], [TYPE, TABLET]], [/\b(xtreme\_)?(v(1[045]|2[015]|[3469]0|7[05])) b/i], [[VENDOR, "Voice"], MODEL, [TYPE, MOBILE]], [/\b(lvtel\-)?(v1[12]) b/i], [[VENDOR, "LvTel"], MODEL, [TYPE, MOBILE]], [/\b(ph-1) /i], [MODEL, [VENDOR, "Essential"], [TYPE, MOBILE]], [/\b(v(100md|700na|7011|917g).*\b) b/i], [MODEL, [VENDOR, "Envizen"], [TYPE, TABLET]], [/\b(trio[-\w\. ]+) b/i], [MODEL, [VENDOR, "MachSpeed"], [TYPE, TABLET]], [/\btu_(1491) b/i], [MODEL, [VENDOR, "Rotor"], [TYPE, TABLET]], [/(shield[\w ]+) b/i], [MODEL, [VENDOR, "Nvidia"], [TYPE, TABLET]], [/(sprint) (\w+)/i], [VENDOR, MODEL, [TYPE, MOBILE]], [/(kin\.[onetw]{3})/i], [[MODEL, /\./g, " "], [VENDOR, MICROSOFT], [TYPE, MOBILE]], [/droid.+; (cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\)/i], [MODEL, [VENDOR, ZEBRA], [TYPE, TABLET]], [/droid.+; (ec30|ps20|tc[2-8]\d[kx])\)/i], [MODEL, [VENDOR, ZEBRA], [TYPE, MOBILE]], [/(ouya)/i, /(nintendo) ([wids3utch]+)/i], [VENDOR, MODEL, [TYPE, CONSOLE]], [/droid.+; (shield) bui/i], [MODEL, [VENDOR, "Nvidia"], [TYPE, CONSOLE]], [/(playstation [345portablevi]+)/i], [MODEL, [VENDOR, SONY], [TYPE, CONSOLE]], [/\b(xbox(?: one)?(?!; xbox))[\); ]/i], [MODEL, [VENDOR, MICROSOFT], [TYPE, CONSOLE]], [/smart-tv.+(samsung)/i], [VENDOR, [TYPE, SMARTTV]], [/hbbtv.+maple;(\d+)/i], [[MODEL, /^/, "SmartTV"], [VENDOR, SAMSUNG], [TYPE, SMARTTV]], [/(?:nux; netcast.+smarttv|lg netcast\.tv-201\d)/i], [[VENDOR, LG], [TYPE, SMARTTV]], [/(apple) ?tv/i], [VENDOR, [MODEL, APPLE + " TV"], [TYPE, SMARTTV]], [/crkey/i], [[MODEL, CHROME + "cast"], [VENDOR, GOOGLE], [TYPE, SMARTTV]], [/droid.+aft(\w)( bui|\))/i], [MODEL, [VENDOR, AMAZON], [TYPE, SMARTTV]], [/\(dtv[\);].+(aquos)/i], [MODEL, [VENDOR, "Sharp"], [TYPE, SMARTTV]], [/\b(roku)[\dx]*[\)\/]((?:dvp-)?[\d\.]*)/i, /hbbtv\/\d+\.\d+\.\d+ +\([\w ]*; *(\w[^;]*);([^;]*)/i], [[VENDOR, trim], [MODEL, trim], [TYPE, SMARTTV]], [/\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\b/i], [[TYPE, SMARTTV]], [/((pebble))app/i], [VENDOR, MODEL, [TYPE, WEARABLE]], [/droid.+; (glass) \d/i], [MODEL, [VENDOR, GOOGLE], [TYPE, WEARABLE]], [/droid.+; (wt63?0{2,3})\)/i], [MODEL, [VENDOR, ZEBRA], [TYPE, WEARABLE]], [/(tesla)(?: qtcarbrowser|\/[-\w\.]+)/i], [VENDOR, [TYPE, EMBEDDED]], [/droid .+?; ([^;]+?)(?: bui|\) applew).+? mobile safari/i], [MODEL, [TYPE, MOBILE]], [/droid .+?; ([^;]+?)(?: bui|\) applew).+?(?! mobile) safari/i], [MODEL, [TYPE, TABLET]], [/\b((tablet|tab)[;\/]|focus\/\d(?!.+mobile))/i], [[TYPE, TABLET]], [/(phone|mobile(?:[;\/]| safari)|pda(?=.+windows ce))/i], [[TYPE, MOBILE]], [/(android[-\w\. ]{0,9});.+buil/i], [MODEL, [VENDOR, "Generic"]]], engine: [[/windows.+ edge\/([\w\.]+)/i], [VERSION, [NAME, EDGE + "HTML"]], [/webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i], [VERSION, [NAME, "Blink"]], [/(presto)\/([\w\.]+)/i, /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna)\/([\w\.]+)/i, /ekioh(flow)\/([\w\.]+)/i, /(khtml|tasman|links)[\/ ]\(?([\w\.]+)/i, /(icab)[\/ ]([23]\.[\d\.]+)/i], [NAME, VERSION], [/rv\:([\w\.]{1,9})\b.+(gecko)/i], [VERSION, NAME]], os: [[/microsoft (windows) (vista|xp)/i], [NAME, VERSION], [/(windows) nt 6\.2; (arm)/i, /(windows (?:phone(?: os)?|mobile))[\/ ]?([\d\.\w ]*)/i, /(windows)[\/ ]?([ntce\d\. ]+\w)(?!.+xbox)/i], [NAME, [VERSION, strMapper, windowsVersionMap]], [/(win(?=3|9|n)|win 9x )([nt\d\.]+)/i], [[NAME, "Windows"], [VERSION, strMapper, windowsVersionMap]], [/ip[honead]{2,4}\b(?:.*os ([\w]+) like mac|; opera)/i, /cfnetwork\/.+darwin/i], [[VERSION, /_/g, "."], [NAME, "iOS"]], [/(mac os x) ?([\w\. ]*)/i, /(macintosh|mac_powerpc\b)(?!.+haiku)/i], [[NAME, "Mac OS"], [VERSION, /_/g, "."]], [/(android|webos|qnx|bada|rim tablet os|maemo|meego|sailfish)[-\/ ]?([\w\.]*)/i, /(blackberry)\w*\/([\w\.]*)/i, /(tizen|kaios)[\/ ]([\w\.]+)/i, /\((series40);/i], [NAME, VERSION], [/\(bb(10);/i], [VERSION, [NAME, BLACKBERRY]], [/(?:symbian ?os|symbos|s60(?=;)|series60)[-\/ ]?([\w\.]*)/i], [VERSION, [NAME, "Symbian"]], [/mozilla\/[\d\.]+ \((?:mobile|tablet|tv|mobile; [\w ]+); rv:.+ gecko\/([\w\.]+)/i], [VERSION, [NAME, FIREFOX + " OS"]], [/web0s;.+rt(tv)/i, /\b(?:hp)?wos(?:browser)?\/([\w\.]+)/i], [VERSION, [NAME, "webOS"]], [/crkey\/([\d\.]+)/i], [VERSION, [NAME, CHROME + "cast"]], [/(cros) [\w]+ ([\w\.]+\w)/i], [[NAME, "Chromium OS"], VERSION], [/(nintendo|playstation) ([wids345portablevuch]+)/i, /(xbox); +xbox ([^\);]+)/i, /\b(joli|palm)\b ?(?:os)?\/?([\w\.]*)/i, /(mint)[\/\(\) ]?(\w*)/i, /(mageia|vectorlinux)[; ]/i, /([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki)(?: gnu\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\/ ]?(?!chrom|package)([-\w\.]*)/i, /(hurd|linux) ?([\w\.]*)/i, /(gnu) ?([\w\.]*)/i, /\b([-frentopc]{0,4}bsd|dragonfly) ?(?!amd|[ix346]{1,2}86)([\w\.]*)/i, /(haiku) (\w+)/i], [NAME, VERSION], [/(sunos) ?([\w\.\d]*)/i], [[NAME, "Solaris"], VERSION], [/((?:open)?solaris)[-\/ ]?([\w\.]*)/i, /(aix) ((\d)(?=\.|\)| )[\w\.])*/i, /\b(beos|os\/2|amigaos|morphos|openvms|fuchsia|hp-ux)/i, /(unix) ?([\w\.]*)/i], [NAME, VERSION]] }; var UAParser = function (ua, extensions) { if (typeof ua === OBJ_TYPE) { extensions = ua; ua = undefined } if (!(this instanceof UAParser)) { return new UAParser(ua, extensions).getResult() } var _ua = ua || (typeof window !== UNDEF_TYPE && window.navigator && window.navigator.userAgent ? window.navigator.userAgent : EMPTY); var _rgxmap = extensions ? extend(regexes, extensions) : regexes; this.getBrowser = function () { var _browser = {}; _browser[NAME] = undefined; _browser[VERSION] = undefined; rgxMapper.call(_browser, _ua, _rgxmap.browser); _browser.major = majorize(_browser.version); return _browser }; this.getCPU = function () { var _cpu = {}; _cpu[ARCHITECTURE] = undefined; rgxMapper.call(_cpu, _ua, _rgxmap.cpu); return _cpu }; this.getDevice = function () { var _device = {}; _device[VENDOR] = undefined; _device[MODEL] = undefined; _device[TYPE] = undefined; rgxMapper.call(_device, _ua, _rgxmap.device); return _device }; this.getEngine = function () { var _engine = {}; _engine[NAME] = undefined; _engine[VERSION] = undefined; rgxMapper.call(_engine, _ua, _rgxmap.engine); return _engine }; this.getOS = function () { var _os = {}; _os[NAME] = undefined; _os[VERSION] = undefined; rgxMapper.call(_os, _ua, _rgxmap.os); return _os }; this.getResult = function () { return { ua: this.getUA(), browser: this.getBrowser(), engine: this.getEngine(), os: this.getOS(), device: this.getDevice(), cpu: this.getCPU() } }; this.getUA = function () { return _ua }; this.setUA = function (ua) { _ua = typeof ua === STR_TYPE && ua.length > UA_MAX_LENGTH ? trim(ua, UA_MAX_LENGTH) : ua; return this }; this.setUA(_ua); return this }; UAParser.VERSION = LIBVERSION; UAParser.BROWSER = enumerize([NAME, VERSION, MAJOR]); UAParser.CPU = enumerize([ARCHITECTURE]); UAParser.DEVICE = enumerize([MODEL, VENDOR, TYPE, CONSOLE, MOBILE, SMARTTV, TABLET, WEARABLE, EMBEDDED]); UAParser.ENGINE = UAParser.OS = enumerize([NAME, VERSION]); if (typeof exports !== UNDEF_TYPE) { if (typeof module !== UNDEF_TYPE && module.exports) { exports = module.exports = UAParser } exports.UAParser = UAParser } else { if (typeof define === FUNC_TYPE && define.amd) { define(function () { return UAParser }) } else if (typeof window !== UNDEF_TYPE) { window.UAParser = UAParser } } var $ = typeof window !== UNDEF_TYPE && (window.jQuery || window.Zepto); if ($ && !$.ua) { var parser = new UAParser; $.ua = parser.getResult(); $.ua.get = function () { return parser.getUA() }; $.ua.set = function (ua) { parser.setUA(ua); var result = parser.getResult(); for (var prop in result) { $.ua[prop] = result[prop] } } } })(typeof window === "object" ? window : this);
    /* Biri.js */ !function (t, e) { "object" == typeof exports && "object" == typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define([], e) : "object" == typeof exports ? exports.biri = e() : t.biri = e() }(window, (function () { return function (t) { var e = {}; function r(n) { if (e[n]) return e[n].exports; var o = e[n] = { i: n, l: !1, exports: {} }; return t[n].call(o.exports, o, o.exports, r), o.l = !0, o.exports } return r.m = t, r.c = e, r.d = function (t, e, n) { r.o(t, e) || Object.defineProperty(t, e, { enumerable: !0, get: n }) }, r.r = function (t) { "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t, "__esModule", { value: !0 }) }, r.t = function (t, e) { if (1 & e && (t = r(t)), 8 & e) return t; if (4 & e && "object" == typeof t && t && t.__esModule) return t; var n = Object.create(null); if (r.r(n), Object.defineProperty(n, "default", { enumerable: !0, value: t }), 2 & e && "string" != typeof t) for (var o in t) r.d(n, o, function (e) { return t[e] }.bind(null, o)); return n }, r.n = function (t) { var e = t && t.__esModule ? function () { return t.default } : function () { return t }; return r.d(e, "a", e), e }, r.o = function (t, e) { return Object.prototype.hasOwnProperty.call(t, e) }, r.p = "", r(r.s = 0) }([function (t, e, r) { var n, o; n = [r(1), r(3)], void 0 === (o = function (e, n) { "use strict"; var o = r(4); e = o(e), n = o(n); var i, a = null, u = []; function c() { return f.apply(this, arguments) } function f() { return (f = (0, n.default)(e.default.mark((function t() { var r, n; return e.default.wrap((function (t) { for (; ;)switch (t.prev = t.next) { case 0: if (n = function (t) { var e = t.candidate; e && "udp" == e.protocol && (a = e.foundation, u.forEach((function (t) { return t(a) })), u.length = 0) }, !i) { t.next = 3; break } return t.abrupt("return"); case 3: return (i = new RTCPeerConnection([{ sdpSemantics: "unified-plan" }, { sdpSemantics: "plan-b" }][0])).addEventListener("icecandidate", n), t.next = 8, i.createOffer({ offerToReceiveAudio: 1, offerToReceiveVideo: 1 }); case 8: r = t.sent, i.setLocalDescription(r); case 10: case "end": return t.stop() } }), t) })))).apply(this, arguments) } function s() { return (s = (0, n.default)(e.default.mark((function t() { var r; return e.default.wrap((function (t) { for (; ;)switch (t.prev = t.next) { case 0: if ("undefined" != typeof RTCPeerConnection) { t.next = 2; break } throw new Error("This browser doesn't support WebRTC, so biri cannot provide a unique, static ID for this machine."); case 2: if (!a) { t.next = 4; break } return t.abrupt("return", a); case 4: return r = new Promise((function (t) { c(), u.push(t) })), t.abrupt("return", r); case 6: case "end": return t.stop() } }), t) })))).apply(this, arguments) } t.exports = function () { return s.apply(this, arguments) } }.apply(e, n)) || (t.exports = o) }, function (t, e, r) { t.exports = r(2) }, function (t, e, r) { var n = function (t) { "use strict"; var e = Object.prototype, r = e.hasOwnProperty, n = "function" == typeof Symbol ? Symbol : {}, o = n.iterator || "@@iterator", i = n.asyncIterator || "@@asyncIterator", a = n.toStringTag || "@@toStringTag"; function u(t, e, r, n) { var o = e && e.prototype instanceof s ? e : s, i = Object.create(o.prototype), a = new L(n || []); return i._invoke = function (t, e, r) { var n = "suspendedStart"; return function (o, i) { if ("executing" === n) throw new Error("Generator is already running"); if ("completed" === n) { if ("throw" === o) throw i; return _() } for (r.method = o, r.arg = i; ;) { var a = r.delegate; if (a) { var u = w(a, r); if (u) { if (u === f) continue; return u } } if ("next" === r.method) r.sent = r._sent = r.arg; else if ("throw" === r.method) { if ("suspendedStart" === n) throw n = "completed", r.arg; r.dispatchException(r.arg) } else "return" === r.method && r.abrupt("return", r.arg); n = "executing"; var s = c(t, e, r); if ("normal" === s.type) { if (n = r.done ? "completed" : "suspendedYield", s.arg === f) continue; return { value: s.arg, done: r.done } } "throw" === s.type && (n = "completed", r.method = "throw", r.arg = s.arg) } } }(t, r, a), i } function c(t, e, r) { try { return { type: "normal", arg: t.call(e, r) } } catch (t) { return { type: "throw", arg: t } } } t.wrap = u; var f = {}; function s() { } function l() { } function h() { } var p = {}; p[o] = function () { return this }; var d = Object.getPrototypeOf, v = d && d(d(E([]))); v && v !== e && r.call(v, o) && (p = v); var y = h.prototype = s.prototype = Object.create(p); function m(t) { ["next", "throw", "return"].forEach((function (e) { t[e] = function (t) { return this._invoke(e, t) } })) } function g(t, e) { var n; this._invoke = function (o, i) { function a() { return new e((function (n, a) { !function n(o, i, a, u) { var f = c(t[o], t, i); if ("throw" !== f.type) { var s = f.arg, l = s.value; return l && "object" == typeof l && r.call(l, "__await") ? e.resolve(l.__await).then((function (t) { n("next", t, a, u) }), (function (t) { n("throw", t, a, u) })) : e.resolve(l).then((function (t) { s.value = t, a(s) }), (function (t) { return n("throw", t, a, u) })) } u(f.arg) }(o, i, n, a) })) } return n = n ? n.then(a, a) : a() } } function w(t, e) { var r = t.iterator[e.method]; if (void 0 === r) { if (e.delegate = null, "throw" === e.method) { if (t.iterator.return && (e.method = "return", e.arg = void 0, w(t, e), "throw" === e.method)) return f; e.method = "throw", e.arg = new TypeError("The iterator does not provide a 'throw' method") } return f } var n = c(r, t.iterator, e.arg); if ("throw" === n.type) return e.method = "throw", e.arg = n.arg, e.delegate = null, f; var o = n.arg; return o ? o.done ? (e[t.resultName] = o.value, e.next = t.nextLoc, "return" !== e.method && (e.method = "next", e.arg = void 0), e.delegate = null, f) : o : (e.method = "throw", e.arg = new TypeError("iterator result is not an object"), e.delegate = null, f) } function x(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e) } function b(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e } function L(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(x, this), this.reset(!0) } function E(t) { if (t) { var e = t[o]; if (e) return e.call(t); if ("function" == typeof t.next) return t; if (!isNaN(t.length)) { var n = -1, i = function e() { for (; ++n < t.length;)if (r.call(t, n)) return e.value = t[n], e.done = !1, e; return e.value = void 0, e.done = !0, e }; return i.next = i } } return { next: _ } } function _() { return { value: void 0, done: !0 } } return l.prototype = y.constructor = h, h.constructor = l, h[a] = l.displayName = "GeneratorFunction", t.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === l || "GeneratorFunction" === (e.displayName || e.name)) }, t.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, h) : (t.__proto__ = h, a in t || (t[a] = "GeneratorFunction")), t.prototype = Object.create(y), t }, t.awrap = function (t) { return { __await: t } }, m(g.prototype), g.prototype[i] = function () { return this }, t.AsyncIterator = g, t.async = function (e, r, n, o, i) { void 0 === i && (i = Promise); var a = new g(u(e, r, n, o), i); return t.isGeneratorFunction(r) ? a : a.next().then((function (t) { return t.done ? t.value : a.next() })) }, m(y), y[a] = "Generator", y[o] = function () { return this }, y.toString = function () { return "[object Generator]" }, t.keys = function (t) { var e = []; for (var r in t) e.push(r); return e.reverse(), function r() { for (; e.length;) { var n = e.pop(); if (n in t) return r.value = n, r.done = !1, r } return r.done = !0, r } }, t.values = E, L.prototype = { constructor: L, reset: function (t) { if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = !1, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(b), !t) for (var e in this) "t" === e.charAt(0) && r.call(this, e) && !isNaN(+e.slice(1)) && (this[e] = void 0) }, stop: function () { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval }, dispatchException: function (t) { if (this.done) throw t; var e = this; function n(r, n) { return a.type = "throw", a.arg = t, e.next = r, n && (e.method = "next", e.arg = void 0), !!n } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return n("end"); if (i.tryLoc <= this.prev) { var u = r.call(i, "catchLoc"), c = r.call(i, "finallyLoc"); if (u && c) { if (this.prev < i.catchLoc) return n(i.catchLoc, !0); if (this.prev < i.finallyLoc) return n(i.finallyLoc) } else if (u) { if (this.prev < i.catchLoc) return n(i.catchLoc, !0) } else { if (!c) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return n(i.finallyLoc) } } } }, abrupt: function (t, e) { for (var n = this.tryEntries.length - 1; n >= 0; --n) { var o = this.tryEntries[n]; if (o.tryLoc <= this.prev && r.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, f) : this.complete(a) }, complete: function (t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), f }, finish: function (t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), b(r), f } }, catch: function (t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; b(r) } return o } } throw new Error("illegal catch attempt") }, delegateYield: function (t, e, r) { return this.delegate = { iterator: E(t), resultName: e, nextLoc: r }, "next" === this.method && (this.arg = void 0), f } }, t }(t.exports); try { regeneratorRuntime = n } catch (t) { Function("r", "regeneratorRuntime = r")(n) } }, function (t, e) { function r(t, e, r, n, o, i, a) { try { var u = t[i](a), c = u.value } catch (t) { return void r(t) } u.done ? e(c) : Promise.resolve(c).then(n, o) } t.exports = function (t) { return function () { var e = this, n = arguments; return new Promise((function (o, i) { var a = t.apply(e, n); function u(t) { r(a, o, i, u, c, "next", t) } function c(t) { r(a, o, i, u, c, "throw", t) } u(void 0) })) } } }, function (t, e) { t.exports = function (t) { return t && t.__esModule ? t : { default: t } } }]) }));
    /* CryptoJS */ !function (t, e) { "object" == typeof exports ? module.exports = exports = e() : "function" == typeof define && define.amd ? define([], e) : t.CryptoJS = e() }(this, function () { var h, t, e, r, i, n, f, o, s, c, a, l, d, m, x, b, H, z, A, u, p, _, v, y, g, B, w, k, S, C, D, E, R, M, F, P, W, O, I, U, K, X, L, j, N, T, q, Z, V, G, J, $, Q, Y, tt, et, rt, it, nt, ot, st, ct, at, ht, lt, ft, dt, ut, pt, _t, vt, yt, gt, Bt, wt, kt, St, bt = bt || function (l) { var t; if ("undefined" != typeof window && window.crypto && (t = window.crypto), !t && "undefined" != typeof window && window.msCrypto && (t = window.msCrypto), !t && "undefined" != typeof global && global.crypto && (t = global.crypto), !t && "function" == typeof require) try { t = require("crypto") } catch (t) { } function i() { if (t) { if ("function" == typeof t.getRandomValues) try { return t.getRandomValues(new Uint32Array(1))[0] } catch (t) { } if ("function" == typeof t.randomBytes) try { return t.randomBytes(4).readInt32LE() } catch (t) { } } throw new Error("Native crypto module could not be used to get secure random number.") } var r = Object.create || function (t) { var e; return n.prototype = t, e = new n, n.prototype = null, e }; function n() { } var e = {}, o = e.lib = {}, s = o.Base = { extend: function (t) { var e = r(this); return t && e.mixIn(t), e.hasOwnProperty("init") && this.init !== e.init || (e.init = function () { e.$super.init.apply(this, arguments) }), (e.init.prototype = e).$super = this, e }, create: function () { var t = this.extend(); return t.init.apply(t, arguments), t }, init: function () { }, mixIn: function (t) { for (var e in t) t.hasOwnProperty(e) && (this[e] = t[e]); t.hasOwnProperty("toString") && (this.toString = t.toString) }, clone: function () { return this.init.prototype.extend(this) } }, f = o.WordArray = s.extend({ init: function (t, e) { t = this.words = t || [], this.sigBytes = null != e ? e : 4 * t.length }, toString: function (t) { return (t || a).stringify(this) }, concat: function (t) { var e = this.words, r = t.words, i = this.sigBytes, n = t.sigBytes; if (this.clamp(), i % 4) for (var o = 0; o < n; o++) { var s = r[o >>> 2] >>> 24 - o % 4 * 8 & 255; e[i + o >>> 2] |= s << 24 - (i + o) % 4 * 8 } else for (o = 0; o < n; o += 4)e[i + o >>> 2] = r[o >>> 2]; return this.sigBytes += n, this }, clamp: function () { var t = this.words, e = this.sigBytes; t[e >>> 2] &= 4294967295 << 32 - e % 4 * 8, t.length = l.ceil(e / 4) }, clone: function () { var t = s.clone.call(this); return t.words = this.words.slice(0), t }, random: function (t) { for (var e = [], r = 0; r < t; r += 4)e.push(i()); return new f.init(e, t) } }), c = e.enc = {}, a = c.Hex = { stringify: function (t) { for (var e = t.words, r = t.sigBytes, i = [], n = 0; n < r; n++) { var o = e[n >>> 2] >>> 24 - n % 4 * 8 & 255; i.push((o >>> 4).toString(16)), i.push((15 & o).toString(16)) } return i.join("") }, parse: function (t) { for (var e = t.length, r = [], i = 0; i < e; i += 2)r[i >>> 3] |= parseInt(t.substr(i, 2), 16) << 24 - i % 8 * 4; return new f.init(r, e / 2) } }, h = c.Latin1 = { stringify: function (t) { for (var e = t.words, r = t.sigBytes, i = [], n = 0; n < r; n++) { var o = e[n >>> 2] >>> 24 - n % 4 * 8 & 255; i.push(String.fromCharCode(o)) } return i.join("") }, parse: function (t) { for (var e = t.length, r = [], i = 0; i < e; i++)r[i >>> 2] |= (255 & t.charCodeAt(i)) << 24 - i % 4 * 8; return new f.init(r, e) } }, d = c.Utf8 = { stringify: function (t) { try { return decodeURIComponent(escape(h.stringify(t))) } catch (t) { throw new Error("Malformed UTF-8 data") } }, parse: function (t) { return h.parse(unescape(encodeURIComponent(t))) } }, u = o.BufferedBlockAlgorithm = s.extend({ reset: function () { this._data = new f.init, this._nDataBytes = 0 }, _append: function (t) { "string" == typeof t && (t = d.parse(t)), this._data.concat(t), this._nDataBytes += t.sigBytes }, _process: function (t) { var e, r = this._data, i = r.words, n = r.sigBytes, o = this.blockSize, s = n / (4 * o), c = (s = t ? l.ceil(s) : l.max((0 | s) - this._minBufferSize, 0)) * o, a = l.min(4 * c, n); if (c) { for (var h = 0; h < c; h += o)this._doProcessBlock(i, h); e = i.splice(0, c), r.sigBytes -= a } return new f.init(e, a) }, clone: function () { var t = s.clone.call(this); return t._data = this._data.clone(), t }, _minBufferSize: 0 }), p = (o.Hasher = u.extend({ cfg: s.extend(), init: function (t) { this.cfg = this.cfg.extend(t), this.reset() }, reset: function () { u.reset.call(this), this._doReset() }, update: function (t) { return this._append(t), this._process(), this }, finalize: function (t) { return t && this._append(t), this._doFinalize() }, blockSize: 16, _createHelper: function (r) { return function (t, e) { return new r.init(e).finalize(t) } }, _createHmacHelper: function (r) { return function (t, e) { return new p.HMAC.init(r, e).finalize(t) } } }), e.algo = {}); return e }(Math); function mt(t, e, r) { return t ^ e ^ r } function xt(t, e, r) { return t & e | ~t & r } function Ht(t, e, r) { return (t | ~e) ^ r } function zt(t, e, r) { return t & r | e & ~r } function At(t, e, r) { return t ^ (e | ~r) } function Ct(t, e) { return t << e | t >>> 32 - e } function Dt(t, e, r, i) { var n, o = this._iv; o ? (n = o.slice(0), this._iv = void 0) : n = this._prevBlock, i.encryptBlock(n, 0); for (var s = 0; s < r; s++)t[e + s] ^= n[s] } function Et(t) { if (255 == (t >> 24 & 255)) { var e = t >> 16 & 255, r = t >> 8 & 255, i = 255 & t; 255 === e ? (e = 0, 255 === r ? (r = 0, 255 === i ? i = 0 : ++i) : ++r) : ++e, t = 0, t += e << 16, t += r << 8, t += i } else t += 1 << 24; return t } function Rt() { for (var t = this._X, e = this._C, r = 0; r < 8; r++)ft[r] = e[r]; e[0] = e[0] + 1295307597 + this._b | 0, e[1] = e[1] + 3545052371 + (e[0] >>> 0 < ft[0] >>> 0 ? 1 : 0) | 0, e[2] = e[2] + 886263092 + (e[1] >>> 0 < ft[1] >>> 0 ? 1 : 0) | 0, e[3] = e[3] + 1295307597 + (e[2] >>> 0 < ft[2] >>> 0 ? 1 : 0) | 0, e[4] = e[4] + 3545052371 + (e[3] >>> 0 < ft[3] >>> 0 ? 1 : 0) | 0, e[5] = e[5] + 886263092 + (e[4] >>> 0 < ft[4] >>> 0 ? 1 : 0) | 0, e[6] = e[6] + 1295307597 + (e[5] >>> 0 < ft[5] >>> 0 ? 1 : 0) | 0, e[7] = e[7] + 3545052371 + (e[6] >>> 0 < ft[6] >>> 0 ? 1 : 0) | 0, this._b = e[7] >>> 0 < ft[7] >>> 0 ? 1 : 0; for (r = 0; r < 8; r++) { var i = t[r] + e[r], n = 65535 & i, o = i >>> 16, s = ((n * n >>> 17) + n * o >>> 15) + o * o, c = ((4294901760 & i) * i | 0) + ((65535 & i) * i | 0); dt[r] = s ^ c } t[0] = dt[0] + (dt[7] << 16 | dt[7] >>> 16) + (dt[6] << 16 | dt[6] >>> 16) | 0, t[1] = dt[1] + (dt[0] << 8 | dt[0] >>> 24) + dt[7] | 0, t[2] = dt[2] + (dt[1] << 16 | dt[1] >>> 16) + (dt[0] << 16 | dt[0] >>> 16) | 0, t[3] = dt[3] + (dt[2] << 8 | dt[2] >>> 24) + dt[1] | 0, t[4] = dt[4] + (dt[3] << 16 | dt[3] >>> 16) + (dt[2] << 16 | dt[2] >>> 16) | 0, t[5] = dt[5] + (dt[4] << 8 | dt[4] >>> 24) + dt[3] | 0, t[6] = dt[6] + (dt[5] << 16 | dt[5] >>> 16) + (dt[4] << 16 | dt[4] >>> 16) | 0, t[7] = dt[7] + (dt[6] << 8 | dt[6] >>> 24) + dt[5] | 0 } function Mt() { for (var t = this._X, e = this._C, r = 0; r < 8; r++)wt[r] = e[r]; e[0] = e[0] + 1295307597 + this._b | 0, e[1] = e[1] + 3545052371 + (e[0] >>> 0 < wt[0] >>> 0 ? 1 : 0) | 0, e[2] = e[2] + 886263092 + (e[1] >>> 0 < wt[1] >>> 0 ? 1 : 0) | 0, e[3] = e[3] + 1295307597 + (e[2] >>> 0 < wt[2] >>> 0 ? 1 : 0) | 0, e[4] = e[4] + 3545052371 + (e[3] >>> 0 < wt[3] >>> 0 ? 1 : 0) | 0, e[5] = e[5] + 886263092 + (e[4] >>> 0 < wt[4] >>> 0 ? 1 : 0) | 0, e[6] = e[6] + 1295307597 + (e[5] >>> 0 < wt[5] >>> 0 ? 1 : 0) | 0, e[7] = e[7] + 3545052371 + (e[6] >>> 0 < wt[6] >>> 0 ? 1 : 0) | 0, this._b = e[7] >>> 0 < wt[7] >>> 0 ? 1 : 0; for (r = 0; r < 8; r++) { var i = t[r] + e[r], n = 65535 & i, o = i >>> 16, s = ((n * n >>> 17) + n * o >>> 15) + o * o, c = ((4294901760 & i) * i | 0) + ((65535 & i) * i | 0); kt[r] = s ^ c } t[0] = kt[0] + (kt[7] << 16 | kt[7] >>> 16) + (kt[6] << 16 | kt[6] >>> 16) | 0, t[1] = kt[1] + (kt[0] << 8 | kt[0] >>> 24) + kt[7] | 0, t[2] = kt[2] + (kt[1] << 16 | kt[1] >>> 16) + (kt[0] << 16 | kt[0] >>> 16) | 0, t[3] = kt[3] + (kt[2] << 8 | kt[2] >>> 24) + kt[1] | 0, t[4] = kt[4] + (kt[3] << 16 | kt[3] >>> 16) + (kt[2] << 16 | kt[2] >>> 16) | 0, t[5] = kt[5] + (kt[4] << 8 | kt[4] >>> 24) + kt[3] | 0, t[6] = kt[6] + (kt[5] << 16 | kt[5] >>> 16) + (kt[4] << 16 | kt[4] >>> 16) | 0, t[7] = kt[7] + (kt[6] << 8 | kt[6] >>> 24) + kt[5] | 0 } return h = bt.lib.WordArray, bt.enc.Base64 = { stringify: function (t) { var e = t.words, r = t.sigBytes, i = this._map; t.clamp(); for (var n = [], o = 0; o < r; o += 3)for (var s = (e[o >>> 2] >>> 24 - o % 4 * 8 & 255) << 16 | (e[o + 1 >>> 2] >>> 24 - (o + 1) % 4 * 8 & 255) << 8 | e[o + 2 >>> 2] >>> 24 - (o + 2) % 4 * 8 & 255, c = 0; c < 4 && o + .75 * c < r; c++)n.push(i.charAt(s >>> 6 * (3 - c) & 63)); var a = i.charAt(64); if (a) for (; n.length % 4;)n.push(a); return n.join("") }, parse: function (t) { var e = t.length, r = this._map, i = this._reverseMap; if (!i) { i = this._reverseMap = []; for (var n = 0; n < r.length; n++)i[r.charCodeAt(n)] = n } var o = r.charAt(64); if (o) { var s = t.indexOf(o); -1 !== s && (e = s) } return function (t, e, r) { for (var i = [], n = 0, o = 0; o < e; o++)if (o % 4) { var s = r[t.charCodeAt(o - 1)] << o % 4 * 2, c = r[t.charCodeAt(o)] >>> 6 - o % 4 * 2, a = s | c; i[n >>> 2] |= a << 24 - n % 4 * 8, n++ } return h.create(i, n) }(t, e, i) }, _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=" }, function (l) { var t = bt, e = t.lib, r = e.WordArray, i = e.Hasher, n = t.algo, H = []; !function () { for (var t = 0; t < 64; t++)H[t] = 4294967296 * l.abs(l.sin(t + 1)) | 0 }(); var o = n.MD5 = i.extend({ _doReset: function () { this._hash = new r.init([1732584193, 4023233417, 2562383102, 271733878]) }, _doProcessBlock: function (t, e) { for (var r = 0; r < 16; r++) { var i = e + r, n = t[i]; t[i] = 16711935 & (n << 8 | n >>> 24) | 4278255360 & (n << 24 | n >>> 8) } var o = this._hash.words, s = t[e + 0], c = t[e + 1], a = t[e + 2], h = t[e + 3], l = t[e + 4], f = t[e + 5], d = t[e + 6], u = t[e + 7], p = t[e + 8], _ = t[e + 9], v = t[e + 10], y = t[e + 11], g = t[e + 12], B = t[e + 13], w = t[e + 14], k = t[e + 15], S = o[0], m = o[1], x = o[2], b = o[3]; S = z(S, m, x, b, s, 7, H[0]), b = z(b, S, m, x, c, 12, H[1]), x = z(x, b, S, m, a, 17, H[2]), m = z(m, x, b, S, h, 22, H[3]), S = z(S, m, x, b, l, 7, H[4]), b = z(b, S, m, x, f, 12, H[5]), x = z(x, b, S, m, d, 17, H[6]), m = z(m, x, b, S, u, 22, H[7]), S = z(S, m, x, b, p, 7, H[8]), b = z(b, S, m, x, _, 12, H[9]), x = z(x, b, S, m, v, 17, H[10]), m = z(m, x, b, S, y, 22, H[11]), S = z(S, m, x, b, g, 7, H[12]), b = z(b, S, m, x, B, 12, H[13]), x = z(x, b, S, m, w, 17, H[14]), S = A(S, m = z(m, x, b, S, k, 22, H[15]), x, b, c, 5, H[16]), b = A(b, S, m, x, d, 9, H[17]), x = A(x, b, S, m, y, 14, H[18]), m = A(m, x, b, S, s, 20, H[19]), S = A(S, m, x, b, f, 5, H[20]), b = A(b, S, m, x, v, 9, H[21]), x = A(x, b, S, m, k, 14, H[22]), m = A(m, x, b, S, l, 20, H[23]), S = A(S, m, x, b, _, 5, H[24]), b = A(b, S, m, x, w, 9, H[25]), x = A(x, b, S, m, h, 14, H[26]), m = A(m, x, b, S, p, 20, H[27]), S = A(S, m, x, b, B, 5, H[28]), b = A(b, S, m, x, a, 9, H[29]), x = A(x, b, S, m, u, 14, H[30]), S = C(S, m = A(m, x, b, S, g, 20, H[31]), x, b, f, 4, H[32]), b = C(b, S, m, x, p, 11, H[33]), x = C(x, b, S, m, y, 16, H[34]), m = C(m, x, b, S, w, 23, H[35]), S = C(S, m, x, b, c, 4, H[36]), b = C(b, S, m, x, l, 11, H[37]), x = C(x, b, S, m, u, 16, H[38]), m = C(m, x, b, S, v, 23, H[39]), S = C(S, m, x, b, B, 4, H[40]), b = C(b, S, m, x, s, 11, H[41]), x = C(x, b, S, m, h, 16, H[42]), m = C(m, x, b, S, d, 23, H[43]), S = C(S, m, x, b, _, 4, H[44]), b = C(b, S, m, x, g, 11, H[45]), x = C(x, b, S, m, k, 16, H[46]), S = D(S, m = C(m, x, b, S, a, 23, H[47]), x, b, s, 6, H[48]), b = D(b, S, m, x, u, 10, H[49]), x = D(x, b, S, m, w, 15, H[50]), m = D(m, x, b, S, f, 21, H[51]), S = D(S, m, x, b, g, 6, H[52]), b = D(b, S, m, x, h, 10, H[53]), x = D(x, b, S, m, v, 15, H[54]), m = D(m, x, b, S, c, 21, H[55]), S = D(S, m, x, b, p, 6, H[56]), b = D(b, S, m, x, k, 10, H[57]), x = D(x, b, S, m, d, 15, H[58]), m = D(m, x, b, S, B, 21, H[59]), S = D(S, m, x, b, l, 6, H[60]), b = D(b, S, m, x, y, 10, H[61]), x = D(x, b, S, m, a, 15, H[62]), m = D(m, x, b, S, _, 21, H[63]), o[0] = o[0] + S | 0, o[1] = o[1] + m | 0, o[2] = o[2] + x | 0, o[3] = o[3] + b | 0 }, _doFinalize: function () { var t = this._data, e = t.words, r = 8 * this._nDataBytes, i = 8 * t.sigBytes; e[i >>> 5] |= 128 << 24 - i % 32; var n = l.floor(r / 4294967296), o = r; e[15 + (64 + i >>> 9 << 4)] = 16711935 & (n << 8 | n >>> 24) | 4278255360 & (n << 24 | n >>> 8), e[14 + (64 + i >>> 9 << 4)] = 16711935 & (o << 8 | o >>> 24) | 4278255360 & (o << 24 | o >>> 8), t.sigBytes = 4 * (e.length + 1), this._process(); for (var s = this._hash, c = s.words, a = 0; a < 4; a++) { var h = c[a]; c[a] = 16711935 & (h << 8 | h >>> 24) | 4278255360 & (h << 24 | h >>> 8) } return s }, clone: function () { var t = i.clone.call(this); return t._hash = this._hash.clone(), t } }); function z(t, e, r, i, n, o, s) { var c = t + (e & r | ~e & i) + n + s; return (c << o | c >>> 32 - o) + e } function A(t, e, r, i, n, o, s) { var c = t + (e & i | r & ~i) + n + s; return (c << o | c >>> 32 - o) + e } function C(t, e, r, i, n, o, s) { var c = t + (e ^ r ^ i) + n + s; return (c << o | c >>> 32 - o) + e } function D(t, e, r, i, n, o, s) { var c = t + (r ^ (e | ~i)) + n + s; return (c << o | c >>> 32 - o) + e } t.MD5 = i._createHelper(o), t.HmacMD5 = i._createHmacHelper(o) }(Math), e = (t = bt).lib, r = e.WordArray, i = e.Hasher, n = t.algo, f = [], o = n.SHA1 = i.extend({ _doReset: function () { this._hash = new r.init([1732584193, 4023233417, 2562383102, 271733878, 3285377520]) }, _doProcessBlock: function (t, e) { for (var r = this._hash.words, i = r[0], n = r[1], o = r[2], s = r[3], c = r[4], a = 0; a < 80; a++) { if (a < 16) f[a] = 0 | t[e + a]; else { var h = f[a - 3] ^ f[a - 8] ^ f[a - 14] ^ f[a - 16]; f[a] = h << 1 | h >>> 31 } var l = (i << 5 | i >>> 27) + c + f[a]; l += a < 20 ? 1518500249 + (n & o | ~n & s) : a < 40 ? 1859775393 + (n ^ o ^ s) : a < 60 ? (n & o | n & s | o & s) - 1894007588 : (n ^ o ^ s) - 899497514, c = s, s = o, o = n << 30 | n >>> 2, n = i, i = l } r[0] = r[0] + i | 0, r[1] = r[1] + n | 0, r[2] = r[2] + o | 0, r[3] = r[3] + s | 0, r[4] = r[4] + c | 0 }, _doFinalize: function () { var t = this._data, e = t.words, r = 8 * this._nDataBytes, i = 8 * t.sigBytes; return e[i >>> 5] |= 128 << 24 - i % 32, e[14 + (64 + i >>> 9 << 4)] = Math.floor(r / 4294967296), e[15 + (64 + i >>> 9 << 4)] = r, t.sigBytes = 4 * e.length, this._process(), this._hash }, clone: function () { var t = i.clone.call(this); return t._hash = this._hash.clone(), t } }), t.SHA1 = i._createHelper(o), t.HmacSHA1 = i._createHmacHelper(o), function (n) { var t = bt, e = t.lib, r = e.WordArray, i = e.Hasher, o = t.algo, s = [], B = []; !function () { function t(t) { for (var e = n.sqrt(t), r = 2; r <= e; r++)if (!(t % r)) return; return 1 } function e(t) { return 4294967296 * (t - (0 | t)) | 0 } for (var r = 2, i = 0; i < 64;)t(r) && (i < 8 && (s[i] = e(n.pow(r, .5))), B[i] = e(n.pow(r, 1 / 3)), i++), r++ }(); var w = [], c = o.SHA256 = i.extend({ _doReset: function () { this._hash = new r.init(s.slice(0)) }, _doProcessBlock: function (t, e) { for (var r = this._hash.words, i = r[0], n = r[1], o = r[2], s = r[3], c = r[4], a = r[5], h = r[6], l = r[7], f = 0; f < 64; f++) { if (f < 16) w[f] = 0 | t[e + f]; else { var d = w[f - 15], u = (d << 25 | d >>> 7) ^ (d << 14 | d >>> 18) ^ d >>> 3, p = w[f - 2], _ = (p << 15 | p >>> 17) ^ (p << 13 | p >>> 19) ^ p >>> 10; w[f] = u + w[f - 7] + _ + w[f - 16] } var v = i & n ^ i & o ^ n & o, y = (i << 30 | i >>> 2) ^ (i << 19 | i >>> 13) ^ (i << 10 | i >>> 22), g = l + ((c << 26 | c >>> 6) ^ (c << 21 | c >>> 11) ^ (c << 7 | c >>> 25)) + (c & a ^ ~c & h) + B[f] + w[f]; l = h, h = a, a = c, c = s + g | 0, s = o, o = n, n = i, i = g + (y + v) | 0 } r[0] = r[0] + i | 0, r[1] = r[1] + n | 0, r[2] = r[2] + o | 0, r[3] = r[3] + s | 0, r[4] = r[4] + c | 0, r[5] = r[5] + a | 0, r[6] = r[6] + h | 0, r[7] = r[7] + l | 0 }, _doFinalize: function () { var t = this._data, e = t.words, r = 8 * this._nDataBytes, i = 8 * t.sigBytes; return e[i >>> 5] |= 128 << 24 - i % 32, e[14 + (64 + i >>> 9 << 4)] = n.floor(r / 4294967296), e[15 + (64 + i >>> 9 << 4)] = r, t.sigBytes = 4 * e.length, this._process(), this._hash }, clone: function () { var t = i.clone.call(this); return t._hash = this._hash.clone(), t } }); t.SHA256 = i._createHelper(c), t.HmacSHA256 = i._createHmacHelper(c) }(Math), function () { var n = bt.lib.WordArray, t = bt.enc; t.Utf16 = t.Utf16BE = { stringify: function (t) { for (var e = t.words, r = t.sigBytes, i = [], n = 0; n < r; n += 2) { var o = e[n >>> 2] >>> 16 - n % 4 * 8 & 65535; i.push(String.fromCharCode(o)) } return i.join("") }, parse: function (t) { for (var e = t.length, r = [], i = 0; i < e; i++)r[i >>> 1] |= t.charCodeAt(i) << 16 - i % 2 * 16; return n.create(r, 2 * e) } }; function s(t) { return t << 8 & 4278255360 | t >>> 8 & 16711935 } t.Utf16LE = { stringify: function (t) { for (var e = t.words, r = t.sigBytes, i = [], n = 0; n < r; n += 2) { var o = s(e[n >>> 2] >>> 16 - n % 4 * 8 & 65535); i.push(String.fromCharCode(o)) } return i.join("") }, parse: function (t) { for (var e = t.length, r = [], i = 0; i < e; i++)r[i >>> 1] |= s(t.charCodeAt(i) << 16 - i % 2 * 16); return n.create(r, 2 * e) } } }(), function () { if ("function" == typeof ArrayBuffer) { var t = bt.lib.WordArray, n = t.init; (t.init = function (t) { if (t instanceof ArrayBuffer && (t = new Uint8Array(t)), (t instanceof Int8Array || "undefined" != typeof Uint8ClampedArray && t instanceof Uint8ClampedArray || t instanceof Int16Array || t instanceof Uint16Array || t instanceof Int32Array || t instanceof Uint32Array || t instanceof Float32Array || t instanceof Float64Array) && (t = new Uint8Array(t.buffer, t.byteOffset, t.byteLength)), t instanceof Uint8Array) { for (var e = t.byteLength, r = [], i = 0; i < e; i++)r[i >>> 2] |= t[i] << 24 - i % 4 * 8; n.call(this, r, e) } else n.apply(this, arguments) }).prototype = t } }(), Math, c = (s = bt).lib, a = c.WordArray, l = c.Hasher, d = s.algo, m = a.create([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13]), x = a.create([5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11]), b = a.create([11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6]), H = a.create([8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11]), z = a.create([0, 1518500249, 1859775393, 2400959708, 2840853838]), A = a.create([1352829926, 1548603684, 1836072691, 2053994217, 0]), u = d.RIPEMD160 = l.extend({ _doReset: function () { this._hash = a.create([1732584193, 4023233417, 2562383102, 271733878, 3285377520]) }, _doProcessBlock: function (t, e) { for (var r = 0; r < 16; r++) { var i = e + r, n = t[i]; t[i] = 16711935 & (n << 8 | n >>> 24) | 4278255360 & (n << 24 | n >>> 8) } var o, s, c, a, h, l, f, d, u, p, _, v = this._hash.words, y = z.words, g = A.words, B = m.words, w = x.words, k = b.words, S = H.words; l = o = v[0], f = s = v[1], d = c = v[2], u = a = v[3], p = h = v[4]; for (r = 0; r < 80; r += 1)_ = o + t[e + B[r]] | 0, _ += r < 16 ? mt(s, c, a) + y[0] : r < 32 ? xt(s, c, a) + y[1] : r < 48 ? Ht(s, c, a) + y[2] : r < 64 ? zt(s, c, a) + y[3] : At(s, c, a) + y[4], _ = (_ = Ct(_ |= 0, k[r])) + h | 0, o = h, h = a, a = Ct(c, 10), c = s, s = _, _ = l + t[e + w[r]] | 0, _ += r < 16 ? At(f, d, u) + g[0] : r < 32 ? zt(f, d, u) + g[1] : r < 48 ? Ht(f, d, u) + g[2] : r < 64 ? xt(f, d, u) + g[3] : mt(f, d, u) + g[4], _ = (_ = Ct(_ |= 0, S[r])) + p | 0, l = p, p = u, u = Ct(d, 10), d = f, f = _; _ = v[1] + c + u | 0, v[1] = v[2] + a + p | 0, v[2] = v[3] + h + l | 0, v[3] = v[4] + o + f | 0, v[4] = v[0] + s + d | 0, v[0] = _ }, _doFinalize: function () { var t = this._data, e = t.words, r = 8 * this._nDataBytes, i = 8 * t.sigBytes; e[i >>> 5] |= 128 << 24 - i % 32, e[14 + (64 + i >>> 9 << 4)] = 16711935 & (r << 8 | r >>> 24) | 4278255360 & (r << 24 | r >>> 8), t.sigBytes = 4 * (e.length + 1), this._process(); for (var n = this._hash, o = n.words, s = 0; s < 5; s++) { var c = o[s]; o[s] = 16711935 & (c << 8 | c >>> 24) | 4278255360 & (c << 24 | c >>> 8) } return n }, clone: function () { var t = l.clone.call(this); return t._hash = this._hash.clone(), t } }), s.RIPEMD160 = l._createHelper(u), s.HmacRIPEMD160 = l._createHmacHelper(u), p = bt.lib.Base, _ = bt.enc.Utf8, bt.algo.HMAC = p.extend({ init: function (t, e) { t = this._hasher = new t.init, "string" == typeof e && (e = _.parse(e)); var r = t.blockSize, i = 4 * r; e.sigBytes > i && (e = t.finalize(e)), e.clamp(); for (var n = this._oKey = e.clone(), o = this._iKey = e.clone(), s = n.words, c = o.words, a = 0; a < r; a++)s[a] ^= 1549556828, c[a] ^= 909522486; n.sigBytes = o.sigBytes = i, this.reset() }, reset: function () { var t = this._hasher; t.reset(), t.update(this._iKey) }, update: function (t) { return this._hasher.update(t), this }, finalize: function (t) { var e = this._hasher, r = e.finalize(t); return e.reset(), e.finalize(this._oKey.clone().concat(r)) } }), y = (v = bt).lib, g = y.Base, B = y.WordArray, w = v.algo, k = w.SHA1, S = w.HMAC, C = w.PBKDF2 = g.extend({ cfg: g.extend({ keySize: 4, hasher: k, iterations: 1 }), init: function (t) { this.cfg = this.cfg.extend(t) }, compute: function (t, e) { for (var r = this.cfg, i = S.create(r.hasher, t), n = B.create(), o = B.create([1]), s = n.words, c = o.words, a = r.keySize, h = r.iterations; s.length < a;) { var l = i.update(e).finalize(o); i.reset(); for (var f = l.words, d = f.length, u = l, p = 1; p < h; p++) { u = i.finalize(u), i.reset(); for (var _ = u.words, v = 0; v < d; v++)f[v] ^= _[v] } n.concat(l), c[0]++ } return n.sigBytes = 4 * a, n } }), v.PBKDF2 = function (t, e, r) { return C.create(r).compute(t, e) }, E = (D = bt).lib, R = E.Base, M = E.WordArray, F = D.algo, P = F.MD5, W = F.EvpKDF = R.extend({ cfg: R.extend({ keySize: 4, hasher: P, iterations: 1 }), init: function (t) { this.cfg = this.cfg.extend(t) }, compute: function (t, e) { for (var r, i = this.cfg, n = i.hasher.create(), o = M.create(), s = o.words, c = i.keySize, a = i.iterations; s.length < c;) { r && n.update(r), r = n.update(t).finalize(e), n.reset(); for (var h = 1; h < a; h++)r = n.finalize(r), n.reset(); o.concat(r) } return o.sigBytes = 4 * c, o } }), D.EvpKDF = function (t, e, r) { return W.create(r).compute(t, e) }, I = (O = bt).lib.WordArray, U = O.algo, K = U.SHA256, X = U.SHA224 = K.extend({ _doReset: function () { this._hash = new I.init([3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428]) }, _doFinalize: function () { var t = K._doFinalize.call(this); return t.sigBytes -= 4, t } }), O.SHA224 = K._createHelper(X), O.HmacSHA224 = K._createHmacHelper(X), L = bt.lib, j = L.Base, N = L.WordArray, (T = bt.x64 = {}).Word = j.extend({ init: function (t, e) { this.high = t, this.low = e } }), T.WordArray = j.extend({ init: function (t, e) { t = this.words = t || [], this.sigBytes = null != e ? e : 8 * t.length }, toX32: function () { for (var t = this.words, e = t.length, r = [], i = 0; i < e; i++) { var n = t[i]; r.push(n.high), r.push(n.low) } return N.create(r, this.sigBytes) }, clone: function () { for (var t = j.clone.call(this), e = t.words = this.words.slice(0), r = e.length, i = 0; i < r; i++)e[i] = e[i].clone(); return t } }), function (d) { var t = bt, e = t.lib, u = e.WordArray, i = e.Hasher, l = t.x64.Word, r = t.algo, C = [], D = [], E = []; !function () { for (var t = 1, e = 0, r = 0; r < 24; r++) { C[t + 5 * e] = (r + 1) * (r + 2) / 2 % 64; var i = (2 * t + 3 * e) % 5; t = e % 5, e = i } for (t = 0; t < 5; t++)for (e = 0; e < 5; e++)D[t + 5 * e] = e + (2 * t + 3 * e) % 5 * 5; for (var n = 1, o = 0; o < 24; o++) { for (var s = 0, c = 0, a = 0; a < 7; a++) { if (1 & n) { var h = (1 << a) - 1; h < 32 ? c ^= 1 << h : s ^= 1 << h - 32 } 128 & n ? n = n << 1 ^ 113 : n <<= 1 } E[o] = l.create(s, c) } }(); var R = []; !function () { for (var t = 0; t < 25; t++)R[t] = l.create() }(); var n = r.SHA3 = i.extend({ cfg: i.cfg.extend({ outputLength: 512 }), _doReset: function () { for (var t = this._state = [], e = 0; e < 25; e++)t[e] = new l.init; this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32 }, _doProcessBlock: function (t, e) { for (var r = this._state, i = this.blockSize / 2, n = 0; n < i; n++) { var o = t[e + 2 * n], s = t[e + 2 * n + 1]; o = 16711935 & (o << 8 | o >>> 24) | 4278255360 & (o << 24 | o >>> 8), s = 16711935 & (s << 8 | s >>> 24) | 4278255360 & (s << 24 | s >>> 8), (x = r[n]).high ^= s, x.low ^= o } for (var c = 0; c < 24; c++) { for (var a = 0; a < 5; a++) { for (var h = 0, l = 0, f = 0; f < 5; f++) { h ^= (x = r[a + 5 * f]).high, l ^= x.low } var d = R[a]; d.high = h, d.low = l } for (a = 0; a < 5; a++) { var u = R[(a + 4) % 5], p = R[(a + 1) % 5], _ = p.high, v = p.low; for (h = u.high ^ (_ << 1 | v >>> 31), l = u.low ^ (v << 1 | _ >>> 31), f = 0; f < 5; f++) { (x = r[a + 5 * f]).high ^= h, x.low ^= l } } for (var y = 1; y < 25; y++) { var g = (x = r[y]).high, B = x.low, w = C[y]; l = w < 32 ? (h = g << w | B >>> 32 - w, B << w | g >>> 32 - w) : (h = B << w - 32 | g >>> 64 - w, g << w - 32 | B >>> 64 - w); var k = R[D[y]]; k.high = h, k.low = l } var S = R[0], m = r[0]; S.high = m.high, S.low = m.low; for (a = 0; a < 5; a++)for (f = 0; f < 5; f++) { var x = r[y = a + 5 * f], b = R[y], H = R[(a + 1) % 5 + 5 * f], z = R[(a + 2) % 5 + 5 * f]; x.high = b.high ^ ~H.high & z.high, x.low = b.low ^ ~H.low & z.low } x = r[0]; var A = E[c]; x.high ^= A.high, x.low ^= A.low } }, _doFinalize: function () { var t = this._data, e = t.words, r = (this._nDataBytes, 8 * t.sigBytes), i = 32 * this.blockSize; e[r >>> 5] |= 1 << 24 - r % 32, e[(d.ceil((1 + r) / i) * i >>> 5) - 1] |= 128, t.sigBytes = 4 * e.length, this._process(); for (var n = this._state, o = this.cfg.outputLength / 8, s = o / 8, c = [], a = 0; a < s; a++) { var h = n[a], l = h.high, f = h.low; l = 16711935 & (l << 8 | l >>> 24) | 4278255360 & (l << 24 | l >>> 8), f = 16711935 & (f << 8 | f >>> 24) | 4278255360 & (f << 24 | f >>> 8), c.push(f), c.push(l) } return new u.init(c, o) }, clone: function () { for (var t = i.clone.call(this), e = t._state = this._state.slice(0), r = 0; r < 25; r++)e[r] = e[r].clone(); return t } }); t.SHA3 = i._createHelper(n), t.HmacSHA3 = i._createHmacHelper(n) }(Math), function () { var t = bt, e = t.lib.Hasher, r = t.x64, i = r.Word, n = r.WordArray, o = t.algo; function s() { return i.create.apply(i, arguments) } var mt = [s(1116352408, 3609767458), s(1899447441, 602891725), s(3049323471, 3964484399), s(3921009573, 2173295548), s(961987163, 4081628472), s(1508970993, 3053834265), s(2453635748, 2937671579), s(2870763221, 3664609560), s(3624381080, 2734883394), s(310598401, 1164996542), s(607225278, 1323610764), s(1426881987, 3590304994), s(1925078388, 4068182383), s(2162078206, 991336113), s(2614888103, 633803317), s(3248222580, 3479774868), s(3835390401, 2666613458), s(4022224774, 944711139), s(264347078, 2341262773), s(604807628, 2007800933), s(770255983, 1495990901), s(1249150122, 1856431235), s(1555081692, 3175218132), s(1996064986, 2198950837), s(2554220882, 3999719339), s(2821834349, 766784016), s(2952996808, 2566594879), s(3210313671, 3203337956), s(3336571891, 1034457026), s(3584528711, 2466948901), s(113926993, 3758326383), s(338241895, 168717936), s(666307205, 1188179964), s(773529912, 1546045734), s(1294757372, 1522805485), s(1396182291, 2643833823), s(1695183700, 2343527390), s(1986661051, 1014477480), s(2177026350, 1206759142), s(2456956037, 344077627), s(2730485921, 1290863460), s(2820302411, 3158454273), s(3259730800, 3505952657), s(3345764771, 106217008), s(3516065817, 3606008344), s(3600352804, 1432725776), s(4094571909, 1467031594), s(275423344, 851169720), s(430227734, 3100823752), s(506948616, 1363258195), s(659060556, 3750685593), s(883997877, 3785050280), s(958139571, 3318307427), s(1322822218, 3812723403), s(1537002063, 2003034995), s(1747873779, 3602036899), s(1955562222, 1575990012), s(2024104815, 1125592928), s(2227730452, 2716904306), s(2361852424, 442776044), s(2428436474, 593698344), s(2756734187, 3733110249), s(3204031479, 2999351573), s(3329325298, 3815920427), s(3391569614, 3928383900), s(3515267271, 566280711), s(3940187606, 3454069534), s(4118630271, 4000239992), s(116418474, 1914138554), s(174292421, 2731055270), s(289380356, 3203993006), s(460393269, 320620315), s(685471733, 587496836), s(852142971, 1086792851), s(1017036298, 365543100), s(1126000580, 2618297676), s(1288033470, 3409855158), s(1501505948, 4234509866), s(1607167915, 987167468), s(1816402316, 1246189591)], xt = []; !function () { for (var t = 0; t < 80; t++)xt[t] = s() }(); var c = o.SHA512 = e.extend({ _doReset: function () { this._hash = new n.init([new i.init(1779033703, 4089235720), new i.init(3144134277, 2227873595), new i.init(1013904242, 4271175723), new i.init(2773480762, 1595750129), new i.init(1359893119, 2917565137), new i.init(2600822924, 725511199), new i.init(528734635, 4215389547), new i.init(1541459225, 327033209)]) }, _doProcessBlock: function (t, e) { for (var r = this._hash.words, i = r[0], n = r[1], o = r[2], s = r[3], c = r[4], a = r[5], h = r[6], l = r[7], f = i.high, d = i.low, u = n.high, p = n.low, _ = o.high, v = o.low, y = s.high, g = s.low, B = c.high, w = c.low, k = a.high, S = a.low, m = h.high, x = h.low, b = l.high, H = l.low, z = f, A = d, C = u, D = p, E = _, R = v, M = y, F = g, P = B, W = w, O = k, I = S, U = m, K = x, X = b, L = H, j = 0; j < 80; j++) { var N, T, q = xt[j]; if (j < 16) T = q.high = 0 | t[e + 2 * j], N = q.low = 0 | t[e + 2 * j + 1]; else { var Z = xt[j - 15], V = Z.high, G = Z.low, J = (V >>> 1 | G << 31) ^ (V >>> 8 | G << 24) ^ V >>> 7, $ = (G >>> 1 | V << 31) ^ (G >>> 8 | V << 24) ^ (G >>> 7 | V << 25), Q = xt[j - 2], Y = Q.high, tt = Q.low, et = (Y >>> 19 | tt << 13) ^ (Y << 3 | tt >>> 29) ^ Y >>> 6, rt = (tt >>> 19 | Y << 13) ^ (tt << 3 | Y >>> 29) ^ (tt >>> 6 | Y << 26), it = xt[j - 7], nt = it.high, ot = it.low, st = xt[j - 16], ct = st.high, at = st.low; T = (T = (T = J + nt + ((N = $ + ot) >>> 0 < $ >>> 0 ? 1 : 0)) + et + ((N += rt) >>> 0 < rt >>> 0 ? 1 : 0)) + ct + ((N += at) >>> 0 < at >>> 0 ? 1 : 0), q.high = T, q.low = N } var ht, lt = P & O ^ ~P & U, ft = W & I ^ ~W & K, dt = z & C ^ z & E ^ C & E, ut = A & D ^ A & R ^ D & R, pt = (z >>> 28 | A << 4) ^ (z << 30 | A >>> 2) ^ (z << 25 | A >>> 7), _t = (A >>> 28 | z << 4) ^ (A << 30 | z >>> 2) ^ (A << 25 | z >>> 7), vt = (P >>> 14 | W << 18) ^ (P >>> 18 | W << 14) ^ (P << 23 | W >>> 9), yt = (W >>> 14 | P << 18) ^ (W >>> 18 | P << 14) ^ (W << 23 | P >>> 9), gt = mt[j], Bt = gt.high, wt = gt.low, kt = X + vt + ((ht = L + yt) >>> 0 < L >>> 0 ? 1 : 0), St = _t + ut; X = U, L = K, U = O, K = I, O = P, I = W, P = M + (kt = (kt = (kt = kt + lt + ((ht = ht + ft) >>> 0 < ft >>> 0 ? 1 : 0)) + Bt + ((ht = ht + wt) >>> 0 < wt >>> 0 ? 1 : 0)) + T + ((ht = ht + N) >>> 0 < N >>> 0 ? 1 : 0)) + ((W = F + ht | 0) >>> 0 < F >>> 0 ? 1 : 0) | 0, M = E, F = R, E = C, R = D, C = z, D = A, z = kt + (pt + dt + (St >>> 0 < _t >>> 0 ? 1 : 0)) + ((A = ht + St | 0) >>> 0 < ht >>> 0 ? 1 : 0) | 0 } d = i.low = d + A, i.high = f + z + (d >>> 0 < A >>> 0 ? 1 : 0), p = n.low = p + D, n.high = u + C + (p >>> 0 < D >>> 0 ? 1 : 0), v = o.low = v + R, o.high = _ + E + (v >>> 0 < R >>> 0 ? 1 : 0), g = s.low = g + F, s.high = y + M + (g >>> 0 < F >>> 0 ? 1 : 0), w = c.low = w + W, c.high = B + P + (w >>> 0 < W >>> 0 ? 1 : 0), S = a.low = S + I, a.high = k + O + (S >>> 0 < I >>> 0 ? 1 : 0), x = h.low = x + K, h.high = m + U + (x >>> 0 < K >>> 0 ? 1 : 0), H = l.low = H + L, l.high = b + X + (H >>> 0 < L >>> 0 ? 1 : 0) }, _doFinalize: function () { var t = this._data, e = t.words, r = 8 * this._nDataBytes, i = 8 * t.sigBytes; return e[i >>> 5] |= 128 << 24 - i % 32, e[30 + (128 + i >>> 10 << 5)] = Math.floor(r / 4294967296), e[31 + (128 + i >>> 10 << 5)] = r, t.sigBytes = 4 * e.length, this._process(), this._hash.toX32() }, clone: function () { var t = e.clone.call(this); return t._hash = this._hash.clone(), t }, blockSize: 32 }); t.SHA512 = e._createHelper(c), t.HmacSHA512 = e._createHmacHelper(c) }(), Z = (q = bt).x64, V = Z.Word, G = Z.WordArray, J = q.algo, $ = J.SHA512, Q = J.SHA384 = $.extend({ _doReset: function () { this._hash = new G.init([new V.init(3418070365, 3238371032), new V.init(1654270250, 914150663), new V.init(2438529370, 812702999), new V.init(355462360, 4144912697), new V.init(1731405415, 4290775857), new V.init(2394180231, 1750603025), new V.init(3675008525, 1694076839), new V.init(1203062813, 3204075428)]) }, _doFinalize: function () { var t = $._doFinalize.call(this); return t.sigBytes -= 16, t } }), q.SHA384 = $._createHelper(Q), q.HmacSHA384 = $._createHmacHelper(Q), bt.lib.Cipher || function () { var t = bt, e = t.lib, r = e.Base, a = e.WordArray, i = e.BufferedBlockAlgorithm, n = t.enc, o = (n.Utf8, n.Base64), s = t.algo.EvpKDF, c = e.Cipher = i.extend({ cfg: r.extend(), createEncryptor: function (t, e) { return this.create(this._ENC_XFORM_MODE, t, e) }, createDecryptor: function (t, e) { return this.create(this._DEC_XFORM_MODE, t, e) }, init: function (t, e, r) { this.cfg = this.cfg.extend(r), this._xformMode = t, this._key = e, this.reset() }, reset: function () { i.reset.call(this), this._doReset() }, process: function (t) { return this._append(t), this._process() }, finalize: function (t) { return t && this._append(t), this._doFinalize() }, keySize: 4, ivSize: 4, _ENC_XFORM_MODE: 1, _DEC_XFORM_MODE: 2, _createHelper: function (i) { return { encrypt: function (t, e, r) { return h(e).encrypt(i, t, e, r) }, decrypt: function (t, e, r) { return h(e).decrypt(i, t, e, r) } } } }); function h(t) { return "string" == typeof t ? w : g } e.StreamCipher = c.extend({ _doFinalize: function () { return this._process(!0) }, blockSize: 1 }); var l, f = t.mode = {}, d = e.BlockCipherMode = r.extend({ createEncryptor: function (t, e) { return this.Encryptor.create(t, e) }, createDecryptor: function (t, e) { return this.Decryptor.create(t, e) }, init: function (t, e) { this._cipher = t, this._iv = e } }), u = f.CBC = ((l = d.extend()).Encryptor = l.extend({ processBlock: function (t, e) { var r = this._cipher, i = r.blockSize; p.call(this, t, e, i), r.encryptBlock(t, e), this._prevBlock = t.slice(e, e + i) } }), l.Decryptor = l.extend({ processBlock: function (t, e) { var r = this._cipher, i = r.blockSize, n = t.slice(e, e + i); r.decryptBlock(t, e), p.call(this, t, e, i), this._prevBlock = n } }), l); function p(t, e, r) { var i, n = this._iv; n ? (i = n, this._iv = void 0) : i = this._prevBlock; for (var o = 0; o < r; o++)t[e + o] ^= i[o] } var _ = (t.pad = {}).Pkcs7 = { pad: function (t, e) { for (var r = 4 * e, i = r - t.sigBytes % r, n = i << 24 | i << 16 | i << 8 | i, o = [], s = 0; s < i; s += 4)o.push(n); var c = a.create(o, i); t.concat(c) }, unpad: function (t) { var e = 255 & t.words[t.sigBytes - 1 >>> 2]; t.sigBytes -= e } }, v = (e.BlockCipher = c.extend({ cfg: c.cfg.extend({ mode: u, padding: _ }), reset: function () { var t; c.reset.call(this); var e = this.cfg, r = e.iv, i = e.mode; this._xformMode == this._ENC_XFORM_MODE ? t = i.createEncryptor : (t = i.createDecryptor, this._minBufferSize = 1), this._mode && this._mode.__creator == t ? this._mode.init(this, r && r.words) : (this._mode = t.call(i, this, r && r.words), this._mode.__creator = t) }, _doProcessBlock: function (t, e) { this._mode.processBlock(t, e) }, _doFinalize: function () { var t, e = this.cfg.padding; return this._xformMode == this._ENC_XFORM_MODE ? (e.pad(this._data, this.blockSize), t = this._process(!0)) : (t = this._process(!0), e.unpad(t)), t }, blockSize: 4 }), e.CipherParams = r.extend({ init: function (t) { this.mixIn(t) }, toString: function (t) { return (t || this.formatter).stringify(this) } })), y = (t.format = {}).OpenSSL = { stringify: function (t) { var e = t.ciphertext, r = t.salt; return (r ? a.create([1398893684, 1701076831]).concat(r).concat(e) : e).toString(o) }, parse: function (t) { var e, r = o.parse(t), i = r.words; return 1398893684 == i[0] && 1701076831 == i[1] && (e = a.create(i.slice(2, 4)), i.splice(0, 4), r.sigBytes -= 16), v.create({ ciphertext: r, salt: e }) } }, g = e.SerializableCipher = r.extend({ cfg: r.extend({ format: y }), encrypt: function (t, e, r, i) { i = this.cfg.extend(i); var n = t.createEncryptor(r, i), o = n.finalize(e), s = n.cfg; return v.create({ ciphertext: o, key: r, iv: s.iv, algorithm: t, mode: s.mode, padding: s.padding, blockSize: t.blockSize, formatter: i.format }) }, decrypt: function (t, e, r, i) { return i = this.cfg.extend(i), e = this._parse(e, i.format), t.createDecryptor(r, i).finalize(e.ciphertext) }, _parse: function (t, e) { return "string" == typeof t ? e.parse(t, this) : t } }), B = (t.kdf = {}).OpenSSL = { execute: function (t, e, r, i) { i = i || a.random(8); var n = s.create({ keySize: e + r }).compute(t, i), o = a.create(n.words.slice(e), 4 * r); return n.sigBytes = 4 * e, v.create({ key: n, iv: o, salt: i }) } }, w = e.PasswordBasedCipher = g.extend({ cfg: g.cfg.extend({ kdf: B }), encrypt: function (t, e, r, i) { var n = (i = this.cfg.extend(i)).kdf.execute(r, t.keySize, t.ivSize); i.iv = n.iv; var o = g.encrypt.call(this, t, e, n.key, i); return o.mixIn(n), o }, decrypt: function (t, e, r, i) { i = this.cfg.extend(i), e = this._parse(e, i.format); var n = i.kdf.execute(r, t.keySize, t.ivSize, e.salt); return i.iv = n.iv, g.decrypt.call(this, t, e, n.key, i) } }) }(), bt.mode.CFB = ((Y = bt.lib.BlockCipherMode.extend()).Encryptor = Y.extend({ processBlock: function (t, e) { var r = this._cipher, i = r.blockSize; Dt.call(this, t, e, i, r), this._prevBlock = t.slice(e, e + i) } }), Y.Decryptor = Y.extend({ processBlock: function (t, e) { var r = this._cipher, i = r.blockSize, n = t.slice(e, e + i); Dt.call(this, t, e, i, r), this._prevBlock = n } }), Y), bt.mode.ECB = ((tt = bt.lib.BlockCipherMode.extend()).Encryptor = tt.extend({ processBlock: function (t, e) { this._cipher.encryptBlock(t, e) } }), tt.Decryptor = tt.extend({ processBlock: function (t, e) { this._cipher.decryptBlock(t, e) } }), tt), bt.pad.AnsiX923 = { pad: function (t, e) { var r = t.sigBytes, i = 4 * e, n = i - r % i, o = r + n - 1; t.clamp(), t.words[o >>> 2] |= n << 24 - o % 4 * 8, t.sigBytes += n }, unpad: function (t) { var e = 255 & t.words[t.sigBytes - 1 >>> 2]; t.sigBytes -= e } }, bt.pad.Iso10126 = { pad: function (t, e) { var r = 4 * e, i = r - t.sigBytes % r; t.concat(bt.lib.WordArray.random(i - 1)).concat(bt.lib.WordArray.create([i << 24], 1)) }, unpad: function (t) { var e = 255 & t.words[t.sigBytes - 1 >>> 2]; t.sigBytes -= e } }, bt.pad.Iso97971 = { pad: function (t, e) { t.concat(bt.lib.WordArray.create([2147483648], 1)), bt.pad.ZeroPadding.pad(t, e) }, unpad: function (t) { bt.pad.ZeroPadding.unpad(t), t.sigBytes-- } }, bt.mode.OFB = (et = bt.lib.BlockCipherMode.extend(), rt = et.Encryptor = et.extend({ processBlock: function (t, e) { var r = this._cipher, i = r.blockSize, n = this._iv, o = this._keystream; n && (o = this._keystream = n.slice(0), this._iv = void 0), r.encryptBlock(o, 0); for (var s = 0; s < i; s++)t[e + s] ^= o[s] } }), et.Decryptor = rt, et), bt.pad.NoPadding = { pad: function () { }, unpad: function () { } }, it = bt.lib.CipherParams, nt = bt.enc.Hex, bt.format.Hex = { stringify: function (t) { return t.ciphertext.toString(nt) }, parse: function (t) { var e = nt.parse(t); return it.create({ ciphertext: e }) } }, function () { var t = bt, e = t.lib.BlockCipher, r = t.algo, h = [], l = [], f = [], d = [], u = [], p = [], _ = [], v = [], y = [], g = []; !function () { for (var t = [], e = 0; e < 256; e++)t[e] = e < 128 ? e << 1 : e << 1 ^ 283; var r = 0, i = 0; for (e = 0; e < 256; e++) { var n = i ^ i << 1 ^ i << 2 ^ i << 3 ^ i << 4; n = n >>> 8 ^ 255 & n ^ 99, h[r] = n; var o = t[l[n] = r], s = t[o], c = t[s], a = 257 * t[n] ^ 16843008 * n; f[r] = a << 24 | a >>> 8, d[r] = a << 16 | a >>> 16, u[r] = a << 8 | a >>> 24, p[r] = a; a = 16843009 * c ^ 65537 * s ^ 257 * o ^ 16843008 * r; _[n] = a << 24 | a >>> 8, v[n] = a << 16 | a >>> 16, y[n] = a << 8 | a >>> 24, g[n] = a, r ? (r = o ^ t[t[t[c ^ o]]], i ^= t[t[i]]) : r = i = 1 } }(); var B = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], i = r.AES = e.extend({ _doReset: function () { if (!this._nRounds || this._keyPriorReset !== this._key) { for (var t = this._keyPriorReset = this._key, e = t.words, r = t.sigBytes / 4, i = 4 * (1 + (this._nRounds = 6 + r)), n = this._keySchedule = [], o = 0; o < i; o++)o < r ? n[o] = e[o] : (a = n[o - 1], o % r ? 6 < r && o % r == 4 && (a = h[a >>> 24] << 24 | h[a >>> 16 & 255] << 16 | h[a >>> 8 & 255] << 8 | h[255 & a]) : (a = h[(a = a << 8 | a >>> 24) >>> 24] << 24 | h[a >>> 16 & 255] << 16 | h[a >>> 8 & 255] << 8 | h[255 & a], a ^= B[o / r | 0] << 24), n[o] = n[o - r] ^ a); for (var s = this._invKeySchedule = [], c = 0; c < i; c++) { o = i - c; if (c % 4) var a = n[o]; else a = n[o - 4]; s[c] = c < 4 || o <= 4 ? a : _[h[a >>> 24]] ^ v[h[a >>> 16 & 255]] ^ y[h[a >>> 8 & 255]] ^ g[h[255 & a]] } } }, encryptBlock: function (t, e) { this._doCryptBlock(t, e, this._keySchedule, f, d, u, p, h) }, decryptBlock: function (t, e) { var r = t[e + 1]; t[e + 1] = t[e + 3], t[e + 3] = r, this._doCryptBlock(t, e, this._invKeySchedule, _, v, y, g, l); r = t[e + 1]; t[e + 1] = t[e + 3], t[e + 3] = r }, _doCryptBlock: function (t, e, r, i, n, o, s, c) { for (var a = this._nRounds, h = t[e] ^ r[0], l = t[e + 1] ^ r[1], f = t[e + 2] ^ r[2], d = t[e + 3] ^ r[3], u = 4, p = 1; p < a; p++) { var _ = i[h >>> 24] ^ n[l >>> 16 & 255] ^ o[f >>> 8 & 255] ^ s[255 & d] ^ r[u++], v = i[l >>> 24] ^ n[f >>> 16 & 255] ^ o[d >>> 8 & 255] ^ s[255 & h] ^ r[u++], y = i[f >>> 24] ^ n[d >>> 16 & 255] ^ o[h >>> 8 & 255] ^ s[255 & l] ^ r[u++], g = i[d >>> 24] ^ n[h >>> 16 & 255] ^ o[l >>> 8 & 255] ^ s[255 & f] ^ r[u++]; h = _, l = v, f = y, d = g } _ = (c[h >>> 24] << 24 | c[l >>> 16 & 255] << 16 | c[f >>> 8 & 255] << 8 | c[255 & d]) ^ r[u++], v = (c[l >>> 24] << 24 | c[f >>> 16 & 255] << 16 | c[d >>> 8 & 255] << 8 | c[255 & h]) ^ r[u++], y = (c[f >>> 24] << 24 | c[d >>> 16 & 255] << 16 | c[h >>> 8 & 255] << 8 | c[255 & l]) ^ r[u++], g = (c[d >>> 24] << 24 | c[h >>> 16 & 255] << 16 | c[l >>> 8 & 255] << 8 | c[255 & f]) ^ r[u++]; t[e] = _, t[e + 1] = v, t[e + 2] = y, t[e + 3] = g }, keySize: 8 }); t.AES = e._createHelper(i) }(), function () { var t = bt, e = t.lib, n = e.WordArray, r = e.BlockCipher, i = t.algo, h = [57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18, 10, 2, 59, 51, 43, 35, 27, 19, 11, 3, 60, 52, 44, 36, 63, 55, 47, 39, 31, 23, 15, 7, 62, 54, 46, 38, 30, 22, 14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 28, 20, 12, 4], l = [14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21, 10, 23, 19, 12, 4, 26, 8, 16, 7, 27, 20, 13, 2, 41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48, 44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32], f = [1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28], d = [{ 0: 8421888, 268435456: 32768, 536870912: 8421378, 805306368: 2, 1073741824: 512, 1342177280: 8421890, 1610612736: 8389122, 1879048192: 8388608, 2147483648: 514, 2415919104: 8389120, 2684354560: 33280, 2952790016: 8421376, 3221225472: 32770, 3489660928: 8388610, 3758096384: 0, 4026531840: 33282, 134217728: 0, 402653184: 8421890, 671088640: 33282, 939524096: 32768, 1207959552: 8421888, 1476395008: 512, 1744830464: 8421378, 2013265920: 2, 2281701376: 8389120, 2550136832: 33280, 2818572288: 8421376, 3087007744: 8389122, 3355443200: 8388610, 3623878656: 32770, 3892314112: 514, 4160749568: 8388608, 1: 32768, 268435457: 2, 536870913: 8421888, 805306369: 8388608, 1073741825: 8421378, 1342177281: 33280, 1610612737: 512, 1879048193: 8389122, 2147483649: 8421890, 2415919105: 8421376, 2684354561: 8388610, 2952790017: 33282, 3221225473: 514, 3489660929: 8389120, 3758096385: 32770, 4026531841: 0, 134217729: 8421890, 402653185: 8421376, 671088641: 8388608, 939524097: 512, 1207959553: 32768, 1476395009: 8388610, 1744830465: 2, 2013265921: 33282, 2281701377: 32770, 2550136833: 8389122, 2818572289: 514, 3087007745: 8421888, 3355443201: 8389120, 3623878657: 0, 3892314113: 33280, 4160749569: 8421378 }, { 0: 1074282512, 16777216: 16384, 33554432: 524288, 50331648: 1074266128, 67108864: 1073741840, 83886080: 1074282496, 100663296: 1073758208, 117440512: 16, 134217728: 540672, 150994944: 1073758224, 167772160: 1073741824, 184549376: 540688, 201326592: 524304, 218103808: 0, 234881024: 16400, 251658240: 1074266112, 8388608: 1073758208, 25165824: 540688, 41943040: 16, 58720256: 1073758224, 75497472: 1074282512, 92274688: 1073741824, 109051904: 524288, 125829120: 1074266128, 142606336: 524304, 159383552: 0, 176160768: 16384, 192937984: 1074266112, 209715200: 1073741840, 226492416: 540672, 243269632: 1074282496, 260046848: 16400, 268435456: 0, 285212672: 1074266128, 301989888: 1073758224, 318767104: 1074282496, 335544320: 1074266112, 352321536: 16, 369098752: 540688, 385875968: 16384, 402653184: 16400, 419430400: 524288, 436207616: 524304, 452984832: 1073741840, 469762048: 540672, 486539264: 1073758208, 503316480: 1073741824, 520093696: 1074282512, 276824064: 540688, 293601280: 524288, 310378496: 1074266112, 327155712: 16384, 343932928: 1073758208, 360710144: 1074282512, 377487360: 16, 394264576: 1073741824, 411041792: 1074282496, 427819008: 1073741840, 444596224: 1073758224, 461373440: 524304, 478150656: 0, 494927872: 16400, 511705088: 1074266128, 528482304: 540672 }, { 0: 260, 1048576: 0, 2097152: 67109120, 3145728: 65796, 4194304: 65540, 5242880: 67108868, 6291456: 67174660, 7340032: 67174400, 8388608: 67108864, 9437184: 67174656, 10485760: 65792, 11534336: 67174404, 12582912: 67109124, 13631488: 65536, 14680064: 4, 15728640: 256, 524288: 67174656, 1572864: 67174404, 2621440: 0, 3670016: 67109120, 4718592: 67108868, 5767168: 65536, 6815744: 65540, 7864320: 260, 8912896: 4, 9961472: 256, 11010048: 67174400, 12058624: 65796, 13107200: 65792, 14155776: 67109124, 15204352: 67174660, 16252928: 67108864, 16777216: 67174656, 17825792: 65540, 18874368: 65536, 19922944: 67109120, 20971520: 256, 22020096: 67174660, 23068672: 67108868, 24117248: 0, 25165824: 67109124, 26214400: 67108864, 27262976: 4, 28311552: 65792, 29360128: 67174400, 30408704: 260, 31457280: 65796, 32505856: 67174404, 17301504: 67108864, 18350080: 260, 19398656: 67174656, 20447232: 0, 21495808: 65540, 22544384: 67109120, 23592960: 256, 24641536: 67174404, 25690112: 65536, 26738688: 67174660, 27787264: 65796, 28835840: 67108868, 29884416: 67109124, 30932992: 67174400, 31981568: 4, 33030144: 65792 }, { 0: 2151682048, 65536: 2147487808, 131072: 4198464, 196608: 2151677952, 262144: 0, 327680: 4198400, 393216: 2147483712, 458752: 4194368, 524288: 2147483648, 589824: 4194304, 655360: 64, 720896: 2147487744, 786432: 2151678016, 851968: 4160, 917504: 4096, 983040: 2151682112, 32768: 2147487808, 98304: 64, 163840: 2151678016, 229376: 2147487744, 294912: 4198400, 360448: 2151682112, 425984: 0, 491520: 2151677952, 557056: 4096, 622592: 2151682048, 688128: 4194304, 753664: 4160, 819200: 2147483648, 884736: 4194368, 950272: 4198464, 1015808: 2147483712, 1048576: 4194368, 1114112: 4198400, 1179648: 2147483712, 1245184: 0, 1310720: 4160, 1376256: 2151678016, 1441792: 2151682048, 1507328: 2147487808, 1572864: 2151682112, 1638400: 2147483648, 1703936: 2151677952, 1769472: 4198464, 1835008: 2147487744, 1900544: 4194304, 1966080: 64, 2031616: 4096, 1081344: 2151677952, 1146880: 2151682112, 1212416: 0, 1277952: 4198400, 1343488: 4194368, 1409024: 2147483648, 1474560: 2147487808, 1540096: 64, 1605632: 2147483712, 1671168: 4096, 1736704: 2147487744, 1802240: 2151678016, 1867776: 4160, 1933312: 2151682048, 1998848: 4194304, 2064384: 4198464 }, { 0: 128, 4096: 17039360, 8192: 262144, 12288: 536870912, 16384: 537133184, 20480: 16777344, 24576: 553648256, 28672: 262272, 32768: 16777216, 36864: 537133056, 40960: 536871040, 45056: 553910400, 49152: 553910272, 53248: 0, 57344: 17039488, 61440: 553648128, 2048: 17039488, 6144: 553648256, 10240: 128, 14336: 17039360, 18432: 262144, 22528: 537133184, 26624: 553910272, 30720: 536870912, 34816: 537133056, 38912: 0, 43008: 553910400, 47104: 16777344, 51200: 536871040, 55296: 553648128, 59392: 16777216, 63488: 262272, 65536: 262144, 69632: 128, 73728: 536870912, 77824: 553648256, 81920: 16777344, 86016: 553910272, 90112: 537133184, 94208: 16777216, 98304: 553910400, 102400: 553648128, 106496: 17039360, 110592: 537133056, 114688: 262272, 118784: 536871040, 122880: 0, 126976: 17039488, 67584: 553648256, 71680: 16777216, 75776: 17039360, 79872: 537133184, 83968: 536870912, 88064: 17039488, 92160: 128, 96256: 553910272, 100352: 262272, 104448: 553910400, 108544: 0, 112640: 553648128, 116736: 16777344, 120832: 262144, 124928: 537133056, 129024: 536871040 }, { 0: 268435464, 256: 8192, 512: 270532608, 768: 270540808, 1024: 268443648, 1280: 2097152, 1536: 2097160, 1792: 268435456, 2048: 0, 2304: 268443656, 2560: 2105344, 2816: 8, 3072: 270532616, 3328: 2105352, 3584: 8200, 3840: 270540800, 128: 270532608, 384: 270540808, 640: 8, 896: 2097152, 1152: 2105352, 1408: 268435464, 1664: 268443648, 1920: 8200, 2176: 2097160, 2432: 8192, 2688: 268443656, 2944: 270532616, 3200: 0, 3456: 270540800, 3712: 2105344, 3968: 268435456, 4096: 268443648, 4352: 270532616, 4608: 270540808, 4864: 8200, 5120: 2097152, 5376: 268435456, 5632: 268435464, 5888: 2105344, 6144: 2105352, 6400: 0, 6656: 8, 6912: 270532608, 7168: 8192, 7424: 268443656, 7680: 270540800, 7936: 2097160, 4224: 8, 4480: 2105344, 4736: 2097152, 4992: 268435464, 5248: 268443648, 5504: 8200, 5760: 270540808, 6016: 270532608, 6272: 270540800, 6528: 270532616, 6784: 8192, 7040: 2105352, 7296: 2097160, 7552: 0, 7808: 268435456, 8064: 268443656 }, { 0: 1048576, 16: 33555457, 32: 1024, 48: 1049601, 64: 34604033, 80: 0, 96: 1, 112: 34603009, 128: 33555456, 144: 1048577, 160: 33554433, 176: 34604032, 192: 34603008, 208: 1025, 224: 1049600, 240: 33554432, 8: 34603009, 24: 0, 40: 33555457, 56: 34604032, 72: 1048576, 88: 33554433, 104: 33554432, 120: 1025, 136: 1049601, 152: 33555456, 168: 34603008, 184: 1048577, 200: 1024, 216: 34604033, 232: 1, 248: 1049600, 256: 33554432, 272: 1048576, 288: 33555457, 304: 34603009, 320: 1048577, 336: 33555456, 352: 34604032, 368: 1049601, 384: 1025, 400: 34604033, 416: 1049600, 432: 1, 448: 0, 464: 34603008, 480: 33554433, 496: 1024, 264: 1049600, 280: 33555457, 296: 34603009, 312: 1, 328: 33554432, 344: 1048576, 360: 1025, 376: 34604032, 392: 33554433, 408: 34603008, 424: 0, 440: 34604033, 456: 1049601, 472: 1024, 488: 33555456, 504: 1048577 }, { 0: 134219808, 1: 131072, 2: 134217728, 3: 32, 4: 131104, 5: 134350880, 6: 134350848, 7: 2048, 8: 134348800, 9: 134219776, 10: 133120, 11: 134348832, 12: 2080, 13: 0, 14: 134217760, 15: 133152, 2147483648: 2048, 2147483649: 134350880, 2147483650: 134219808, 2147483651: 134217728, 2147483652: 134348800, 2147483653: 133120, 2147483654: 133152, 2147483655: 32, 2147483656: 134217760, 2147483657: 2080, 2147483658: 131104, 2147483659: 134350848, 2147483660: 0, 2147483661: 134348832, 2147483662: 134219776, 2147483663: 131072, 16: 133152, 17: 134350848, 18: 32, 19: 2048, 20: 134219776, 21: 134217760, 22: 134348832, 23: 131072, 24: 0, 25: 131104, 26: 134348800, 27: 134219808, 28: 134350880, 29: 133120, 30: 2080, 31: 134217728, 2147483664: 131072, 2147483665: 2048, 2147483666: 134348832, 2147483667: 133152, 2147483668: 32, 2147483669: 134348800, 2147483670: 134217728, 2147483671: 134219808, 2147483672: 134350880, 2147483673: 134217760, 2147483674: 134219776, 2147483675: 0, 2147483676: 133120, 2147483677: 2080, 2147483678: 131104, 2147483679: 134350848 }], u = [4160749569, 528482304, 33030144, 2064384, 129024, 8064, 504, 2147483679], o = i.DES = r.extend({ _doReset: function () { for (var t = this._key.words, e = [], r = 0; r < 56; r++) { var i = h[r] - 1; e[r] = t[i >>> 5] >>> 31 - i % 32 & 1 } for (var n = this._subKeys = [], o = 0; o < 16; o++) { var s = n[o] = [], c = f[o]; for (r = 0; r < 24; r++)s[r / 6 | 0] |= e[(l[r] - 1 + c) % 28] << 31 - r % 6, s[4 + (r / 6 | 0)] |= e[28 + (l[r + 24] - 1 + c) % 28] << 31 - r % 6; s[0] = s[0] << 1 | s[0] >>> 31; for (r = 1; r < 7; r++)s[r] = s[r] >>> 4 * (r - 1) + 3; s[7] = s[7] << 5 | s[7] >>> 27 } var a = this._invSubKeys = []; for (r = 0; r < 16; r++)a[r] = n[15 - r] }, encryptBlock: function (t, e) { this._doCryptBlock(t, e, this._subKeys) }, decryptBlock: function (t, e) { this._doCryptBlock(t, e, this._invSubKeys) }, _doCryptBlock: function (t, e, r) { this._lBlock = t[e], this._rBlock = t[e + 1], p.call(this, 4, 252645135), p.call(this, 16, 65535), _.call(this, 2, 858993459), _.call(this, 8, 16711935), p.call(this, 1, 1431655765); for (var i = 0; i < 16; i++) { for (var n = r[i], o = this._lBlock, s = this._rBlock, c = 0, a = 0; a < 8; a++)c |= d[a][((s ^ n[a]) & u[a]) >>> 0]; this._lBlock = s, this._rBlock = o ^ c } var h = this._lBlock; this._lBlock = this._rBlock, this._rBlock = h, p.call(this, 1, 1431655765), _.call(this, 8, 16711935), _.call(this, 2, 858993459), p.call(this, 16, 65535), p.call(this, 4, 252645135), t[e] = this._lBlock, t[e + 1] = this._rBlock }, keySize: 2, ivSize: 2, blockSize: 2 }); function p(t, e) { var r = (this._lBlock >>> t ^ this._rBlock) & e; this._rBlock ^= r, this._lBlock ^= r << t } function _(t, e) { var r = (this._rBlock >>> t ^ this._lBlock) & e; this._lBlock ^= r, this._rBlock ^= r << t } t.DES = r._createHelper(o); var s = i.TripleDES = r.extend({ _doReset: function () { var t = this._key.words; if (2 !== t.length && 4 !== t.length && t.length < 6) throw new Error("Invalid key length - 3DES requires the key length to be 64, 128, 192 or >192."); var e = t.slice(0, 2), r = t.length < 4 ? t.slice(0, 2) : t.slice(2, 4), i = t.length < 6 ? t.slice(0, 2) : t.slice(4, 6); this._des1 = o.createEncryptor(n.create(e)), this._des2 = o.createEncryptor(n.create(r)), this._des3 = o.createEncryptor(n.create(i)) }, encryptBlock: function (t, e) { this._des1.encryptBlock(t, e), this._des2.decryptBlock(t, e), this._des3.encryptBlock(t, e) }, decryptBlock: function (t, e) { this._des3.decryptBlock(t, e), this._des2.encryptBlock(t, e), this._des1.decryptBlock(t, e) }, keySize: 6, ivSize: 2, blockSize: 2 }); t.TripleDES = r._createHelper(s) }(), function () { var t = bt, e = t.lib.StreamCipher, r = t.algo, i = r.RC4 = e.extend({ _doReset: function () { for (var t = this._key, e = t.words, r = t.sigBytes, i = this._S = [], n = 0; n < 256; n++)i[n] = n; n = 0; for (var o = 0; n < 256; n++) { var s = n % r, c = e[s >>> 2] >>> 24 - s % 4 * 8 & 255; o = (o + i[n] + c) % 256; var a = i[n]; i[n] = i[o], i[o] = a } this._i = this._j = 0 }, _doProcessBlock: function (t, e) { t[e] ^= n.call(this) }, keySize: 8, ivSize: 0 }); function n() { for (var t = this._S, e = this._i, r = this._j, i = 0, n = 0; n < 4; n++) { r = (r + t[e = (e + 1) % 256]) % 256; var o = t[e]; t[e] = t[r], t[r] = o, i |= t[(t[e] + t[r]) % 256] << 24 - 8 * n } return this._i = e, this._j = r, i } t.RC4 = e._createHelper(i); var o = r.RC4Drop = i.extend({ cfg: i.cfg.extend({ drop: 192 }), _doReset: function () { i._doReset.call(this); for (var t = this.cfg.drop; 0 < t; t--)n.call(this) } }); t.RC4Drop = e._createHelper(o) }(), bt.mode.CTRGladman = (ot = bt.lib.BlockCipherMode.extend(), st = ot.Encryptor = ot.extend({ processBlock: function (t, e) { var r, i = this._cipher, n = i.blockSize, o = this._iv, s = this._counter; o && (s = this._counter = o.slice(0), this._iv = void 0), 0 === ((r = s)[0] = Et(r[0])) && (r[1] = Et(r[1])); var c = s.slice(0); i.encryptBlock(c, 0); for (var a = 0; a < n; a++)t[e + a] ^= c[a] } }), ot.Decryptor = st, ot), at = (ct = bt).lib.StreamCipher, ht = ct.algo, lt = [], ft = [], dt = [], ut = ht.Rabbit = at.extend({ _doReset: function () { for (var t = this._key.words, e = this.cfg.iv, r = 0; r < 4; r++)t[r] = 16711935 & (t[r] << 8 | t[r] >>> 24) | 4278255360 & (t[r] << 24 | t[r] >>> 8); var i = this._X = [t[0], t[3] << 16 | t[2] >>> 16, t[1], t[0] << 16 | t[3] >>> 16, t[2], t[1] << 16 | t[0] >>> 16, t[3], t[2] << 16 | t[1] >>> 16], n = this._C = [t[2] << 16 | t[2] >>> 16, 4294901760 & t[0] | 65535 & t[1], t[3] << 16 | t[3] >>> 16, 4294901760 & t[1] | 65535 & t[2], t[0] << 16 | t[0] >>> 16, 4294901760 & t[2] | 65535 & t[3], t[1] << 16 | t[1] >>> 16, 4294901760 & t[3] | 65535 & t[0]]; for (r = this._b = 0; r < 4; r++)Rt.call(this); for (r = 0; r < 8; r++)n[r] ^= i[r + 4 & 7]; if (e) { var o = e.words, s = o[0], c = o[1], a = 16711935 & (s << 8 | s >>> 24) | 4278255360 & (s << 24 | s >>> 8), h = 16711935 & (c << 8 | c >>> 24) | 4278255360 & (c << 24 | c >>> 8), l = a >>> 16 | 4294901760 & h, f = h << 16 | 65535 & a; n[0] ^= a, n[1] ^= l, n[2] ^= h, n[3] ^= f, n[4] ^= a, n[5] ^= l, n[6] ^= h, n[7] ^= f; for (r = 0; r < 4; r++)Rt.call(this) } }, _doProcessBlock: function (t, e) { var r = this._X; Rt.call(this), lt[0] = r[0] ^ r[5] >>> 16 ^ r[3] << 16, lt[1] = r[2] ^ r[7] >>> 16 ^ r[5] << 16, lt[2] = r[4] ^ r[1] >>> 16 ^ r[7] << 16, lt[3] = r[6] ^ r[3] >>> 16 ^ r[1] << 16; for (var i = 0; i < 4; i++)lt[i] = 16711935 & (lt[i] << 8 | lt[i] >>> 24) | 4278255360 & (lt[i] << 24 | lt[i] >>> 8), t[e + i] ^= lt[i] }, blockSize: 4, ivSize: 2 }), ct.Rabbit = at._createHelper(ut), bt.mode.CTR = (pt = bt.lib.BlockCipherMode.extend(), _t = pt.Encryptor = pt.extend({ processBlock: function (t, e) { var r = this._cipher, i = r.blockSize, n = this._iv, o = this._counter; n && (o = this._counter = n.slice(0), this._iv = void 0); var s = o.slice(0); r.encryptBlock(s, 0), o[i - 1] = o[i - 1] + 1 | 0; for (var c = 0; c < i; c++)t[e + c] ^= s[c] } }), pt.Decryptor = _t, pt), yt = (vt = bt).lib.StreamCipher, gt = vt.algo, Bt = [], wt = [], kt = [], St = gt.RabbitLegacy = yt.extend({ _doReset: function () { for (var t = this._key.words, e = this.cfg.iv, r = this._X = [t[0], t[3] << 16 | t[2] >>> 16, t[1], t[0] << 16 | t[3] >>> 16, t[2], t[1] << 16 | t[0] >>> 16, t[3], t[2] << 16 | t[1] >>> 16], i = this._C = [t[2] << 16 | t[2] >>> 16, 4294901760 & t[0] | 65535 & t[1], t[3] << 16 | t[3] >>> 16, 4294901760 & t[1] | 65535 & t[2], t[0] << 16 | t[0] >>> 16, 4294901760 & t[2] | 65535 & t[3], t[1] << 16 | t[1] >>> 16, 4294901760 & t[3] | 65535 & t[0]], n = this._b = 0; n < 4; n++)Mt.call(this); for (n = 0; n < 8; n++)i[n] ^= r[n + 4 & 7]; if (e) { var o = e.words, s = o[0], c = o[1], a = 16711935 & (s << 8 | s >>> 24) | 4278255360 & (s << 24 | s >>> 8), h = 16711935 & (c << 8 | c >>> 24) | 4278255360 & (c << 24 | c >>> 8), l = a >>> 16 | 4294901760 & h, f = h << 16 | 65535 & a; i[0] ^= a, i[1] ^= l, i[2] ^= h, i[3] ^= f, i[4] ^= a, i[5] ^= l, i[6] ^= h, i[7] ^= f; for (n = 0; n < 4; n++)Mt.call(this) } }, _doProcessBlock: function (t, e) { var r = this._X; Mt.call(this), Bt[0] = r[0] ^ r[5] >>> 16 ^ r[3] << 16, Bt[1] = r[2] ^ r[7] >>> 16 ^ r[5] << 16, Bt[2] = r[4] ^ r[1] >>> 16 ^ r[7] << 16, Bt[3] = r[6] ^ r[3] >>> 16 ^ r[1] << 16; for (var i = 0; i < 4; i++)Bt[i] = 16711935 & (Bt[i] << 8 | Bt[i] >>> 24) | 4278255360 & (Bt[i] << 24 | Bt[i] >>> 8), t[e + i] ^= Bt[i] }, blockSize: 4, ivSize: 2 }), vt.RabbitLegacy = yt._createHelper(St), bt.pad.ZeroPadding = { pad: function (t, e) { var r = 4 * e; t.clamp(), t.sigBytes += r - (t.sigBytes % r || r) }, unpad: function (t) { var e = t.words, r = t.sigBytes - 1; for (r = t.sigBytes - 1; 0 <= r; r--)if (e[r >>> 2] >>> 24 - r % 4 * 8 & 255) { t.sigBytes = r + 1; break } } }, bt });
    /* JSEncrypt */ !function (t, e) { "object" == typeof exports && "undefined" != typeof module ? e(exports) : "function" == typeof define && define.amd ? define(["exports"], e) : e(t.JSEncrypt = {}) }(this, function (t) { "use strict"; var e = "0123456789abcdefghijklmnopqrstuvwxyz"; function i(t) { return e.charAt(t) } function r(t, e) { return t & e } function n(t, e) { return t | e } function s(t, e) { return t ^ e } function o(t, e) { return t & ~e } function h(t) { if (0 == t) return -1; var e = 0; return 0 == (65535 & t) && (t >>= 16, e += 16), 0 == (255 & t) && (t >>= 8, e += 8), 0 == (15 & t) && (t >>= 4, e += 4), 0 == (3 & t) && (t >>= 2, e += 2), 0 == (1 & t) && ++e, e } function a(t) { for (var e = 0; 0 != t;)t &= t - 1, ++e; return e } var u = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"; function c(t) { var e, i, r = ""; for (e = 0; e + 3 <= t.length; e += 3)i = parseInt(t.substring(e, e + 3), 16), r += u.charAt(i >> 6) + u.charAt(63 & i); for (e + 1 == t.length ? (i = parseInt(t.substring(e, e + 1), 16), r += u.charAt(i << 2)) : e + 2 == t.length && (i = parseInt(t.substring(e, e + 2), 16), r += u.charAt(i >> 2) + u.charAt((3 & i) << 4)); 0 < (3 & r.length);)r += "="; return r } function f(t) { var e, r = "", n = 0, s = 0; for (e = 0; e < t.length && "=" != t.charAt(e); ++e) { var o = u.indexOf(t.charAt(e)); o < 0 || (0 == n ? (r += i(o >> 2), s = 3 & o, n = 1) : 1 == n ? (r += i(s << 2 | o >> 4), s = 15 & o, n = 2) : 2 == n ? (r += i(s), r += i(o >> 2), s = 3 & o, n = 3) : (r += i(s << 2 | o >> 4), r += i(15 & o), n = 0)) } return 1 == n && (r += i(s << 2)), r } var l, p, g = function (t, e) { return (g = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]) })(t, e) }, d = { decode: function (t) { var e; if (void 0 === p) { var i = "= \f\n\r\t \u2028\u2029"; for (p = Object.create(null), e = 0; e < 64; ++e)p["ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(e)] = e; for (e = 0; e < i.length; ++e)p[i.charAt(e)] = -1 } var r = [], n = 0, s = 0; for (e = 0; e < t.length; ++e) { var o = t.charAt(e); if ("=" == o) break; if (-1 != (o = p[o])) { if (void 0 === o) throw new Error("Illegal character at offset " + e); n |= o, 4 <= ++s ? (r[r.length] = n >> 16, r[r.length] = n >> 8 & 255, r[r.length] = 255 & n, s = n = 0) : n <<= 6 } } switch (s) { case 1: throw new Error("Base64 encoding incomplete: at least 2 bits missing"); case 2: r[r.length] = n >> 10; break; case 3: r[r.length] = n >> 16, r[r.length] = n >> 8 & 255 }return r }, re: /-----BEGIN [^-]+-----([A-Za-z0-9+\/=\s]+)-----END [^-]+-----|begin-base64[^\n]+\n([A-Za-z0-9+\/=\s]+)====/, unarmor: function (t) { var e = d.re.exec(t); if (e) if (e[1]) t = e[1]; else { if (!e[2]) throw new Error("RegExp out of sync"); t = e[2] } return d.decode(t) } }, v = 1e13, m = function () { function t(t) { this.buf = [+t || 0] } return t.prototype.mulAdd = function (t, e) { var i, r, n = this.buf, s = n.length; for (i = 0; i < s; ++i)(r = n[i] * t + e) < v ? e = 0 : r -= (e = 0 | r / v) * v, n[i] = r; 0 < e && (n[i] = e) }, t.prototype.sub = function (t) { var e, i, r = this.buf, n = r.length; for (e = 0; e < n; ++e)(i = r[e] - t) < 0 ? (i += v, t = 1) : t = 0, r[e] = i; for (; 0 === r[r.length - 1];)r.pop() }, t.prototype.toString = function (t) { if (10 != (t || 10)) throw new Error("only base 10 is supported"); for (var e = this.buf, i = e[e.length - 1].toString(), r = e.length - 2; 0 <= r; --r)i += (v + e[r]).toString().substring(1); return i }, t.prototype.valueOf = function () { for (var t = this.buf, e = 0, i = t.length - 1; 0 <= i; --i)e = e * v + t[i]; return e }, t.prototype.simplify = function () { var t = this.buf; return 1 == t.length ? t[0] : this }, t }(), y = "…", b = /^(\d\d)(0[1-9]|1[0-2])(0[1-9]|[12]\d|3[01])([01]\d|2[0-3])(?:([0-5]\d)(?:([0-5]\d)(?:[.,](\d{1,3}))?)?)?(Z|[-+](?:[0]\d|1[0-2])([0-5]\d)?)?$/, T = /^(\d\d\d\d)(0[1-9]|1[0-2])(0[1-9]|[12]\d|3[01])([01]\d|2[0-3])(?:([0-5]\d)(?:([0-5]\d)(?:[.,](\d{1,3}))?)?)?(Z|[-+](?:[0]\d|1[0-2])([0-5]\d)?)?$/; function S(t, e) { return t.length > e && (t = t.substring(0, e) + y), t } var E, w = function () { function t(e, i) { this.hexDigits = "0123456789ABCDEF", e instanceof t ? (this.enc = e.enc, this.pos = e.pos) : (this.enc = e, this.pos = i) } return t.prototype.get = function (t) { if (void 0 === t && (t = this.pos++), t >= this.enc.length) throw new Error("Requesting byte offset " + t + " on a stream of length " + this.enc.length); return "string" == typeof this.enc ? this.enc.charCodeAt(t) : this.enc[t] }, t.prototype.hexByte = function (t) { return this.hexDigits.charAt(t >> 4 & 15) + this.hexDigits.charAt(15 & t) }, t.prototype.hexDump = function (t, e, i) { for (var r = "", n = t; n < e; ++n)if (r += this.hexByte(this.get(n)), !0 !== i) switch (15 & n) { case 7: r += "  "; break; case 15: r += "\n"; break; default: r += " " }return r }, t.prototype.isASCII = function (t, e) { for (var i = t; i < e; ++i) { var r = this.get(i); if (r < 32 || 176 < r) return !1 } return !0 }, t.prototype.parseStringISO = function (t, e) { for (var i = "", r = t; r < e; ++r)i += String.fromCharCode(this.get(r)); return i }, t.prototype.parseStringUTF = function (t, e) { for (var i = "", r = t; r < e;) { var n = this.get(r++); i += n < 128 ? String.fromCharCode(n) : 191 < n && n < 224 ? String.fromCharCode((31 & n) << 6 | 63 & this.get(r++)) : String.fromCharCode((15 & n) << 12 | (63 & this.get(r++)) << 6 | 63 & this.get(r++)) } return i }, t.prototype.parseStringBMP = function (t, e) { for (var i, r, n = "", s = t; s < e;)i = this.get(s++), r = this.get(s++), n += String.fromCharCode(i << 8 | r); return n }, t.prototype.parseTime = function (t, e, i) { var r = this.parseStringISO(t, e), n = (i ? b : T).exec(r); return n ? (i && (n[1] = +n[1], n[1] += +n[1] < 70 ? 2e3 : 1900), r = n[1] + "-" + n[2] + "-" + n[3] + " " + n[4], n[5] && (r += ":" + n[5], n[6] && (r += ":" + n[6], n[7] && (r += "." + n[7]))), n[8] && (r += " UTC", "Z" != n[8] && (r += n[8], n[9] && (r += ":" + n[9]))), r) : "Unrecognized time: " + r }, t.prototype.parseInteger = function (t, e) { for (var i, r = this.get(t), n = 127 < r, s = n ? 255 : 0, o = ""; r == s && ++t < e;)r = this.get(t); if (0 == (i = e - t)) return n ? -1 : 0; if (4 < i) { for (o = r, i <<= 3; 0 == (128 & (+o ^ s));)o = +o << 1, --i; o = "(" + i + " bit)\n" } n && (r -= 256); for (var h = new m(r), a = t + 1; a < e; ++a)h.mulAdd(256, this.get(a)); return o + h.toString() }, t.prototype.parseBitString = function (t, e, i) { for (var r = this.get(t), n = "(" + ((e - t - 1 << 3) - r) + " bit)\n", s = "", o = t + 1; o < e; ++o) { for (var h = this.get(o), a = o == e - 1 ? r : 0, u = 7; a <= u; --u)s += h >> u & 1 ? "1" : "0"; if (s.length > i) return n + S(s, i) } return n + s }, t.prototype.parseOctetString = function (t, e, i) { if (this.isASCII(t, e)) return S(this.parseStringISO(t, e), i); var r = e - t, n = "(" + r + " byte)\n"; (i /= 2) < r && (e = t + i); for (var s = t; s < e; ++s)n += this.hexByte(this.get(s)); return i < r && (n += y), n }, t.prototype.parseOID = function (t, e, i) { for (var r = "", n = new m, s = 0, o = t; o < e; ++o) { var h = this.get(o); if (n.mulAdd(128, 127 & h), s += 7, !(128 & h)) { if ("" === r) if ((n = n.simplify()) instanceof m) n.sub(80), r = "2." + n.toString(); else { var a = n < 80 ? n < 40 ? 0 : 1 : 2; r = a + "." + (n - 40 * a) } else r += "." + n.toString(); if (r.length > i) return S(r, i); n = new m, s = 0 } } return 0 < s && (r += ".incomplete"), r }, t }(), D = function () { function t(t, e, i, r, n) { if (!(r instanceof x)) throw new Error("Invalid tag value."); this.stream = t, this.header = e, this.length = i, this.tag = r, this.sub = n } return t.prototype.typeName = function () { switch (this.tag.tagClass) { case 0: switch (this.tag.tagNumber) { case 0: return "EOC"; case 1: return "BOOLEAN"; case 2: return "INTEGER"; case 3: return "BIT_STRING"; case 4: return "OCTET_STRING"; case 5: return "NULL"; case 6: return "OBJECT_IDENTIFIER"; case 7: return "ObjectDescriptor"; case 8: return "EXTERNAL"; case 9: return "REAL"; case 10: return "ENUMERATED"; case 11: return "EMBEDDED_PDV"; case 12: return "UTF8String"; case 16: return "SEQUENCE"; case 17: return "SET"; case 18: return "NumericString"; case 19: return "PrintableString"; case 20: return "TeletexString"; case 21: return "VideotexString"; case 22: return "IA5String"; case 23: return "UTCTime"; case 24: return "GeneralizedTime"; case 25: return "GraphicString"; case 26: return "VisibleString"; case 27: return "GeneralString"; case 28: return "UniversalString"; case 30: return "BMPString" }return "Universal_" + this.tag.tagNumber.toString(); case 1: return "Application_" + this.tag.tagNumber.toString(); case 2: return "[" + this.tag.tagNumber.toString() + "]"; case 3: return "Private_" + this.tag.tagNumber.toString() } }, t.prototype.content = function (t) { if (void 0 === this.tag) return null; void 0 === t && (t = 1 / 0); var e = this.posContent(), i = Math.abs(this.length); if (!this.tag.isUniversal()) return null !== this.sub ? "(" + this.sub.length + " elem)" : this.stream.parseOctetString(e, e + i, t); switch (this.tag.tagNumber) { case 1: return 0 === this.stream.get(e) ? "false" : "true"; case 2: return this.stream.parseInteger(e, e + i); case 3: return this.sub ? "(" + this.sub.length + " elem)" : this.stream.parseBitString(e, e + i, t); case 4: return this.sub ? "(" + this.sub.length + " elem)" : this.stream.parseOctetString(e, e + i, t); case 6: return this.stream.parseOID(e, e + i, t); case 16: case 17: return null !== this.sub ? "(" + this.sub.length + " elem)" : "(no elem)"; case 12: return S(this.stream.parseStringUTF(e, e + i), t); case 18: case 19: case 20: case 21: case 22: case 26: return S(this.stream.parseStringISO(e, e + i), t); case 30: return S(this.stream.parseStringBMP(e, e + i), t); case 23: case 24: return this.stream.parseTime(e, e + i, 23 == this.tag.tagNumber) }return null }, t.prototype.toString = function () { return this.typeName() + "@" + this.stream.pos + "[header:" + this.header + ",length:" + this.length + ",sub:" + (null === this.sub ? "null" : this.sub.length) + "]" }, t.prototype.toPrettyString = function (t) { void 0 === t && (t = ""); var e = t + this.typeName() + " @" + this.stream.pos; if (0 <= this.length && (e += "+"), e += this.length, this.tag.tagConstructed ? e += " (constructed)" : !this.tag.isUniversal() || 3 != this.tag.tagNumber && 4 != this.tag.tagNumber || null === this.sub || (e += " (encapsulates)"), e += "\n", null !== this.sub) { t += "  "; for (var i = 0, r = this.sub.length; i < r; ++i)e += this.sub[i].toPrettyString(t) } return e }, t.prototype.posStart = function () { return this.stream.pos }, t.prototype.posContent = function () { return this.stream.pos + this.header }, t.prototype.posEnd = function () { return this.stream.pos + this.header + Math.abs(this.length) }, t.prototype.toHexString = function () { return this.stream.hexDump(this.posStart(), this.posEnd(), !0) }, t.decodeLength = function (t) { var e = t.get(), i = 127 & e; if (i == e) return i; if (6 < i) throw new Error("Length over 48 bits not supported at position " + (t.pos - 1)); if (0 === i) return null; for (var r = e = 0; r < i; ++r)e = 256 * e + t.get(); return e }, t.prototype.getHexStringValue = function () { var t = this.toHexString(), e = 2 * this.header, i = 2 * this.length; return t.substr(e, i) }, t.decode = function (e) { var i; i = e instanceof w ? e : new w(e, 0); var r = new w(i), n = new x(i), s = t.decodeLength(i), o = i.pos, h = o - r.pos, a = null, u = function () { var e = []; if (null !== s) { for (var r = o + s; i.pos < r;)e[e.length] = t.decode(i); if (i.pos != r) throw new Error("Content size is not correct for container starting at offset " + o) } else try { for (; ;) { var n = t.decode(i); if (n.tag.isEOC()) break; e[e.length] = n } s = o - i.pos } catch (e) { throw new Error("Exception while decoding undefined length content: " + e) } return e }; if (n.tagConstructed) a = u(); else if (n.isUniversal() && (3 == n.tagNumber || 4 == n.tagNumber)) try { if (3 == n.tagNumber && 0 != i.get()) throw new Error("BIT STRINGs with unused bits cannot encapsulate."); a = u(); for (var c = 0; c < a.length; ++c)if (a[c].tag.isEOC()) throw new Error("EOC is not supposed to be actual content.") } catch (e) { a = null } if (null === a) { if (null === s) throw new Error("We can't skip over an invalid tag with undefined length at offset " + o); i.pos = o + Math.abs(s) } return new t(r, h, s, n, a) }, t }(), x = function () { function t(t) { var e = t.get(); if (this.tagClass = e >> 6, this.tagConstructed = 0 != (32 & e), this.tagNumber = 31 & e, 31 == this.tagNumber) { for (var i = new m; e = t.get(), i.mulAdd(128, 127 & e), 128 & e;); this.tagNumber = i.simplify() } } return t.prototype.isUniversal = function () { return 0 === this.tagClass }, t.prototype.isEOC = function () { return 0 === this.tagClass && 0 === this.tagNumber }, t }(), R = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997], B = (1 << 26) / R[R.length - 1], A = function () { function t(t, e, i) { null != t && ("number" == typeof t ? this.fromNumber(t, e, i) : null == e && "string" != typeof t ? this.fromString(t, 256) : this.fromString(t, e)) } return t.prototype.toString = function (t) { if (this.s < 0) return "-" + this.negate().toString(t); var e; if (16 == t) e = 4; else if (8 == t) e = 3; else if (2 == t) e = 1; else if (32 == t) e = 5; else { if (4 != t) return this.toRadix(t); e = 2 } var r, n = (1 << e) - 1, s = !1, o = "", h = this.t, a = this.DB - h * this.DB % e; if (0 < h--) for (a < this.DB && 0 < (r = this[h] >> a) && (s = !0, o = i(r)); 0 <= h;)a < e ? (r = (this[h] & (1 << a) - 1) << e - a, r |= this[--h] >> (a += this.DB - e)) : (r = this[h] >> (a -= e) & n, a <= 0 && (a += this.DB, --h)), 0 < r && (s = !0), s && (o += i(r)); return s ? o : "0" }, t.prototype.negate = function () { var e = P(); return t.ZERO.subTo(this, e), e }, t.prototype.abs = function () { return this.s < 0 ? this.negate() : this }, t.prototype.compareTo = function (t) { var e = this.s - t.s; if (0 != e) return e; var i = this.t; if (0 != (e = i - t.t)) return this.s < 0 ? -e : e; for (; 0 <= --i;)if (0 != (e = this[i] - t[i])) return e; return 0 }, t.prototype.bitLength = function () { return this.t <= 0 ? 0 : this.DB * (this.t - 1) + F(this[this.t - 1] ^ this.s & this.DM) }, t.prototype.mod = function (e) { var i = P(); return this.abs().divRemTo(e, null, i), this.s < 0 && 0 < i.compareTo(t.ZERO) && e.subTo(i, i), i }, t.prototype.modPowInt = function (t, e) { var i; return i = t < 256 || e.isEven() ? new V(e) : new I(e), this.exp(t, i) }, t.prototype.clone = function () { var t = P(); return this.copyTo(t), t }, t.prototype.intValue = function () { if (this.s < 0) { if (1 == this.t) return this[0] - this.DV; if (0 == this.t) return -1 } else { if (1 == this.t) return this[0]; if (0 == this.t) return 0 } return (this[1] & (1 << 32 - this.DB) - 1) << this.DB | this[0] }, t.prototype.byteValue = function () { return 0 == this.t ? this.s : this[0] << 24 >> 24 }, t.prototype.shortValue = function () { return 0 == this.t ? this.s : this[0] << 16 >> 16 }, t.prototype.signum = function () { return this.s < 0 ? -1 : this.t <= 0 || 1 == this.t && this[0] <= 0 ? 0 : 1 }, t.prototype.toByteArray = function () { var t = this.t, e = []; e[0] = this.s; var i, r = this.DB - t * this.DB % 8, n = 0; if (0 < t--) for (r < this.DB && (i = this[t] >> r) != (this.s & this.DM) >> r && (e[n++] = i | this.s << this.DB - r); 0 <= t;)r < 8 ? (i = (this[t] & (1 << r) - 1) << 8 - r, i |= this[--t] >> (r += this.DB - 8)) : (i = this[t] >> (r -= 8) & 255, r <= 0 && (r += this.DB, --t)), 0 != (128 & i) && (i |= -256), 0 == n && (128 & this.s) != (128 & i) && ++n, (0 < n || i != this.s) && (e[n++] = i); return e }, t.prototype.equals = function (t) { return 0 == this.compareTo(t) }, t.prototype.min = function (t) { return this.compareTo(t) < 0 ? this : t }, t.prototype.max = function (t) { return 0 < this.compareTo(t) ? this : t }, t.prototype.and = function (t) { var e = P(); return this.bitwiseTo(t, r, e), e }, t.prototype.or = function (t) { var e = P(); return this.bitwiseTo(t, n, e), e }, t.prototype.xor = function (t) { var e = P(); return this.bitwiseTo(t, s, e), e }, t.prototype.andNot = function (t) { var e = P(); return this.bitwiseTo(t, o, e), e }, t.prototype.not = function () { for (var t = P(), e = 0; e < this.t; ++e)t[e] = this.DM & ~this[e]; return t.t = this.t, t.s = ~this.s, t }, t.prototype.shiftLeft = function (t) { var e = P(); return t < 0 ? this.rShiftTo(-t, e) : this.lShiftTo(t, e), e }, t.prototype.shiftRight = function (t) { var e = P(); return t < 0 ? this.lShiftTo(-t, e) : this.rShiftTo(t, e), e }, t.prototype.getLowestSetBit = function () { for (var t = 0; t < this.t; ++t)if (0 != this[t]) return t * this.DB + h(this[t]); return this.s < 0 ? this.t * this.DB : -1 }, t.prototype.bitCount = function () { for (var t = 0, e = this.s & this.DM, i = 0; i < this.t; ++i)t += a(this[i] ^ e); return t }, t.prototype.testBit = function (t) { var e = Math.floor(t / this.DB); return e >= this.t ? 0 != this.s : 0 != (this[e] & 1 << t % this.DB) }, t.prototype.setBit = function (t) { return this.changeBit(t, n) }, t.prototype.clearBit = function (t) { return this.changeBit(t, o) }, t.prototype.flipBit = function (t) { return this.changeBit(t, s) }, t.prototype.add = function (t) { var e = P(); return this.addTo(t, e), e }, t.prototype.subtract = function (t) { var e = P(); return this.subTo(t, e), e }, t.prototype.multiply = function (t) { var e = P(); return this.multiplyTo(t, e), e }, t.prototype.divide = function (t) { var e = P(); return this.divRemTo(t, e, null), e }, t.prototype.remainder = function (t) { var e = P(); return this.divRemTo(t, null, e), e }, t.prototype.divideAndRemainder = function (t) { var e = P(), i = P(); return this.divRemTo(t, e, i), [e, i] }, t.prototype.modPow = function (t, e) { var i, r, n = t.bitLength(), s = C(1); if (n <= 0) return s; i = n < 18 ? 1 : n < 48 ? 3 : n < 144 ? 4 : n < 768 ? 5 : 6, r = n < 8 ? new V(e) : e.isEven() ? new N(e) : new I(e); var o = [], h = 3, a = i - 1, u = (1 << i) - 1; if (o[1] = r.convert(this), 1 < i) { var c = P(); for (r.sqrTo(o[1], c); h <= u;)o[h] = P(), r.mulTo(c, o[h - 2], o[h]), h += 2 } var f, l, p = t.t - 1, g = !0, d = P(); for (n = F(t[p]) - 1; 0 <= p;) { for (a <= n ? f = t[p] >> n - a & u : (f = (t[p] & (1 << n + 1) - 1) << a - n, 0 < p && (f |= t[p - 1] >> this.DB + n - a)), h = i; 0 == (1 & f);)f >>= 1, --h; if ((n -= h) < 0 && (n += this.DB, --p), g) o[f].copyTo(s), g = !1; else { for (; 1 < h;)r.sqrTo(s, d), r.sqrTo(d, s), h -= 2; 0 < h ? r.sqrTo(s, d) : (l = s, s = d, d = l), r.mulTo(d, o[f], s) } for (; 0 <= p && 0 == (t[p] & 1 << n);)r.sqrTo(s, d), l = s, s = d, d = l, --n < 0 && (n = this.DB - 1, --p) } return r.revert(s) }, t.prototype.modInverse = function (e) { var i = e.isEven(); if (this.isEven() && i || 0 == e.signum()) return t.ZERO; for (var r = e.clone(), n = this.clone(), s = C(1), o = C(0), h = C(0), a = C(1); 0 != r.signum();) { for (; r.isEven();)r.rShiftTo(1, r), i ? (s.isEven() && o.isEven() || (s.addTo(this, s), o.subTo(e, o)), s.rShiftTo(1, s)) : o.isEven() || o.subTo(e, o), o.rShiftTo(1, o); for (; n.isEven();)n.rShiftTo(1, n), i ? (h.isEven() && a.isEven() || (h.addTo(this, h), a.subTo(e, a)), h.rShiftTo(1, h)) : a.isEven() || a.subTo(e, a), a.rShiftTo(1, a); 0 <= r.compareTo(n) ? (r.subTo(n, r), i && s.subTo(h, s), o.subTo(a, o)) : (n.subTo(r, n), i && h.subTo(s, h), a.subTo(o, a)) } return 0 != n.compareTo(t.ONE) ? t.ZERO : 0 <= a.compareTo(e) ? a.subtract(e) : a.signum() < 0 ? (a.addTo(e, a), a.signum() < 0 ? a.add(e) : a) : a }, t.prototype.pow = function (t) { return this.exp(t, new O) }, t.prototype.gcd = function (t) { var e = this.s < 0 ? this.negate() : this.clone(), i = t.s < 0 ? t.negate() : t.clone(); if (e.compareTo(i) < 0) { var r = e; e = i, i = r } var n = e.getLowestSetBit(), s = i.getLowestSetBit(); if (s < 0) return e; for (n < s && (s = n), 0 < s && (e.rShiftTo(s, e), i.rShiftTo(s, i)); 0 < e.signum();)0 < (n = e.getLowestSetBit()) && e.rShiftTo(n, e), 0 < (n = i.getLowestSetBit()) && i.rShiftTo(n, i), 0 <= e.compareTo(i) ? (e.subTo(i, e), e.rShiftTo(1, e)) : (i.subTo(e, i), i.rShiftTo(1, i)); return 0 < s && i.lShiftTo(s, i), i }, t.prototype.isProbablePrime = function (t) { var e, i = this.abs(); if (1 == i.t && i[0] <= R[R.length - 1]) { for (e = 0; e < R.length; ++e)if (i[0] == R[e]) return !0; return !1 } if (i.isEven()) return !1; for (e = 1; e < R.length;) { for (var r = R[e], n = e + 1; n < R.length && r < B;)r *= R[n++]; for (r = i.modInt(r); e < n;)if (r % R[e++] == 0) return !1 } return i.millerRabin(t) }, t.prototype.copyTo = function (t) { for (var e = this.t - 1; 0 <= e; --e)t[e] = this[e]; t.t = this.t, t.s = this.s }, t.prototype.fromInt = function (t) { this.t = 1, this.s = t < 0 ? -1 : 0, 0 < t ? this[0] = t : t < -1 ? this[0] = t + this.DV : this.t = 0 }, t.prototype.fromString = function (e, i) { var r; if (16 == i) r = 4; else if (8 == i) r = 3; else if (256 == i) r = 8; else if (2 == i) r = 1; else if (32 == i) r = 5; else { if (4 != i) return void this.fromRadix(e, i); r = 2 } this.t = 0, this.s = 0; for (var n = e.length, s = !1, o = 0; 0 <= --n;) { var h = 8 == r ? 255 & +e[n] : H(e, n); h < 0 ? "-" == e.charAt(n) && (s = !0) : (s = !1, 0 == o ? this[this.t++] = h : o + r > this.DB ? (this[this.t - 1] |= (h & (1 << this.DB - o) - 1) << o, this[this.t++] = h >> this.DB - o) : this[this.t - 1] |= h << o, (o += r) >= this.DB && (o -= this.DB)) } 8 == r && 0 != (128 & +e[0]) && (this.s = -1, 0 < o && (this[this.t - 1] |= (1 << this.DB - o) - 1 << o)), this.clamp(), s && t.ZERO.subTo(this, this) }, t.prototype.clamp = function () { for (var t = this.s & this.DM; 0 < this.t && this[this.t - 1] == t;)--this.t }, t.prototype.dlShiftTo = function (t, e) { var i; for (i = this.t - 1; 0 <= i; --i)e[i + t] = this[i]; for (i = t - 1; 0 <= i; --i)e[i] = 0; e.t = this.t + t, e.s = this.s }, t.prototype.drShiftTo = function (t, e) { for (var i = t; i < this.t; ++i)e[i - t] = this[i]; e.t = Math.max(this.t - t, 0), e.s = this.s }, t.prototype.lShiftTo = function (t, e) { for (var i = t % this.DB, r = this.DB - i, n = (1 << r) - 1, s = Math.floor(t / this.DB), o = this.s << i & this.DM, h = this.t - 1; 0 <= h; --h)e[h + s + 1] = this[h] >> r | o, o = (this[h] & n) << i; for (h = s - 1; 0 <= h; --h)e[h] = 0; e[s] = o, e.t = this.t + s + 1, e.s = this.s, e.clamp() }, t.prototype.rShiftTo = function (t, e) { e.s = this.s; var i = Math.floor(t / this.DB); if (i >= this.t) e.t = 0; else { var r = t % this.DB, n = this.DB - r, s = (1 << r) - 1; e[0] = this[i] >> r; for (var o = i + 1; o < this.t; ++o)e[o - i - 1] |= (this[o] & s) << n, e[o - i] = this[o] >> r; 0 < r && (e[this.t - i - 1] |= (this.s & s) << n), e.t = this.t - i, e.clamp() } }, t.prototype.subTo = function (t, e) { for (var i = 0, r = 0, n = Math.min(t.t, this.t); i < n;)r += this[i] - t[i], e[i++] = r & this.DM, r >>= this.DB; if (t.t < this.t) { for (r -= t.s; i < this.t;)r += this[i], e[i++] = r & this.DM, r >>= this.DB; r += this.s } else { for (r += this.s; i < t.t;)r -= t[i], e[i++] = r & this.DM, r >>= this.DB; r -= t.s } e.s = r < 0 ? -1 : 0, r < -1 ? e[i++] = this.DV + r : 0 < r && (e[i++] = r), e.t = i, e.clamp() }, t.prototype.multiplyTo = function (e, i) { var r = this.abs(), n = e.abs(), s = r.t; for (i.t = s + n.t; 0 <= --s;)i[s] = 0; for (s = 0; s < n.t; ++s)i[s + r.t] = r.am(0, n[s], i, s, 0, r.t); i.s = 0, i.clamp(), this.s != e.s && t.ZERO.subTo(i, i) }, t.prototype.squareTo = function (t) { for (var e = this.abs(), i = t.t = 2 * e.t; 0 <= --i;)t[i] = 0; for (i = 0; i < e.t - 1; ++i) { var r = e.am(i, e[i], t, 2 * i, 0, 1); (t[i + e.t] += e.am(i + 1, 2 * e[i], t, 2 * i + 1, r, e.t - i - 1)) >= e.DV && (t[i + e.t] -= e.DV, t[i + e.t + 1] = 1) } 0 < t.t && (t[t.t - 1] += e.am(i, e[i], t, 2 * i, 0, 1)), t.s = 0, t.clamp() }, t.prototype.divRemTo = function (e, i, r) { var n = e.abs(); if (!(n.t <= 0)) { var s = this.abs(); if (s.t < n.t) return null != i && i.fromInt(0), void (null != r && this.copyTo(r)); null == r && (r = P()); var o = P(), h = this.s, a = e.s, u = this.DB - F(n[n.t - 1]); 0 < u ? (n.lShiftTo(u, o), s.lShiftTo(u, r)) : (n.copyTo(o), s.copyTo(r)); var c = o.t, f = o[c - 1]; if (0 != f) { var l = f * (1 << this.F1) + (1 < c ? o[c - 2] >> this.F2 : 0), p = this.FV / l, g = (1 << this.F1) / l, d = 1 << this.F2, v = r.t, m = v - c, y = null == i ? P() : i; for (o.dlShiftTo(m, y), 0 <= r.compareTo(y) && (r[r.t++] = 1, r.subTo(y, r)), t.ONE.dlShiftTo(c, y), y.subTo(o, o); o.t < c;)o[o.t++] = 0; for (; 0 <= --m;) { var b = r[--v] == f ? this.DM : Math.floor(r[v] * p + (r[v - 1] + d) * g); if ((r[v] += o.am(0, b, r, m, 0, c)) < b) for (o.dlShiftTo(m, y), r.subTo(y, r); r[v] < --b;)r.subTo(y, r) } null != i && (r.drShiftTo(c, i), h != a && t.ZERO.subTo(i, i)), r.t = c, r.clamp(), 0 < u && r.rShiftTo(u, r), h < 0 && t.ZERO.subTo(r, r) } } }, t.prototype.invDigit = function () { if (this.t < 1) return 0; var t = this[0]; if (0 == (1 & t)) return 0; var e = 3 & t; return 0 < (e = (e = (e = (e = e * (2 - (15 & t) * e) & 15) * (2 - (255 & t) * e) & 255) * (2 - ((65535 & t) * e & 65535)) & 65535) * (2 - t * e % this.DV) % this.DV) ? this.DV - e : -e }, t.prototype.isEven = function () { return 0 == (0 < this.t ? 1 & this[0] : this.s) }, t.prototype.exp = function (e, i) { if (4294967295 < e || e < 1) return t.ONE; var r = P(), n = P(), s = i.convert(this), o = F(e) - 1; for (s.copyTo(r); 0 <= --o;)if (i.sqrTo(r, n), 0 < (e & 1 << o)) i.mulTo(n, s, r); else { var h = r; r = n, n = h } return i.revert(r) }, t.prototype.chunkSize = function (t) { return Math.floor(Math.LN2 * this.DB / Math.log(t)) }, t.prototype.toRadix = function (t) { if (null == t && (t = 10), 0 == this.signum() || t < 2 || 36 < t) return "0"; var e = this.chunkSize(t), i = Math.pow(t, e), r = C(i), n = P(), s = P(), o = ""; for (this.divRemTo(r, n, s); 0 < n.signum();)o = (i + s.intValue()).toString(t).substr(1) + o, n.divRemTo(r, n, s); return s.intValue().toString(t) + o }, t.prototype.fromRadix = function (e, i) { this.fromInt(0), null == i && (i = 10); for (var r = this.chunkSize(i), n = Math.pow(i, r), s = !1, o = 0, h = 0, a = 0; a < e.length; ++a) { var u = H(e, a); u < 0 ? "-" == e.charAt(a) && 0 == this.signum() && (s = !0) : (h = i * h + u, ++o >= r && (this.dMultiply(n), this.dAddOffset(h, 0), h = o = 0)) } 0 < o && (this.dMultiply(Math.pow(i, o)), this.dAddOffset(h, 0)), s && t.ZERO.subTo(this, this) }, t.prototype.fromNumber = function (e, i, r) { if ("number" == typeof i) if (e < 2) this.fromInt(1); else for (this.fromNumber(e, r), this.testBit(e - 1) || this.bitwiseTo(t.ONE.shiftLeft(e - 1), n, this), this.isEven() && this.dAddOffset(1, 0); !this.isProbablePrime(i);)this.dAddOffset(2, 0), this.bitLength() > e && this.subTo(t.ONE.shiftLeft(e - 1), this); else { var s = [], o = 7 & e; s.length = 1 + (e >> 3), i.nextBytes(s), 0 < o ? s[0] &= (1 << o) - 1 : s[0] = 0, this.fromString(s, 256) } }, t.prototype.bitwiseTo = function (t, e, i) { var r, n, s = Math.min(t.t, this.t); for (r = 0; r < s; ++r)i[r] = e(this[r], t[r]); if (t.t < this.t) { for (n = t.s & this.DM, r = s; r < this.t; ++r)i[r] = e(this[r], n); i.t = this.t } else { for (n = this.s & this.DM, r = s; r < t.t; ++r)i[r] = e(n, t[r]); i.t = t.t } i.s = e(this.s, t.s), i.clamp() }, t.prototype.changeBit = function (e, i) { var r = t.ONE.shiftLeft(e); return this.bitwiseTo(r, i, r), r }, t.prototype.addTo = function (t, e) { for (var i = 0, r = 0, n = Math.min(t.t, this.t); i < n;)r += this[i] + t[i], e[i++] = r & this.DM, r >>= this.DB; if (t.t < this.t) { for (r += t.s; i < this.t;)r += this[i], e[i++] = r & this.DM, r >>= this.DB; r += this.s } else { for (r += this.s; i < t.t;)r += t[i], e[i++] = r & this.DM, r >>= this.DB; r += t.s } e.s = r < 0 ? -1 : 0, 0 < r ? e[i++] = r : r < -1 && (e[i++] = this.DV + r), e.t = i, e.clamp() }, t.prototype.dMultiply = function (t) { this[this.t] = this.am(0, t - 1, this, 0, 0, this.t), ++this.t, this.clamp() }, t.prototype.dAddOffset = function (t, e) { if (0 != t) { for (; this.t <= e;)this[this.t++] = 0; for (this[e] += t; this[e] >= this.DV;)this[e] -= this.DV, ++e >= this.t && (this[this.t++] = 0), ++this[e] } }, t.prototype.multiplyLowerTo = function (t, e, i) { var r = Math.min(this.t + t.t, e); for (i.s = 0, i.t = r; 0 < r;)i[--r] = 0; for (var n = i.t - this.t; r < n; ++r)i[r + this.t] = this.am(0, t[r], i, r, 0, this.t); for (n = Math.min(t.t, e); r < n; ++r)this.am(0, t[r], i, r, 0, e - r); i.clamp() }, t.prototype.multiplyUpperTo = function (t, e, i) { --e; var r = i.t = this.t + t.t - e; for (i.s = 0; 0 <= --r;)i[r] = 0; for (r = Math.max(e - this.t, 0); r < t.t; ++r)i[this.t + r - e] = this.am(e - r, t[r], i, 0, 0, this.t + r - e); i.clamp(), i.drShiftTo(1, i) }, t.prototype.modInt = function (t) { if (t <= 0) return 0; var e = this.DV % t, i = this.s < 0 ? t - 1 : 0; if (0 < this.t) if (0 == e) i = this[0] % t; else for (var r = this.t - 1; 0 <= r; --r)i = (e * i + this[r]) % t; return i }, t.prototype.millerRabin = function (e) { var i = this.subtract(t.ONE), r = i.getLowestSetBit(); if (r <= 0) return !1; var n = i.shiftRight(r); R.length < (e = e + 1 >> 1) && (e = R.length); for (var s = P(), o = 0; o < e; ++o) { s.fromInt(R[Math.floor(Math.random() * R.length)]); var h = s.modPow(n, this); if (0 != h.compareTo(t.ONE) && 0 != h.compareTo(i)) { for (var a = 1; a++ < r && 0 != h.compareTo(i);)if (0 == (h = h.modPowInt(2, this)).compareTo(t.ONE)) return !1; if (0 != h.compareTo(i)) return !1 } } return !0 }, t.prototype.square = function () { var t = P(); return this.squareTo(t), t }, t.prototype.gcda = function (t, e) { var i = this.s < 0 ? this.negate() : this.clone(), r = t.s < 0 ? t.negate() : t.clone(); if (i.compareTo(r) < 0) { var n = i; i = r, r = n } var s = i.getLowestSetBit(), o = r.getLowestSetBit(); if (o < 0) e(i); else { s < o && (o = s), 0 < o && (i.rShiftTo(o, i), r.rShiftTo(o, r)); var h = function () { 0 < (s = i.getLowestSetBit()) && i.rShiftTo(s, i), 0 < (s = r.getLowestSetBit()) && r.rShiftTo(s, r), 0 <= i.compareTo(r) ? (i.subTo(r, i), i.rShiftTo(1, i)) : (r.subTo(i, r), r.rShiftTo(1, r)), 0 < i.signum() ? setTimeout(h, 0) : (0 < o && r.lShiftTo(o, r), setTimeout(function () { e(r) }, 0)) }; setTimeout(h, 10) } }, t.prototype.fromNumberAsync = function (e, i, r, s) { if ("number" == typeof i) if (e < 2) this.fromInt(1); else { this.fromNumber(e, r), this.testBit(e - 1) || this.bitwiseTo(t.ONE.shiftLeft(e - 1), n, this), this.isEven() && this.dAddOffset(1, 0); var o = this, h = function () { o.dAddOffset(2, 0), o.bitLength() > e && o.subTo(t.ONE.shiftLeft(e - 1), o), o.isProbablePrime(i) ? setTimeout(function () { s() }, 0) : setTimeout(h, 0) }; setTimeout(h, 0) } else { var a = [], u = 7 & e; a.length = 1 + (e >> 3), i.nextBytes(a), 0 < u ? a[0] &= (1 << u) - 1 : a[0] = 0, this.fromString(a, 256) } }, t }(), O = function () { function t() { } return t.prototype.convert = function (t) { return t }, t.prototype.revert = function (t) { return t }, t.prototype.mulTo = function (t, e, i) { t.multiplyTo(e, i) }, t.prototype.sqrTo = function (t, e) { t.squareTo(e) }, t }(), V = function () { function t(t) { this.m = t } return t.prototype.convert = function (t) { return t.s < 0 || 0 <= t.compareTo(this.m) ? t.mod(this.m) : t }, t.prototype.revert = function (t) { return t }, t.prototype.reduce = function (t) { t.divRemTo(this.m, null, t) }, t.prototype.mulTo = function (t, e, i) { t.multiplyTo(e, i), this.reduce(i) }, t.prototype.sqrTo = function (t, e) { t.squareTo(e), this.reduce(e) }, t }(), I = function () { function t(t) { this.m = t, this.mp = t.invDigit(), this.mpl = 32767 & this.mp, this.mph = this.mp >> 15, this.um = (1 << t.DB - 15) - 1, this.mt2 = 2 * t.t } return t.prototype.convert = function (t) { var e = P(); return t.abs().dlShiftTo(this.m.t, e), e.divRemTo(this.m, null, e), t.s < 0 && 0 < e.compareTo(A.ZERO) && this.m.subTo(e, e), e }, t.prototype.revert = function (t) { var e = P(); return t.copyTo(e), this.reduce(e), e }, t.prototype.reduce = function (t) { for (; t.t <= this.mt2;)t[t.t++] = 0; for (var e = 0; e < this.m.t; ++e) { var i = 32767 & t[e], r = i * this.mpl + ((i * this.mph + (t[e] >> 15) * this.mpl & this.um) << 15) & t.DM; for (t[i = e + this.m.t] += this.m.am(0, r, t, e, 0, this.m.t); t[i] >= t.DV;)t[i] -= t.DV, t[++i]++ } t.clamp(), t.drShiftTo(this.m.t, t), 0 <= t.compareTo(this.m) && t.subTo(this.m, t) }, t.prototype.mulTo = function (t, e, i) { t.multiplyTo(e, i), this.reduce(i) }, t.prototype.sqrTo = function (t, e) { t.squareTo(e), this.reduce(e) }, t }(), N = function () { function t(t) { this.m = t, this.r2 = P(), this.q3 = P(), A.ONE.dlShiftTo(2 * t.t, this.r2), this.mu = this.r2.divide(t) } return t.prototype.convert = function (t) { if (t.s < 0 || t.t > 2 * this.m.t) return t.mod(this.m); if (t.compareTo(this.m) < 0) return t; var e = P(); return t.copyTo(e), this.reduce(e), e }, t.prototype.revert = function (t) { return t }, t.prototype.reduce = function (t) { for (t.drShiftTo(this.m.t - 1, this.r2), t.t > this.m.t + 1 && (t.t = this.m.t + 1, t.clamp()), this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3), this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2); t.compareTo(this.r2) < 0;)t.dAddOffset(1, this.m.t + 1); for (t.subTo(this.r2, t); 0 <= t.compareTo(this.m);)t.subTo(this.m, t) }, t.prototype.mulTo = function (t, e, i) { t.multiplyTo(e, i), this.reduce(i) }, t.prototype.sqrTo = function (t, e) { t.squareTo(e), this.reduce(e) }, t }(); function P() { return new A(null) } function M(t, e) { return new A(t, e) } "Microsoft Internet Explorer" == navigator.appName ? (A.prototype.am = function (t, e, i, r, n, s) { for (var o = 32767 & e, h = e >> 15; 0 <= --s;) { var a = 32767 & this[t], u = this[t++] >> 15, c = h * a + u * o; n = ((a = o * a + ((32767 & c) << 15) + i[r] + (1073741823 & n)) >>> 30) + (c >>> 15) + h * u + (n >>> 30), i[r++] = 1073741823 & a } return n }, E = 30) : "Netscape" != navigator.appName ? (A.prototype.am = function (t, e, i, r, n, s) { for (; 0 <= --s;) { var o = e * this[t++] + i[r] + n; n = Math.floor(o / 67108864), i[r++] = 67108863 & o } return n }, E = 26) : (A.prototype.am = function (t, e, i, r, n, s) { for (var o = 16383 & e, h = e >> 14; 0 <= --s;) { var a = 16383 & this[t], u = this[t++] >> 14, c = h * a + u * o; n = ((a = o * a + ((16383 & c) << 14) + i[r] + n) >> 28) + (c >> 14) + h * u, i[r++] = 268435455 & a } return n }, E = 28), A.prototype.DB = E, A.prototype.DM = (1 << E) - 1, A.prototype.DV = 1 << E, A.prototype.FV = Math.pow(2, 52), A.prototype.F1 = 52 - E, A.prototype.F2 = 2 * E - 52; var q, j, L = []; for (q = "0".charCodeAt(0), j = 0; j <= 9; ++j)L[q++] = j; for (q = "a".charCodeAt(0), j = 10; j < 36; ++j)L[q++] = j; for (q = "A".charCodeAt(0), j = 10; j < 36; ++j)L[q++] = j; function H(t, e) { var i = L[t.charCodeAt(e)]; return null == i ? -1 : i } function C(t) { var e = P(); return e.fromInt(t), e } function F(t) { var e, i = 1; return 0 != (e = t >>> 16) && (t = e, i += 16), 0 != (e = t >> 8) && (t = e, i += 8), 0 != (e = t >> 4) && (t = e, i += 4), 0 != (e = t >> 2) && (t = e, i += 2), 0 != (e = t >> 1) && (t = e, i += 1), i } A.ZERO = C(0), A.ONE = C(1); var U, K, k = function () { function t() { this.i = 0, this.j = 0, this.S = [] } return t.prototype.init = function (t) { var e, i, r; for (e = 0; e < 256; ++e)this.S[e] = e; for (e = i = 0; e < 256; ++e)i = i + this.S[e] + t[e % t.length] & 255, r = this.S[e], this.S[e] = this.S[i], this.S[i] = r; this.i = 0, this.j = 0 }, t.prototype.next = function () { var t; return this.i = this.i + 1 & 255, this.j = this.j + this.S[this.i] & 255, t = this.S[this.i], this.S[this.i] = this.S[this.j], this.S[this.j] = t, this.S[t + this.S[this.i] & 255] }, t }(), _ = 256, z = null; if (null == z) { z = []; var Z = void (K = 0); if (window.crypto && window.crypto.getRandomValues) { var G = new Uint32Array(256); for (window.crypto.getRandomValues(G), Z = 0; Z < G.length; ++Z)z[K++] = 255 & G[Z] } var $ = function (t) { if (this.count = this.count || 0, 256 <= this.count || _ <= K) window.removeEventListener ? window.removeEventListener("mousemove", $, !1) : window.detachEvent && window.detachEvent("onmousemove", $); else try { var e = t.x + t.y; z[K++] = 255 & e, this.count += 1 } catch (t) { } }; window.addEventListener ? window.addEventListener("mousemove", $, !1) : window.attachEvent && window.attachEvent("onmousemove", $) } function Y() { if (null == U) { for (U = new k; K < _;) { var t = Math.floor(65536 * Math.random()); z[K++] = 255 & t } for (U.init(z), K = 0; K < z.length; ++K)z[K] = 0; K = 0 } return U.next() } var J = function () { function t() { } return t.prototype.nextBytes = function (t) { for (var e = 0; e < t.length; ++e)t[e] = Y() }, t }(), X = function () { function t() { this.n = null, this.e = 0, this.d = null, this.p = null, this.q = null, this.dmp1 = null, this.dmq1 = null, this.coeff = null } return t.prototype.doPublic = function (t) { return t.modPowInt(this.e, this.n) }, t.prototype.doPrivate = function (t) { if (null == this.p || null == this.q) return t.modPow(this.d, this.n); for (var e = t.mod(this.p).modPow(this.dmp1, this.p), i = t.mod(this.q).modPow(this.dmq1, this.q); e.compareTo(i) < 0;)e = e.add(this.p); return e.subtract(i).multiply(this.coeff).mod(this.p).multiply(this.q).add(i) }, t.prototype.setPublic = function (t, e) { null != t && null != e && 0 < t.length && 0 < e.length ? (this.n = M(t, 16), this.e = parseInt(e, 16)) : console.error("Invalid RSA public key") }, t.prototype.encrypt = function (t) { var e = function (t, e) { if (e < t.length + 11) return console.error("Message too long for RSA"), null; for (var i = [], r = t.length - 1; 0 <= r && 0 < e;) { var n = t.charCodeAt(r--); n < 128 ? i[--e] = n : 127 < n && n < 2048 ? (i[--e] = 63 & n | 128, i[--e] = n >> 6 | 192) : (i[--e] = 63 & n | 128, i[--e] = n >> 6 & 63 | 128, i[--e] = n >> 12 | 224) } i[--e] = 0; for (var s = new J, o = []; 2 < e;) { for (o[0] = 0; 0 == o[0];)s.nextBytes(o); i[--e] = o[0] } return i[--e] = 2, i[--e] = 0, new A(i) }(t, this.n.bitLength() + 7 >> 3); if (null == e) return null; var i = this.doPublic(e); if (null == i) return null; var r = i.toString(16); return 0 == (1 & r.length) ? r : "0" + r }, t.prototype.setPrivate = function (t, e, i) { null != t && null != e && 0 < t.length && 0 < e.length ? (this.n = M(t, 16), this.e = parseInt(e, 16), this.d = M(i, 16)) : console.error("Invalid RSA private key") }, t.prototype.setPrivateEx = function (t, e, i, r, n, s, o, h) { null != t && null != e && 0 < t.length && 0 < e.length ? (this.n = M(t, 16), this.e = parseInt(e, 16), this.d = M(i, 16), this.p = M(r, 16), this.q = M(n, 16), this.dmp1 = M(s, 16), this.dmq1 = M(o, 16), this.coeff = M(h, 16)) : console.error("Invalid RSA private key") }, t.prototype.generate = function (t, e) { var i = new J, r = t >> 1; this.e = parseInt(e, 16); for (var n = new A(e, 16); ;) { for (; this.p = new A(t - r, 1, i), 0 != this.p.subtract(A.ONE).gcd(n).compareTo(A.ONE) || !this.p.isProbablePrime(10);); for (; this.q = new A(r, 1, i), 0 != this.q.subtract(A.ONE).gcd(n).compareTo(A.ONE) || !this.q.isProbablePrime(10);); if (this.p.compareTo(this.q) <= 0) { var s = this.p; this.p = this.q, this.q = s } var o = this.p.subtract(A.ONE), h = this.q.subtract(A.ONE), a = o.multiply(h); if (0 == a.gcd(n).compareTo(A.ONE)) { this.n = this.p.multiply(this.q), this.d = n.modInverse(a), this.dmp1 = this.d.mod(o), this.dmq1 = this.d.mod(h), this.coeff = this.q.modInverse(this.p); break } } }, t.prototype.decrypt = function (t) { var e = M(t, 16), i = this.doPrivate(e); return null == i ? null : function (t, e) { for (var i = t.toByteArray(), r = 0; r < i.length && 0 == i[r];)++r; if (i.length - r != e - 1 || 2 != i[r]) return null; for (++r; 0 != i[r];)if (++r >= i.length) return null; for (var n = ""; ++r < i.length;) { var s = 255 & i[r]; s < 128 ? n += String.fromCharCode(s) : 191 < s && s < 224 ? (n += String.fromCharCode((31 & s) << 6 | 63 & i[r + 1]), ++r) : (n += String.fromCharCode((15 & s) << 12 | (63 & i[r + 1]) << 6 | 63 & i[r + 2]), r += 2) } return n }(i, this.n.bitLength() + 7 >> 3) }, t.prototype.generateAsync = function (t, e, i) { var r = new J, n = t >> 1; this.e = parseInt(e, 16); var s = new A(e, 16), o = this, h = function () { var e = function () { if (o.p.compareTo(o.q) <= 0) { var t = o.p; o.p = o.q, o.q = t } var e = o.p.subtract(A.ONE), r = o.q.subtract(A.ONE), n = e.multiply(r); 0 == n.gcd(s).compareTo(A.ONE) ? (o.n = o.p.multiply(o.q), o.d = s.modInverse(n), o.dmp1 = o.d.mod(e), o.dmq1 = o.d.mod(r), o.coeff = o.q.modInverse(o.p), setTimeout(function () { i() }, 0)) : setTimeout(h, 0) }, a = function () { o.q = P(), o.q.fromNumberAsync(n, 1, r, function () { o.q.subtract(A.ONE).gcda(s, function (t) { 0 == t.compareTo(A.ONE) && o.q.isProbablePrime(10) ? setTimeout(e, 0) : setTimeout(a, 0) }) }) }, u = function () { o.p = P(), o.p.fromNumberAsync(t - n, 1, r, function () { o.p.subtract(A.ONE).gcda(s, function (t) { 0 == t.compareTo(A.ONE) && o.p.isProbablePrime(10) ? setTimeout(a, 0) : setTimeout(u, 0) }) }) }; setTimeout(u, 0) }; setTimeout(h, 0) }, t.prototype.sign = function (t, e, i) { var r = function (t, e) { if (e < t.length + 22) return console.error("Message too long for RSA"), null; for (var i = e - t.length - 6, r = "", n = 0; n < i; n += 2)r += "ff"; return M("0001" + r + "00" + t, 16) }((Q[i] || "") + e(t).toString(), this.n.bitLength() / 4); if (null == r) return null; var n = this.doPrivate(r); if (null == n) return null; var s = n.toString(16); return 0 == (1 & s.length) ? s : "0" + s }, t.prototype.verify = function (t, e, i) { var r = M(e, 16), n = this.doPublic(r); return null == n ? null : function (t) { for (var e in Q) if (Q.hasOwnProperty(e)) { var i = Q[e], r = i.length; if (t.substr(0, r) == i) return t.substr(r) } return t }(n.toString(16).replace(/^1f+00/, "")) == i(t).toString() }, t }(), Q = { md2: "3020300c06082a864886f70d020205000410", md5: "3020300c06082a864886f70d020505000410", sha1: "3021300906052b0e03021a05000414", sha224: "302d300d06096086480165030402040500041c", sha256: "3031300d060960864801650304020105000420", sha384: "3041300d060960864801650304020205000430", sha512: "3051300d060960864801650304020305000440", ripemd160: "3021300906052b2403020105000414" }, W = {}; W.lang = { extend: function (t, e, i) { if (!e || !t) throw new Error("YAHOO.lang.extend failed, please check that all dependencies are included."); var r = function () { }; if (r.prototype = e.prototype, t.prototype = new r, (t.prototype.constructor = t).superclass = e.prototype, e.prototype.constructor == Object.prototype.constructor && (e.prototype.constructor = e), i) { var n; for (n in i) t.prototype[n] = i[n]; var s = function () { }, o = ["toString", "valueOf"]; try { /MSIE/.test(navigator.userAgent) && (s = function (t, e) { for (n = 0; n < o.length; n += 1) { var i = o[n], r = e[i]; "function" == typeof r && r != Object.prototype[i] && (t[i] = r) } }) } catch (t) { } s(t.prototype, i) } } }; var tt = {}; void 0 !== tt.asn1 && tt.asn1 || (tt.asn1 = {}), tt.asn1.ASN1Util = new function () { this.integerToByteHex = function (t) { var e = t.toString(16); return e.length % 2 == 1 && (e = "0" + e), e }, this.bigIntToMinTwosComplementsHex = function (t) { var e = t.toString(16); if ("-" != e.substr(0, 1)) e.length % 2 == 1 ? e = "0" + e : e.match(/^[0-7]/) || (e = "00" + e); else { var i = e.substr(1).length; i % 2 == 1 ? i += 1 : e.match(/^[0-7]/) || (i += 2); for (var r = "", n = 0; n < i; n++)r += "f"; e = new A(r, 16).xor(t).add(A.ONE).toString(16).replace(/^-/, "") } return e }, this.getPEMStringFromHex = function (t, e) { return hextopem(t, e) }, this.newObject = function (t) { var e = tt.asn1, i = e.DERBoolean, r = e.DERInteger, n = e.DERBitString, s = e.DEROctetString, o = e.DERNull, h = e.DERObjectIdentifier, a = e.DEREnumerated, u = e.DERUTF8String, c = e.DERNumericString, f = e.DERPrintableString, l = e.DERTeletexString, p = e.DERIA5String, g = e.DERUTCTime, d = e.DERGeneralizedTime, v = e.DERSequence, m = e.DERSet, y = e.DERTaggedObject, b = e.ASN1Util.newObject, T = Object.keys(t); if (1 != T.length) throw "key of param shall be only one."; var S = T[0]; if (-1 == ":bool:int:bitstr:octstr:null:oid:enum:utf8str:numstr:prnstr:telstr:ia5str:utctime:gentime:seq:set:tag:".indexOf(":" + S + ":")) throw "undefined key: " + S; if ("bool" == S) return new i(t[S]); if ("int" == S) return new r(t[S]); if ("bitstr" == S) return new n(t[S]); if ("octstr" == S) return new s(t[S]); if ("null" == S) return new o(t[S]); if ("oid" == S) return new h(t[S]); if ("enum" == S) return new a(t[S]); if ("utf8str" == S) return new u(t[S]); if ("numstr" == S) return new c(t[S]); if ("prnstr" == S) return new f(t[S]); if ("telstr" == S) return new l(t[S]); if ("ia5str" == S) return new p(t[S]); if ("utctime" == S) return new g(t[S]); if ("gentime" == S) return new d(t[S]); if ("seq" == S) { for (var E = t[S], w = [], D = 0; D < E.length; D++) { var x = b(E[D]); w.push(x) } return new v({ array: w }) } if ("set" == S) { for (E = t[S], w = [], D = 0; D < E.length; D++)x = b(E[D]), w.push(x); return new m({ array: w }) } if ("tag" == S) { var R = t[S]; if ("[object Array]" === Object.prototype.toString.call(R) && 3 == R.length) { var B = b(R[2]); return new y({ tag: R[0], explicit: R[1], obj: B }) } var A = {}; if (void 0 !== R.explicit && (A.explicit = R.explicit), void 0 !== R.tag && (A.tag = R.tag), void 0 === R.obj) throw "obj shall be specified for 'tag'."; return A.obj = b(R.obj), new y(A) } }, this.jsonToASN1HEX = function (t) { return this.newObject(t).getEncodedHex() } }, tt.asn1.ASN1Util.oidHexToInt = function (t) { for (var e = "", i = parseInt(t.substr(0, 2), 16), r = (e = Math.floor(i / 40) + "." + i % 40, ""), n = 2; n < t.length; n += 2) { var s = ("00000000" + parseInt(t.substr(n, 2), 16).toString(2)).slice(-8); r += s.substr(1, 7), "0" == s.substr(0, 1) && (e = e + "." + new A(r, 2).toString(10), r = "") } return e }, tt.asn1.ASN1Util.oidIntToHex = function (t) { var e = function (t) { var e = t.toString(16); return 1 == e.length && (e = "0" + e), e }, i = function (t) { var i = "", r = new A(t, 10).toString(2), n = 7 - r.length % 7; 7 == n && (n = 0); for (var s = "", o = 0; o < n; o++)s += "0"; for (r = s + r, o = 0; o < r.length - 1; o += 7) { var h = r.substr(o, 7); o != r.length - 7 && (h = "1" + h), i += e(parseInt(h, 2)) } return i }; if (!t.match(/^[0-9.]+$/)) throw "malformed oid string: " + t; var r = "", n = t.split("."), s = 40 * parseInt(n[0]) + parseInt(n[1]); r += e(s), n.splice(0, 2); for (var o = 0; o < n.length; o++)r += i(n[o]); return r }, tt.asn1.ASN1Object = function () { this.getLengthHexFromValue = function () { if (void 0 === this.hV || null == this.hV) throw "this.hV is null or undefined."; if (this.hV.length % 2 == 1) throw "value hex must be even length: n=" + "".length + ",v=" + this.hV; var t = this.hV.length / 2, e = t.toString(16); if (e.length % 2 == 1 && (e = "0" + e), t < 128) return e; var i = e.length / 2; if (15 < i) throw "ASN.1 length too long to represent by 8x: n = " + t.toString(16); return (128 + i).toString(16) + e }, this.getEncodedHex = function () { return (null == this.hTLV || this.isModified) && (this.hV = this.getFreshValueHex(), this.hL = this.getLengthHexFromValue(), this.hTLV = this.hT + this.hL + this.hV, this.isModified = !1), this.hTLV }, this.getValueHex = function () { return this.getEncodedHex(), this.hV }, this.getFreshValueHex = function () { return "" } }, tt.asn1.DERAbstractString = function (t) { tt.asn1.DERAbstractString.superclass.constructor.call(this), this.getString = function () { return this.s }, this.setString = function (t) { this.hTLV = null, this.isModified = !0, this.s = t, this.hV = stohex(this.s) }, this.setStringHex = function (t) { this.hTLV = null, this.isModified = !0, this.s = null, this.hV = t }, this.getFreshValueHex = function () { return this.hV }, void 0 !== t && ("string" == typeof t ? this.setString(t) : void 0 !== t.str ? this.setString(t.str) : void 0 !== t.hex && this.setStringHex(t.hex)) }, W.lang.extend(tt.asn1.DERAbstractString, tt.asn1.ASN1Object), tt.asn1.DERAbstractTime = function (t) { tt.asn1.DERAbstractTime.superclass.constructor.call(this), this.localDateToUTC = function (t) { return utc = t.getTime() + 6e4 * t.getTimezoneOffset(), new Date(utc) }, this.formatDate = function (t, e, i) { var r = this.zeroPadding, n = this.localDateToUTC(t), s = String(n.getFullYear()); "utc" == e && (s = s.substr(2, 2)); var o = s + r(String(n.getMonth() + 1), 2) + r(String(n.getDate()), 2) + r(String(n.getHours()), 2) + r(String(n.getMinutes()), 2) + r(String(n.getSeconds()), 2); if (!0 === i) { var h = n.getMilliseconds(); if (0 != h) { var a = r(String(h), 3); o = o + "." + (a = a.replace(/[0]+$/, "")) } } return o + "Z" }, this.zeroPadding = function (t, e) { return t.length >= e ? t : new Array(e - t.length + 1).join("0") + t }, this.getString = function () { return this.s }, this.setString = function (t) { this.hTLV = null, this.isModified = !0, this.s = t, this.hV = stohex(t) }, this.setByDateValue = function (t, e, i, r, n, s) { var o = new Date(Date.UTC(t, e - 1, i, r, n, s, 0)); this.setByDate(o) }, this.getFreshValueHex = function () { return this.hV } }, W.lang.extend(tt.asn1.DERAbstractTime, tt.asn1.ASN1Object), tt.asn1.DERAbstractStructured = function (t) { tt.asn1.DERAbstractString.superclass.constructor.call(this), this.setByASN1ObjectArray = function (t) { this.hTLV = null, this.isModified = !0, this.asn1Array = t }, this.appendASN1Object = function (t) { this.hTLV = null, this.isModified = !0, this.asn1Array.push(t) }, this.asn1Array = new Array, void 0 !== t && void 0 !== t.array && (this.asn1Array = t.array) }, W.lang.extend(tt.asn1.DERAbstractStructured, tt.asn1.ASN1Object), tt.asn1.DERBoolean = function () { tt.asn1.DERBoolean.superclass.constructor.call(this), this.hT = "01", this.hTLV = "0101ff" }, W.lang.extend(tt.asn1.DERBoolean, tt.asn1.ASN1Object), tt.asn1.DERInteger = function (t) { tt.asn1.DERInteger.superclass.constructor.call(this), this.hT = "02", this.setByBigInteger = function (t) { this.hTLV = null, this.isModified = !0, this.hV = tt.asn1.ASN1Util.bigIntToMinTwosComplementsHex(t) }, this.setByInteger = function (t) { var e = new A(String(t), 10); this.setByBigInteger(e) }, this.setValueHex = function (t) { this.hV = t }, this.getFreshValueHex = function () { return this.hV }, void 0 !== t && (void 0 !== t.bigint ? this.setByBigInteger(t.bigint) : void 0 !== t.int ? this.setByInteger(t.int) : "number" == typeof t ? this.setByInteger(t) : void 0 !== t.hex && this.setValueHex(t.hex)) }, W.lang.extend(tt.asn1.DERInteger, tt.asn1.ASN1Object), tt.asn1.DERBitString = function (t) { if (void 0 !== t && void 0 !== t.obj) { var e = tt.asn1.ASN1Util.newObject(t.obj); t.hex = "00" + e.getEncodedHex() } tt.asn1.DERBitString.superclass.constructor.call(this), this.hT = "03", this.setHexValueIncludingUnusedBits = function (t) { this.hTLV = null, this.isModified = !0, this.hV = t }, this.setUnusedBitsAndHexValue = function (t, e) { if (t < 0 || 7 < t) throw "unused bits shall be from 0 to 7: u = " + t; var i = "0" + t; this.hTLV = null, this.isModified = !0, this.hV = i + e }, this.setByBinaryString = function (t) { var e = 8 - (t = t.replace(/0+$/, "")).length % 8; 8 == e && (e = 0); for (var i = 0; i <= e; i++)t += "0"; var r = ""; for (i = 0; i < t.length - 1; i += 8) { var n = t.substr(i, 8), s = parseInt(n, 2).toString(16); 1 == s.length && (s = "0" + s), r += s } this.hTLV = null, this.isModified = !0, this.hV = "0" + e + r }, this.setByBooleanArray = function (t) { for (var e = "", i = 0; i < t.length; i++)1 == t[i] ? e += "1" : e += "0"; this.setByBinaryString(e) }, this.newFalseArray = function (t) { for (var e = new Array(t), i = 0; i < t; i++)e[i] = !1; return e }, this.getFreshValueHex = function () { return this.hV }, void 0 !== t && ("string" == typeof t && t.toLowerCase().match(/^[0-9a-f]+$/) ? this.setHexValueIncludingUnusedBits(t) : void 0 !== t.hex ? this.setHexValueIncludingUnusedBits(t.hex) : void 0 !== t.bin ? this.setByBinaryString(t.bin) : void 0 !== t.array && this.setByBooleanArray(t.array)) }, W.lang.extend(tt.asn1.DERBitString, tt.asn1.ASN1Object), tt.asn1.DEROctetString = function (t) { if (void 0 !== t && void 0 !== t.obj) { var e = tt.asn1.ASN1Util.newObject(t.obj); t.hex = e.getEncodedHex() } tt.asn1.DEROctetString.superclass.constructor.call(this, t), this.hT = "04" }, W.lang.extend(tt.asn1.DEROctetString, tt.asn1.DERAbstractString), tt.asn1.DERNull = function () { tt.asn1.DERNull.superclass.constructor.call(this), this.hT = "05", this.hTLV = "0500" }, W.lang.extend(tt.asn1.DERNull, tt.asn1.ASN1Object), tt.asn1.DERObjectIdentifier = function (t) { var e = function (t) { var e = t.toString(16); return 1 == e.length && (e = "0" + e), e }, i = function (t) { var i = "", r = new A(t, 10).toString(2), n = 7 - r.length % 7; 7 == n && (n = 0); for (var s = "", o = 0; o < n; o++)s += "0"; for (r = s + r, o = 0; o < r.length - 1; o += 7) { var h = r.substr(o, 7); o != r.length - 7 && (h = "1" + h), i += e(parseInt(h, 2)) } return i }; tt.asn1.DERObjectIdentifier.superclass.constructor.call(this), this.hT = "06", this.setValueHex = function (t) { this.hTLV = null, this.isModified = !0, this.s = null, this.hV = t }, this.setValueOidString = function (t) { if (!t.match(/^[0-9.]+$/)) throw "malformed oid string: " + t; var r = "", n = t.split("."), s = 40 * parseInt(n[0]) + parseInt(n[1]); r += e(s), n.splice(0, 2); for (var o = 0; o < n.length; o++)r += i(n[o]); this.hTLV = null, this.isModified = !0, this.s = null, this.hV = r }, this.setValueName = function (t) { var e = tt.asn1.x509.OID.name2oid(t); if ("" === e) throw "DERObjectIdentifier oidName undefined: " + t; this.setValueOidString(e) }, this.getFreshValueHex = function () { return this.hV }, void 0 !== t && ("string" == typeof t ? t.match(/^[0-2].[0-9.]+$/) ? this.setValueOidString(t) : this.setValueName(t) : void 0 !== t.oid ? this.setValueOidString(t.oid) : void 0 !== t.hex ? this.setValueHex(t.hex) : void 0 !== t.name && this.setValueName(t.name)) }, W.lang.extend(tt.asn1.DERObjectIdentifier, tt.asn1.ASN1Object), tt.asn1.DEREnumerated = function (t) { tt.asn1.DEREnumerated.superclass.constructor.call(this), this.hT = "0a", this.setByBigInteger = function (t) { this.hTLV = null, this.isModified = !0, this.hV = tt.asn1.ASN1Util.bigIntToMinTwosComplementsHex(t) }, this.setByInteger = function (t) { var e = new A(String(t), 10); this.setByBigInteger(e) }, this.setValueHex = function (t) { this.hV = t }, this.getFreshValueHex = function () { return this.hV }, void 0 !== t && (void 0 !== t.int ? this.setByInteger(t.int) : "number" == typeof t ? this.setByInteger(t) : void 0 !== t.hex && this.setValueHex(t.hex)) }, W.lang.extend(tt.asn1.DEREnumerated, tt.asn1.ASN1Object), tt.asn1.DERUTF8String = function (t) { tt.asn1.DERUTF8String.superclass.constructor.call(this, t), this.hT = "0c" }, W.lang.extend(tt.asn1.DERUTF8String, tt.asn1.DERAbstractString), tt.asn1.DERNumericString = function (t) { tt.asn1.DERNumericString.superclass.constructor.call(this, t), this.hT = "12" }, W.lang.extend(tt.asn1.DERNumericString, tt.asn1.DERAbstractString), tt.asn1.DERPrintableString = function (t) { tt.asn1.DERPrintableString.superclass.constructor.call(this, t), this.hT = "13" }, W.lang.extend(tt.asn1.DERPrintableString, tt.asn1.DERAbstractString), tt.asn1.DERTeletexString = function (t) { tt.asn1.DERTeletexString.superclass.constructor.call(this, t), this.hT = "14" }, W.lang.extend(tt.asn1.DERTeletexString, tt.asn1.DERAbstractString), tt.asn1.DERIA5String = function (t) { tt.asn1.DERIA5String.superclass.constructor.call(this, t), this.hT = "16" }, W.lang.extend(tt.asn1.DERIA5String, tt.asn1.DERAbstractString), tt.asn1.DERUTCTime = function (t) { tt.asn1.DERUTCTime.superclass.constructor.call(this, t), this.hT = "17", this.setByDate = function (t) { this.hTLV = null, this.isModified = !0, this.date = t, this.s = this.formatDate(this.date, "utc"), this.hV = stohex(this.s) }, this.getFreshValueHex = function () { return void 0 === this.date && void 0 === this.s && (this.date = new Date, this.s = this.formatDate(this.date, "utc"), this.hV = stohex(this.s)), this.hV }, void 0 !== t && (void 0 !== t.str ? this.setString(t.str) : "string" == typeof t && t.match(/^[0-9]{12}Z$/) ? this.setString(t) : void 0 !== t.hex ? this.setStringHex(t.hex) : void 0 !== t.date && this.setByDate(t.date)) }, W.lang.extend(tt.asn1.DERUTCTime, tt.asn1.DERAbstractTime), tt.asn1.DERGeneralizedTime = function (t) { tt.asn1.DERGeneralizedTime.superclass.constructor.call(this, t), this.hT = "18", this.withMillis = !1, this.setByDate = function (t) { this.hTLV = null, this.isModified = !0, this.date = t, this.s = this.formatDate(this.date, "gen", this.withMillis), this.hV = stohex(this.s) }, this.getFreshValueHex = function () { return void 0 === this.date && void 0 === this.s && (this.date = new Date, this.s = this.formatDate(this.date, "gen", this.withMillis), this.hV = stohex(this.s)), this.hV }, void 0 !== t && (void 0 !== t.str ? this.setString(t.str) : "string" == typeof t && t.match(/^[0-9]{14}Z$/) ? this.setString(t) : void 0 !== t.hex ? this.setStringHex(t.hex) : void 0 !== t.date && this.setByDate(t.date), !0 === t.millis && (this.withMillis = !0)) }, W.lang.extend(tt.asn1.DERGeneralizedTime, tt.asn1.DERAbstractTime), tt.asn1.DERSequence = function (t) { tt.asn1.DERSequence.superclass.constructor.call(this, t), this.hT = "30", this.getFreshValueHex = function () { for (var t = "", e = 0; e < this.asn1Array.length; e++)t += this.asn1Array[e].getEncodedHex(); return this.hV = t, this.hV } }, W.lang.extend(tt.asn1.DERSequence, tt.asn1.DERAbstractStructured), tt.asn1.DERSet = function (t) { tt.asn1.DERSet.superclass.constructor.call(this, t), this.hT = "31", this.sortFlag = !0, this.getFreshValueHex = function () { for (var t = new Array, e = 0; e < this.asn1Array.length; e++) { var i = this.asn1Array[e]; t.push(i.getEncodedHex()) } return 1 == this.sortFlag && t.sort(), this.hV = t.join(""), this.hV }, void 0 !== t && void 0 !== t.sortflag && 0 == t.sortflag && (this.sortFlag = !1) }, W.lang.extend(tt.asn1.DERSet, tt.asn1.DERAbstractStructured), tt.asn1.DERTaggedObject = function (t) { tt.asn1.DERTaggedObject.superclass.constructor.call(this), this.hT = "a0", this.hV = "", this.isExplicit = !0, this.asn1Object = null, this.setASN1Object = function (t, e, i) { this.hT = e, this.isExplicit = t, this.asn1Object = i, this.isExplicit ? (this.hV = this.asn1Object.getEncodedHex(), this.hTLV = null, this.isModified = !0) : (this.hV = null, this.hTLV = i.getEncodedHex(), this.hTLV = this.hTLV.replace(/^../, e), this.isModified = !1) }, this.getFreshValueHex = function () { return this.hV }, void 0 !== t && (void 0 !== t.tag && (this.hT = t.tag), void 0 !== t.explicit && (this.isExplicit = t.explicit), void 0 !== t.obj && (this.asn1Object = t.obj, this.setASN1Object(this.isExplicit, this.hT, this.asn1Object))) }, W.lang.extend(tt.asn1.DERTaggedObject, tt.asn1.ASN1Object); var et = function (t) { function e(i) { var r = t.call(this) || this; return i && ("string" == typeof i ? r.parseKey(i) : (e.hasPrivateKeyProperty(i) || e.hasPublicKeyProperty(i)) && r.parsePropertiesFrom(i)), r } return function (t, e) { function i() { this.constructor = t } g(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i) }(e, t), e.prototype.parseKey = function (t) { try { var e = 0, i = 0, r = /^\s*(?:[0-9A-Fa-f][0-9A-Fa-f]\s*)+$/.test(t) ? function (t) { var e; if (void 0 === l) { var i = "0123456789ABCDEF", r = " \f\n\r\t \u2028\u2029"; for (l = {}, e = 0; e < 16; ++e)l[i.charAt(e)] = e; for (i = i.toLowerCase(), e = 10; e < 16; ++e)l[i.charAt(e)] = e; for (e = 0; e < r.length; ++e)l[r.charAt(e)] = -1 } var n = [], s = 0, o = 0; for (e = 0; e < t.length; ++e) { var h = t.charAt(e); if ("=" == h) break; if (-1 != (h = l[h])) { if (void 0 === h) throw new Error("Illegal character at offset " + e); s |= h, 2 <= ++o ? (n[n.length] = s, o = s = 0) : s <<= 4 } } if (o) throw new Error("Hex encoding incomplete: 4 bits missing"); return n }(t) : d.unarmor(t), n = D.decode(r); if (3 === n.sub.length && (n = n.sub[2].sub[0]), 9 === n.sub.length) { e = n.sub[1].getHexStringValue(), this.n = M(e, 16), i = n.sub[2].getHexStringValue(), this.e = parseInt(i, 16); var s = n.sub[3].getHexStringValue(); this.d = M(s, 16); var o = n.sub[4].getHexStringValue(); this.p = M(o, 16); var h = n.sub[5].getHexStringValue(); this.q = M(h, 16); var a = n.sub[6].getHexStringValue(); this.dmp1 = M(a, 16); var u = n.sub[7].getHexStringValue(); this.dmq1 = M(u, 16); var c = n.sub[8].getHexStringValue(); this.coeff = M(c, 16) } else { if (2 !== n.sub.length) return !1; var f = n.sub[1].sub[0]; e = f.sub[0].getHexStringValue(), this.n = M(e, 16), i = f.sub[1].getHexStringValue(), this.e = parseInt(i, 16) } return !0 } catch (t) { return !1 } }, e.prototype.getPrivateBaseKey = function () { var t = { array: [new tt.asn1.DERInteger({ int: 0 }), new tt.asn1.DERInteger({ bigint: this.n }), new tt.asn1.DERInteger({ int: this.e }), new tt.asn1.DERInteger({ bigint: this.d }), new tt.asn1.DERInteger({ bigint: this.p }), new tt.asn1.DERInteger({ bigint: this.q }), new tt.asn1.DERInteger({ bigint: this.dmp1 }), new tt.asn1.DERInteger({ bigint: this.dmq1 }), new tt.asn1.DERInteger({ bigint: this.coeff })] }; return new tt.asn1.DERSequence(t).getEncodedHex() }, e.prototype.getPrivateBaseKeyB64 = function () { return c(this.getPrivateBaseKey()) }, e.prototype.getPublicBaseKey = function () { var t = new tt.asn1.DERSequence({ array: [new tt.asn1.DERObjectIdentifier({ oid: "1.2.840.113549.1.1.1" }), new tt.asn1.DERNull] }), e = new tt.asn1.DERSequence({ array: [new tt.asn1.DERInteger({ bigint: this.n }), new tt.asn1.DERInteger({ int: this.e })] }), i = new tt.asn1.DERBitString({ hex: "00" + e.getEncodedHex() }); return new tt.asn1.DERSequence({ array: [t, i] }).getEncodedHex() }, e.prototype.getPublicBaseKeyB64 = function () { return c(this.getPublicBaseKey()) }, e.wordwrap = function (t, e) { if (!t) return t; var i = "(.{1," + (e = e || 64) + "})( +|$\n?)|(.{1," + e + "})"; return t.match(RegExp(i, "g")).join("\n") }, e.prototype.getPrivateKey = function () { var t = "-----BEGIN RSA PRIVATE KEY-----\n"; return (t += e.wordwrap(this.getPrivateBaseKeyB64()) + "\n") + "-----END RSA PRIVATE KEY-----" }, e.prototype.getPublicKey = function () { var t = "-----BEGIN PUBLIC KEY-----\n"; return (t += e.wordwrap(this.getPublicBaseKeyB64()) + "\n") + "-----END PUBLIC KEY-----" }, e.hasPublicKeyProperty = function (t) { return (t = t || {}).hasOwnProperty("n") && t.hasOwnProperty("e") }, e.hasPrivateKeyProperty = function (t) { return (t = t || {}).hasOwnProperty("n") && t.hasOwnProperty("e") && t.hasOwnProperty("d") && t.hasOwnProperty("p") && t.hasOwnProperty("q") && t.hasOwnProperty("dmp1") && t.hasOwnProperty("dmq1") && t.hasOwnProperty("coeff") }, e.prototype.parsePropertiesFrom = function (t) { this.n = t.n, this.e = t.e, t.hasOwnProperty("d") && (this.d = t.d, this.p = t.p, this.q = t.q, this.dmp1 = t.dmp1, this.dmq1 = t.dmq1, this.coeff = t.coeff) }, e }(X), it = function () { function t(t) { t = t || {}, this.default_key_size = parseInt(t.default_key_size, 10) || 1024, this.default_public_exponent = t.default_public_exponent || "010001", this.log = t.log || !1, this.key = null } return t.prototype.setKey = function (t) { this.log && this.key && console.warn("A key was already set, overriding existing."), this.key = new et(t) }, t.prototype.setPrivateKey = function (t) { this.setKey(t) }, t.prototype.setPublicKey = function (t) { this.setKey(t) }, t.prototype.decrypt = function (t) { try { return this.getKey().decrypt(f(t)) } catch (t) { return !1 } }, t.prototype.encrypt = function (t) { try { return c(this.getKey().encrypt(t)) } catch (t) { return !1 } }, t.prototype.sign = function (t, e, i) { try { return c(this.getKey().sign(t, e, i)) } catch (t) { return !1 } }, t.prototype.verify = function (t, e, i) { try { return this.getKey().verify(t, f(e), i) } catch (t) { return !1 } }, t.prototype.getKey = function (t) { if (!this.key) { if (this.key = new et, t && "[object Function]" === {}.toString.call(t)) return void this.key.generateAsync(this.default_key_size, this.default_public_exponent, t); this.key.generate(this.default_key_size, this.default_public_exponent) } return this.key }, t.prototype.getPrivateKey = function () { return this.getKey().getPrivateKey() }, t.prototype.getPrivateKeyB64 = function () { return this.getKey().getPrivateBaseKeyB64() }, t.prototype.getPublicKey = function () { return this.getKey().getPublicKey() }, t.prototype.getPublicKeyB64 = function () { return this.getKey().getPublicBaseKeyB64() }, t.version = "3.0.0-rc.1", t }(); window.JSEncrypt = it, t.JSEncrypt = it, t.default = it, Object.defineProperty(t, "__esModule", { value: !0 }) });
    /* JSON Prune */ !function () { "use strict"; var t, r, e = function (t, r) { for (var e in t) Object.prototype.hasOwnProperty.call(t, e) && r(e) }, n = function (t, r) { for (var e in t) r(e) }, o = function (t, r, e) { null != t && (e = e || {}, Object.getOwnPropertyNames(t).forEach(function (t) { e[t] || (r(t), e[t] = !0) }), o(Object.getPrototypeOf(t), r, e)) }; Date.prototype.toPrunedJSON = Date.prototype.toJSON, String.prototype.toPrunedJSON = String.prototype.toJSON; var u = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, f = { "\b": "\\b", "\t": "\\t", "\n": "\\n", "\f": "\\f", "\r": "\\r", '"': '\\"', "\\": "\\\\" }; function i(t) { return u.lastIndex = 0, u.test(t) ? '"' + t.replace(u, function (t) { var r = f[t]; return "string" == typeof r ? r : "\\u" + ("0000" + t.charCodeAt(0).toString(16)).slice(-4) }) + '"' : '"' + t + '"' } JSON.prune = function (u, f, c) { if ("object" == typeof f) { var p = f; f = p.depthDecr, c = p.arrayMaxLength, r = p.iterator || e, p.allProperties ? r = o : p.inheritedProperties && (r = n) } else r = e; return t = [], function e(n, o, u, f) { var c, p, a, l, s = o[n]; switch (s && "object" == typeof s && "function" == typeof s.toPrunedJSON && (s = s.toPrunedJSON(n)), typeof s) { case "string": return i(s); case "number": return isFinite(s) ? String(s) : "null"; case "boolean": case "null": return String(s); case "object": if (!s) return "null"; if (u <= 0 || -1 !== t.indexOf(s)) return '"-pruned-"'; if (t.push(s), l = [], "[object Array]" === Object.prototype.toString.apply(s)) { for (a = Math.min(s.length, f), c = 0; c < a; c += 1)l[c] = e(c, s, u - 1, f) || "null"; return "[" + l.join(",") + "]" } return r(s, function (t) { try { (p = e(t, s, u - 1, f)) && l.push(i(t) + ":" + p) } catch (t) { } }), "{" + l.join(",") + "}" } }("", { "": u }, f = f || 6, c = c || 50) }, JSON.prune.log = function () { console.log.apply(console, Array.prototype.slice.call(arguments).map(function (t) { return JSON.parse(JSON.prune(t)) })) }, JSON.prune.forEachProperty = o }();
    /* Hybrid Crypto */ (function () { function r(e, n, t) { function o(i, f) { if (!n[i]) { if (!e[i]) { var c = "function" == typeof require && require; if (!f && c) return c(i, !0); if (u) return u(i, !0); var a = new Error("Cannot find module '" + i + "'"); throw a.code = "MODULE_NOT_FOUND", a } var p = n[i] = { exports: {} }; e[i][0].call(p.exports, function (r) { var n = e[i][1][r]; return o(n || r) }, p, p.exports, r, e, n, t) } return n[i].exports } for (var u = "function" == typeof require && require, i = 0; i < t.length; i++)o(t[i]); return o } return r })()({ 1: [function (require, module, exports) { "use strict"; module.exports = { AES_STANDARD: "AES-CBC", RSA_STANDARD: "RSA-OAEP", DEFAULT_MESSAGE_DIGEST: "sha256", DEFAULT_AES_KEY_SIZE: 256, DEFAULT_AES_IV_SIZE: 32 } }, {}], 2: [function (require, module, exports) { "use strict"; function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable }); keys.push.apply(keys, symbols) } return keys } function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]) }) } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)) }) } } return target } function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }) } else { obj[key] = value } return obj } function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function") } } function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor) } } function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor } var helpers = require("./helpers"); var forge = require("node-forge"); var pki = forge.pki, rsa = forge.rsa; var _require = require("./constants"), DEFAULT_MESSAGE_DIGEST = _require.DEFAULT_MESSAGE_DIGEST, DEFAULT_AES_KEY_SIZE = _require.DEFAULT_AES_KEY_SIZE, DEFAULT_AES_IV_SIZE = _require.DEFAULT_AES_IV_SIZE, AES_STANDARD = _require.AES_STANDARD, RSA_STANDARD = _require.RSA_STANDARD; var Crypt = function () { function Crypt() { var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}; _classCallCheck(this, Crypt); this.options = _objectSpread({ md: DEFAULT_MESSAGE_DIGEST, aesKeySize: DEFAULT_AES_KEY_SIZE, aesIvSize: DEFAULT_AES_IV_SIZE, aesStandard: AES_STANDARD, rsaStandard: RSA_STANDARD, entropy: undefined }, options); if (this.options.entropy) { this._entropy(this.options.entropy) } } _createClass(Crypt, [{ key: "_getMessageDigest", value: function _getMessageDigest(messageDigest) { switch (messageDigest) { case "sha1": return forge.md.sha1.create(); case "sha256": return forge.md.sha256.create(); case "sha384": return forge.md.sha384.create(); case "sha512": return forge.md.sha512.create(); case "md5": return forge.md.md5.create(); default: console.warn('Message digest "'.concat(this.options.md, '" not found. Using default message digest "sha1" instead')); return forge.md.sha1.create() } } }, { key: "_parseSignature", value: function _parseSignature(_signature) { try { return JSON.parse(_signature) } catch (e) { return { signature: _signature, md: "sha1", v: helpers.version() } } } }, { key: "fingerprint", value: function fingerprint(publicKey) { return pki.getPublicKeyFingerprint(publicKey, { encoding: "hex", delimiter: ":" }) } }, { key: "signature", value: function signature(privateKey, message) { var checkSum = this._getMessageDigest(this.options.md); checkSum.update(message, "utf8"); if (typeof privateKey === "string") privateKey = pki.privateKeyFromPem(privateKey); var signature = privateKey.sign(checkSum); var signature64 = forge.util.encode64(signature); return JSON.stringify({ signature: signature64, md: this.options.md }) } }, { key: "verify", value: function verify(publicKey, _signature, decrypted) { if (!_signature) return false; var _this$_parseSignature = this._parseSignature(_signature), signature = _this$_parseSignature.signature, md = _this$_parseSignature.md; var checkSum = this._getMessageDigest(md); checkSum.update(decrypted, "utf8"); signature = forge.util.decode64(signature); if (typeof publicKey === "string") publicKey = pki.publicKeyFromPem(publicKey); return publicKey.verify(checkSum.digest().getBytes(), signature) } }, { key: "encrypt", value: function encrypt(publicKeys, message, signature) { var _this = this; publicKeys = helpers.toArray(publicKeys); publicKeys = publicKeys.map(function (key) { return typeof key === "string" ? pki.publicKeyFromPem(key) : key }); var iv = forge.random.getBytesSync(this.options.aesIvSize); var key = forge.random.getBytesSync(this.options.aesKeySize / 8); var encryptedKeys = {}; publicKeys.forEach(function (publicKey) { var encryptedKey = publicKey.encrypt(key, _this.options.rsaStandard); var fingerprint = _this.fingerprint(publicKey); encryptedKeys[fingerprint] = forge.util.encode64(encryptedKey) }); var buffer = forge.util.createBuffer(message, "utf8"); var cipher = forge.cipher.createCipher(this.options.aesStandard, key); cipher.start({ iv: iv }); cipher.update(buffer); cipher.finish(); var payload = {}; payload.v = helpers.version(); payload.iv = forge.util.encode64(iv); payload.keys = encryptedKeys; payload.cipher = forge.util.encode64(cipher.output.data); payload.signature = signature; payload.tag = cipher.mode.tag && forge.util.encode64(cipher.mode.tag.getBytes()); return JSON.stringify(payload) } }, { key: "decrypt", value: function decrypt(privateKey, encrypted) { this._validate(encrypted); var payload = JSON.parse(encrypted); if (typeof privateKey === "string") privateKey = pki.privateKeyFromPem(privateKey); var fingerprint = this.fingerprint(privateKey); var encryptedKey = payload.keys[fingerprint]; if (!encryptedKey) throw "RSA fingerprint doesn't match with any of the encrypted message's fingerprints"; var keyBytes = forge.util.decode64(encryptedKey); var iv = forge.util.decode64(payload.iv); var cipher = forge.util.decode64(payload.cipher); var tag = payload.tag && forge.util.decode64(payload.tag); var key = privateKey.decrypt(keyBytes, this.options.rsaStandard); var buffer = forge.util.createBuffer(cipher); var decipher = forge.cipher.createDecipher(this.options.aesStandard, key); decipher.start({ iv: iv, tag: tag }); decipher.update(buffer); decipher.finish(); var bytes = decipher.output.getBytes(); var decrypted = forge.util.decodeUtf8(bytes); var output = {}; output.message = decrypted; output.signature = payload.signature; return output } }, { key: "_validate", value: function _validate(encrypted) { var p = JSON.parse(encrypted); if (!(p.hasOwnProperty("v") && p.hasOwnProperty("iv") && p.hasOwnProperty("keys") && p.hasOwnProperty("cipher"))) throw "Encrypted message is not valid" } }, { key: "_entropy", value: function _entropy(input) { var inputString = String(input); var bytes = forge.util.encodeUtf8(inputString); forge.random.collect(bytes) } }]); return Crypt }(); module.exports = Crypt }, { "./constants": 1, "./helpers": 3, "node-forge": 18 }], 3: [function (require, module, exports) { "use strict"; var pkg = require("../package.json"); module.exports = { version: function version() { return "".concat(pkg.name, "_").concat(pkg.version) }, toArray: function toArray(obj) { return Array.isArray(obj) ? obj : [obj] } } }, { "../package.json": 52 }], 4: [function (require, module, exports) { "use strict"; function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable }); keys.push.apply(keys, symbols) } return keys } function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]) }) } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)) }) } } return target } function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }) } else { obj[key] = value } return obj } function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function") } } function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor) } } function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor } var forge = require("node-forge"); var pki = forge.pki; var RSA = function () { function RSA() { var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}; _classCallCheck(this, RSA); this.options = _objectSpread({ keySize: 4096, entropy: undefined }, options); if (this.options.entropy) { this._entropy(this.options.entropy) } } _createClass(RSA, [{ key: "generateKeyPair", value: function generateKeyPair(callback, keySize) { pki.rsa.generateKeyPair({ bits: keySize || this.options.keySize, workers: -1 }, function (err, keyPair) { keyPair.publicKey = pki.publicKeyToPem(keyPair.publicKey); keyPair.privateKey = pki.privateKeyToPem(keyPair.privateKey); callback(keyPair) }) } }, { key: "generateKeyPairAsync", value: function generateKeyPairAsync(keySize) { var _this = this; return new Promise(function (resolve) { _this.generateKeyPair(resolve, keySize) }) } }, { key: "_entropy", value: function _entropy(input) { var inputString = String(input); var bytes = forge.util.encodeUtf8(inputString); forge.random.collect(bytes) } }]); return RSA }(); module.exports = RSA }, { "node-forge": 18 }], 5: [function (require, module, exports) { "use strict"; var _crypt = _interopRequireDefault(require("./crypt")); var _rsa = _interopRequireDefault(require("./rsa")); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj } } window.Crypt = _crypt.default; window.RSA = _rsa.default }, { "./crypt": 2, "./rsa": 4 }], 6: [function (require, module, exports) { }, {}], 7: [function (require, module, exports) { var forge = require("./forge"); require("./cipher"); require("./cipherModes"); require("./util"); module.exports = forge.aes = forge.aes || {}; forge.aes.startEncrypting = function (key, iv, output, mode) { var cipher = _createCipher({ key: key, output: output, decrypt: false, mode: mode }); cipher.start(iv); return cipher }; forge.aes.createEncryptionCipher = function (key, mode) { return _createCipher({ key: key, output: null, decrypt: false, mode: mode }) }; forge.aes.startDecrypting = function (key, iv, output, mode) { var cipher = _createCipher({ key: key, output: output, decrypt: true, mode: mode }); cipher.start(iv); return cipher }; forge.aes.createDecryptionCipher = function (key, mode) { return _createCipher({ key: key, output: null, decrypt: true, mode: mode }) }; forge.aes.Algorithm = function (name, mode) { if (!init) { initialize() } var self = this; self.name = name; self.mode = new mode({ blockSize: 16, cipher: { encrypt: function (inBlock, outBlock) { return _updateBlock(self._w, inBlock, outBlock, false) }, decrypt: function (inBlock, outBlock) { return _updateBlock(self._w, inBlock, outBlock, true) } } }); self._init = false }; forge.aes.Algorithm.prototype.initialize = function (options) { if (this._init) { return } var key = options.key; var tmp; if (typeof key === "string" && (key.length === 16 || key.length === 24 || key.length === 32)) { key = forge.util.createBuffer(key) } else if (forge.util.isArray(key) && (key.length === 16 || key.length === 24 || key.length === 32)) { tmp = key; key = forge.util.createBuffer(); for (var i = 0; i < tmp.length; ++i) { key.putByte(tmp[i]) } } if (!forge.util.isArray(key)) { tmp = key; key = []; var len = tmp.length(); if (len === 16 || len === 24 || len === 32) { len = len >>> 2; for (var i = 0; i < len; ++i) { key.push(tmp.getInt32()) } } } if (!forge.util.isArray(key) || !(key.length === 4 || key.length === 6 || key.length === 8)) { throw new Error("Invalid key parameter.") } var mode = this.mode.name; var encryptOp = ["CFB", "OFB", "CTR", "GCM"].indexOf(mode) !== -1; this._w = _expandKey(key, options.decrypt && !encryptOp); this._init = true }; forge.aes._expandKey = function (key, decrypt) { if (!init) { initialize() } return _expandKey(key, decrypt) }; forge.aes._updateBlock = _updateBlock; registerAlgorithm("AES-ECB", forge.cipher.modes.ecb); registerAlgorithm("AES-CBC", forge.cipher.modes.cbc); registerAlgorithm("AES-CFB", forge.cipher.modes.cfb); registerAlgorithm("AES-OFB", forge.cipher.modes.ofb); registerAlgorithm("AES-CTR", forge.cipher.modes.ctr); registerAlgorithm("AES-GCM", forge.cipher.modes.gcm); function registerAlgorithm(name, mode) { var factory = function () { return new forge.aes.Algorithm(name, mode) }; forge.cipher.registerAlgorithm(name, factory) } var init = false; var Nb = 4; var sbox; var isbox; var rcon; var mix; var imix; function initialize() { init = true; rcon = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54]; var xtime = new Array(256); for (var i = 0; i < 128; ++i) { xtime[i] = i << 1; xtime[i + 128] = i + 128 << 1 ^ 283 } sbox = new Array(256); isbox = new Array(256); mix = new Array(4); imix = new Array(4); for (var i = 0; i < 4; ++i) { mix[i] = new Array(256); imix[i] = new Array(256) } var e = 0, ei = 0, e2, e4, e8, sx, sx2, me, ime; for (var i = 0; i < 256; ++i) { sx = ei ^ ei << 1 ^ ei << 2 ^ ei << 3 ^ ei << 4; sx = sx >> 8 ^ sx & 255 ^ 99; sbox[e] = sx; isbox[sx] = e; sx2 = xtime[sx]; e2 = xtime[e]; e4 = xtime[e2]; e8 = xtime[e4]; me = sx2 << 24 ^ sx << 16 ^ sx << 8 ^ (sx ^ sx2); ime = (e2 ^ e4 ^ e8) << 24 ^ (e ^ e8) << 16 ^ (e ^ e4 ^ e8) << 8 ^ (e ^ e2 ^ e8); for (var n = 0; n < 4; ++n) { mix[n][e] = me; imix[n][sx] = ime; me = me << 24 | me >>> 8; ime = ime << 24 | ime >>> 8 } if (e === 0) { e = ei = 1 } else { e = e2 ^ xtime[xtime[xtime[e2 ^ e8]]]; ei ^= xtime[xtime[ei]] } } } function _expandKey(key, decrypt) { var w = key.slice(0); var temp, iNk = 1; var Nk = w.length; var Nr1 = Nk + 6 + 1; var end = Nb * Nr1; for (var i = Nk; i < end; ++i) { temp = w[i - 1]; if (i % Nk === 0) { temp = sbox[temp >>> 16 & 255] << 24 ^ sbox[temp >>> 8 & 255] << 16 ^ sbox[temp & 255] << 8 ^ sbox[temp >>> 24] ^ rcon[iNk] << 24; iNk++ } else if (Nk > 6 && i % Nk === 4) { temp = sbox[temp >>> 24] << 24 ^ sbox[temp >>> 16 & 255] << 16 ^ sbox[temp >>> 8 & 255] << 8 ^ sbox[temp & 255] } w[i] = w[i - Nk] ^ temp } if (decrypt) { var tmp; var m0 = imix[0]; var m1 = imix[1]; var m2 = imix[2]; var m3 = imix[3]; var wnew = w.slice(0); end = w.length; for (var i = 0, wi = end - Nb; i < end; i += Nb, wi -= Nb) { if (i === 0 || i === end - Nb) { wnew[i] = w[wi]; wnew[i + 1] = w[wi + 3]; wnew[i + 2] = w[wi + 2]; wnew[i + 3] = w[wi + 1] } else { for (var n = 0; n < Nb; ++n) { tmp = w[wi + n]; wnew[i + (3 & -n)] = m0[sbox[tmp >>> 24]] ^ m1[sbox[tmp >>> 16 & 255]] ^ m2[sbox[tmp >>> 8 & 255]] ^ m3[sbox[tmp & 255]] } } } w = wnew } return w } function _updateBlock(w, input, output, decrypt) { var Nr = w.length / 4 - 1; var m0, m1, m2, m3, sub; if (decrypt) { m0 = imix[0]; m1 = imix[1]; m2 = imix[2]; m3 = imix[3]; sub = isbox } else { m0 = mix[0]; m1 = mix[1]; m2 = mix[2]; m3 = mix[3]; sub = sbox } var a, b, c, d, a2, b2, c2; a = input[0] ^ w[0]; b = input[decrypt ? 3 : 1] ^ w[1]; c = input[2] ^ w[2]; d = input[decrypt ? 1 : 3] ^ w[3]; var i = 3; for (var round = 1; round < Nr; ++round) { a2 = m0[a >>> 24] ^ m1[b >>> 16 & 255] ^ m2[c >>> 8 & 255] ^ m3[d & 255] ^ w[++i]; b2 = m0[b >>> 24] ^ m1[c >>> 16 & 255] ^ m2[d >>> 8 & 255] ^ m3[a & 255] ^ w[++i]; c2 = m0[c >>> 24] ^ m1[d >>> 16 & 255] ^ m2[a >>> 8 & 255] ^ m3[b & 255] ^ w[++i]; d = m0[d >>> 24] ^ m1[a >>> 16 & 255] ^ m2[b >>> 8 & 255] ^ m3[c & 255] ^ w[++i]; a = a2; b = b2; c = c2 } output[0] = sub[a >>> 24] << 24 ^ sub[b >>> 16 & 255] << 16 ^ sub[c >>> 8 & 255] << 8 ^ sub[d & 255] ^ w[++i]; output[decrypt ? 3 : 1] = sub[b >>> 24] << 24 ^ sub[c >>> 16 & 255] << 16 ^ sub[d >>> 8 & 255] << 8 ^ sub[a & 255] ^ w[++i]; output[2] = sub[c >>> 24] << 24 ^ sub[d >>> 16 & 255] << 16 ^ sub[a >>> 8 & 255] << 8 ^ sub[b & 255] ^ w[++i]; output[decrypt ? 1 : 3] = sub[d >>> 24] << 24 ^ sub[a >>> 16 & 255] << 16 ^ sub[b >>> 8 & 255] << 8 ^ sub[c & 255] ^ w[++i] } function _createCipher(options) { options = options || {}; var mode = (options.mode || "CBC").toUpperCase(); var algorithm = "AES-" + mode; var cipher; if (options.decrypt) { cipher = forge.cipher.createDecipher(algorithm, options.key) } else { cipher = forge.cipher.createCipher(algorithm, options.key) } var start = cipher.start; cipher.start = function (iv, options) { var output = null; if (options instanceof forge.util.ByteBuffer) { output = options; options = {} } options = options || {}; options.output = output; options.iv = iv; start.call(cipher, options) }; return cipher } }, { "./cipher": 11, "./cipherModes": 12, "./forge": 16, "./util": 48 }], 8: [function (require, module, exports) { var forge = require("./forge"); require("./aes"); require("./tls"); var tls = module.exports = forge.tls; tls.CipherSuites["TLS_RSA_WITH_AES_128_CBC_SHA"] = { id: [0, 47], name: "TLS_RSA_WITH_AES_128_CBC_SHA", initSecurityParameters: function (sp) { sp.bulk_cipher_algorithm = tls.BulkCipherAlgorithm.aes; sp.cipher_type = tls.CipherType.block; sp.enc_key_length = 16; sp.block_length = 16; sp.fixed_iv_length = 16; sp.record_iv_length = 16; sp.mac_algorithm = tls.MACAlgorithm.hmac_sha1; sp.mac_length = 20; sp.mac_key_length = 20 }, initConnectionState: initConnectionState }; tls.CipherSuites["TLS_RSA_WITH_AES_256_CBC_SHA"] = { id: [0, 53], name: "TLS_RSA_WITH_AES_256_CBC_SHA", initSecurityParameters: function (sp) { sp.bulk_cipher_algorithm = tls.BulkCipherAlgorithm.aes; sp.cipher_type = tls.CipherType.block; sp.enc_key_length = 32; sp.block_length = 16; sp.fixed_iv_length = 16; sp.record_iv_length = 16; sp.mac_algorithm = tls.MACAlgorithm.hmac_sha1; sp.mac_length = 20; sp.mac_key_length = 20 }, initConnectionState: initConnectionState }; function initConnectionState(state, c, sp) { var client = c.entity === forge.tls.ConnectionEnd.client; state.read.cipherState = { init: false, cipher: forge.cipher.createDecipher("AES-CBC", client ? sp.keys.server_write_key : sp.keys.client_write_key), iv: client ? sp.keys.server_write_IV : sp.keys.client_write_IV }; state.write.cipherState = { init: false, cipher: forge.cipher.createCipher("AES-CBC", client ? sp.keys.client_write_key : sp.keys.server_write_key), iv: client ? sp.keys.client_write_IV : sp.keys.server_write_IV }; state.read.cipherFunction = decrypt_aes_cbc_sha1; state.write.cipherFunction = encrypt_aes_cbc_sha1; state.read.macLength = state.write.macLength = sp.mac_length; state.read.macFunction = state.write.macFunction = tls.hmac_sha1 } function encrypt_aes_cbc_sha1(record, s) { var rval = false; var mac = s.macFunction(s.macKey, s.sequenceNumber, record); record.fragment.putBytes(mac); s.updateSequenceNumber(); var iv; if (record.version.minor === tls.Versions.TLS_1_0.minor) { iv = s.cipherState.init ? null : s.cipherState.iv } else { iv = forge.random.getBytesSync(16) } s.cipherState.init = true; var cipher = s.cipherState.cipher; cipher.start({ iv: iv }); if (record.version.minor >= tls.Versions.TLS_1_1.minor) { cipher.output.putBytes(iv) } cipher.update(record.fragment); if (cipher.finish(encrypt_aes_cbc_sha1_padding)) { record.fragment = cipher.output; record.length = record.fragment.length(); rval = true } return rval } function encrypt_aes_cbc_sha1_padding(blockSize, input, decrypt) { if (!decrypt) { var padding = blockSize - input.length() % blockSize; input.fillWithByte(padding - 1, padding) } return true } function decrypt_aes_cbc_sha1_padding(blockSize, output, decrypt) { var rval = true; if (decrypt) { var len = output.length(); var paddingLength = output.last(); for (var i = len - 1 - paddingLength; i < len - 1; ++i) { rval = rval && output.at(i) == paddingLength } if (rval) { output.truncate(paddingLength + 1) } } return rval } function decrypt_aes_cbc_sha1(record, s) { var rval = false; var iv; if (record.version.minor === tls.Versions.TLS_1_0.minor) { iv = s.cipherState.init ? null : s.cipherState.iv } else { iv = record.fragment.getBytes(16) } s.cipherState.init = true; var cipher = s.cipherState.cipher; cipher.start({ iv: iv }); cipher.update(record.fragment); rval = cipher.finish(decrypt_aes_cbc_sha1_padding); var macLen = s.macLength; var mac = forge.random.getBytesSync(macLen); var len = cipher.output.length(); if (len >= macLen) { record.fragment = cipher.output.getBytes(len - macLen); mac = cipher.output.getBytes(macLen) } else { record.fragment = cipher.output.getBytes() } record.fragment = forge.util.createBuffer(record.fragment); record.length = record.fragment.length(); var mac2 = s.macFunction(s.macKey, s.sequenceNumber, record); s.updateSequenceNumber(); rval = compareMacs(s.macKey, mac, mac2) && rval; return rval } function compareMacs(key, mac1, mac2) { var hmac = forge.hmac.create(); hmac.start("SHA1", key); hmac.update(mac1); mac1 = hmac.digest().getBytes(); hmac.start(null, null); hmac.update(mac2); mac2 = hmac.digest().getBytes(); return mac1 === mac2 } }, { "./aes": 7, "./forge": 16, "./tls": 47 }], 9: [function (require, module, exports) { var forge = require("./forge"); require("./util"); require("./oids"); var asn1 = module.exports = forge.asn1 = forge.asn1 || {}; asn1.Class = { UNIVERSAL: 0, APPLICATION: 64, CONTEXT_SPECIFIC: 128, PRIVATE: 192 }; asn1.Type = { NONE: 0, BOOLEAN: 1, INTEGER: 2, BITSTRING: 3, OCTETSTRING: 4, NULL: 5, OID: 6, ODESC: 7, EXTERNAL: 8, REAL: 9, ENUMERATED: 10, EMBEDDED: 11, UTF8: 12, ROID: 13, SEQUENCE: 16, SET: 17, PRINTABLESTRING: 19, IA5STRING: 22, UTCTIME: 23, GENERALIZEDTIME: 24, BMPSTRING: 30 }; asn1.create = function (tagClass, type, constructed, value, options) { if (forge.util.isArray(value)) { var tmp = []; for (var i = 0; i < value.length; ++i) { if (value[i] !== undefined) { tmp.push(value[i]) } } value = tmp } var obj = { tagClass: tagClass, type: type, constructed: constructed, composed: constructed || forge.util.isArray(value), value: value }; if (options && "bitStringContents" in options) { obj.bitStringContents = options.bitStringContents; obj.original = asn1.copy(obj) } return obj }; asn1.copy = function (obj, options) { var copy; if (forge.util.isArray(obj)) { copy = []; for (var i = 0; i < obj.length; ++i) { copy.push(asn1.copy(obj[i], options)) } return copy } if (typeof obj === "string") { return obj } copy = { tagClass: obj.tagClass, type: obj.type, constructed: obj.constructed, composed: obj.composed, value: asn1.copy(obj.value, options) }; if (options && !options.excludeBitStringContents) { copy.bitStringContents = obj.bitStringContents } return copy }; asn1.equals = function (obj1, obj2, options) { if (forge.util.isArray(obj1)) { if (!forge.util.isArray(obj2)) { return false } if (obj1.length !== obj2.length) { return false } for (var i = 0; i < obj1.length; ++i) { if (!asn1.equals(obj1[i], obj2[i])) { return false } } return true } if (typeof obj1 !== typeof obj2) { return false } if (typeof obj1 === "string") { return obj1 === obj2 } var equal = obj1.tagClass === obj2.tagClass && obj1.type === obj2.type && obj1.constructed === obj2.constructed && obj1.composed === obj2.composed && asn1.equals(obj1.value, obj2.value); if (options && options.includeBitStringContents) { equal = equal && obj1.bitStringContents === obj2.bitStringContents } return equal }; asn1.getBerValueLength = function (b) { var b2 = b.getByte(); if (b2 === 128) { return undefined } var length; var longForm = b2 & 128; if (!longForm) { length = b2 } else { length = b.getInt((b2 & 127) << 3) } return length }; function _checkBufferLength(bytes, remaining, n) { if (n > remaining) { var error = new Error("Too few bytes to parse DER."); error.available = bytes.length(); error.remaining = remaining; error.requested = n; throw error } } var _getValueLength = function (bytes, remaining) { var b2 = bytes.getByte(); remaining--; if (b2 === 128) { return undefined } var length; var longForm = b2 & 128; if (!longForm) { length = b2 } else { var longFormBytes = b2 & 127; _checkBufferLength(bytes, remaining, longFormBytes); length = bytes.getInt(longFormBytes << 3) } if (length < 0) { throw new Error("Negative length: " + length) } return length }; asn1.fromDer = function (bytes, options) { if (options === undefined) { options = { strict: true, decodeBitStrings: true } } if (typeof options === "boolean") { options = { strict: options, decodeBitStrings: true } } if (!("strict" in options)) { options.strict = true } if (!("decodeBitStrings" in options)) { options.decodeBitStrings = true } if (typeof bytes === "string") { bytes = forge.util.createBuffer(bytes) } return _fromDer(bytes, bytes.length(), 0, options) }; function _fromDer(bytes, remaining, depth, options) { var start; _checkBufferLength(bytes, remaining, 2); var b1 = bytes.getByte(); remaining--; var tagClass = b1 & 192; var type = b1 & 31; start = bytes.length(); var length = _getValueLength(bytes, remaining); remaining -= start - bytes.length(); if (length !== undefined && length > remaining) { if (options.strict) { var error = new Error("Too few bytes to read ASN.1 value."); error.available = bytes.length(); error.remaining = remaining; error.requested = length; throw error } length = remaining } var value; var bitStringContents; var constructed = (b1 & 32) === 32; if (constructed) { value = []; if (length === undefined) { for (; ;) { _checkBufferLength(bytes, remaining, 2); if (bytes.bytes(2) === String.fromCharCode(0, 0)) { bytes.getBytes(2); remaining -= 2; break } start = bytes.length(); value.push(_fromDer(bytes, remaining, depth + 1, options)); remaining -= start - bytes.length() } } else { while (length > 0) { start = bytes.length(); value.push(_fromDer(bytes, length, depth + 1, options)); remaining -= start - bytes.length(); length -= start - bytes.length() } } } if (value === undefined && tagClass === asn1.Class.UNIVERSAL && type === asn1.Type.BITSTRING) { bitStringContents = bytes.bytes(length) } if (value === undefined && options.decodeBitStrings && tagClass === asn1.Class.UNIVERSAL && type === asn1.Type.BITSTRING && length > 1) { var savedRead = bytes.read; var savedRemaining = remaining; var unused = 0; if (type === asn1.Type.BITSTRING) { _checkBufferLength(bytes, remaining, 1); unused = bytes.getByte(); remaining-- } if (unused === 0) { try { start = bytes.length(); var subOptions = { verbose: options.verbose, strict: true, decodeBitStrings: true }; var composed = _fromDer(bytes, remaining, depth + 1, subOptions); var used = start - bytes.length(); remaining -= used; if (type == asn1.Type.BITSTRING) { used++ } var tc = composed.tagClass; if (used === length && (tc === asn1.Class.UNIVERSAL || tc === asn1.Class.CONTEXT_SPECIFIC)) { value = [composed] } } catch (ex) { } } if (value === undefined) { bytes.read = savedRead; remaining = savedRemaining } } if (value === undefined) { if (length === undefined) { if (options.strict) { throw new Error("Non-constructed ASN.1 object of indefinite length.") } length = remaining } if (type === asn1.Type.BMPSTRING) { value = ""; for (; length > 0; length -= 2) { _checkBufferLength(bytes, remaining, 2); value += String.fromCharCode(bytes.getInt16()); remaining -= 2 } } else { value = bytes.getBytes(length) } } var asn1Options = bitStringContents === undefined ? null : { bitStringContents: bitStringContents }; return asn1.create(tagClass, type, constructed, value, asn1Options) } asn1.toDer = function (obj) { var bytes = forge.util.createBuffer(); var b1 = obj.tagClass | obj.type; var value = forge.util.createBuffer(); var useBitStringContents = false; if ("bitStringContents" in obj) { useBitStringContents = true; if (obj.original) { useBitStringContents = asn1.equals(obj, obj.original) } } if (useBitStringContents) { value.putBytes(obj.bitStringContents) } else if (obj.composed) { if (obj.constructed) { b1 |= 32 } else { value.putByte(0) } for (var i = 0; i < obj.value.length; ++i) { if (obj.value[i] !== undefined) { value.putBuffer(asn1.toDer(obj.value[i])) } } } else { if (obj.type === asn1.Type.BMPSTRING) { for (var i = 0; i < obj.value.length; ++i) { value.putInt16(obj.value.charCodeAt(i)) } } else { if (obj.type === asn1.Type.INTEGER && obj.value.length > 1 && (obj.value.charCodeAt(0) === 0 && (obj.value.charCodeAt(1) & 128) === 0 || obj.value.charCodeAt(0) === 255 && (obj.value.charCodeAt(1) & 128) === 128)) { value.putBytes(obj.value.substr(1)) } else { value.putBytes(obj.value) } } } bytes.putByte(b1); if (value.length() <= 127) { bytes.putByte(value.length() & 127) } else { var len = value.length(); var lenBytes = ""; do { lenBytes += String.fromCharCode(len & 255); len = len >>> 8 } while (len > 0); bytes.putByte(lenBytes.length | 128); for (var i = lenBytes.length - 1; i >= 0; --i) { bytes.putByte(lenBytes.charCodeAt(i)) } } bytes.putBuffer(value); return bytes }; asn1.oidToDer = function (oid) { var values = oid.split("."); var bytes = forge.util.createBuffer(); bytes.putByte(40 * parseInt(values[0], 10) + parseInt(values[1], 10)); var last, valueBytes, value, b; for (var i = 2; i < values.length; ++i) { last = true; valueBytes = []; value = parseInt(values[i], 10); do { b = value & 127; value = value >>> 7; if (!last) { b |= 128 } valueBytes.push(b); last = false } while (value > 0); for (var n = valueBytes.length - 1; n >= 0; --n) { bytes.putByte(valueBytes[n]) } } return bytes }; asn1.derToOid = function (bytes) { var oid; if (typeof bytes === "string") { bytes = forge.util.createBuffer(bytes) } var b = bytes.getByte(); oid = Math.floor(b / 40) + "." + b % 40; var value = 0; while (bytes.length() > 0) { b = bytes.getByte(); value = value << 7; if (b & 128) { value += b & 127 } else { oid += "." + (value + b); value = 0 } } return oid }; asn1.utcTimeToDate = function (utc) { var date = new Date; var year = parseInt(utc.substr(0, 2), 10); year = year >= 50 ? 1900 + year : 2e3 + year; var MM = parseInt(utc.substr(2, 2), 10) - 1; var DD = parseInt(utc.substr(4, 2), 10); var hh = parseInt(utc.substr(6, 2), 10); var mm = parseInt(utc.substr(8, 2), 10); var ss = 0; if (utc.length > 11) { var c = utc.charAt(10); var end = 10; if (c !== "+" && c !== "-") { ss = parseInt(utc.substr(10, 2), 10); end += 2 } } date.setUTCFullYear(year, MM, DD); date.setUTCHours(hh, mm, ss, 0); if (end) { c = utc.charAt(end); if (c === "+" || c === "-") { var hhoffset = parseInt(utc.substr(end + 1, 2), 10); var mmoffset = parseInt(utc.substr(end + 4, 2), 10); var offset = hhoffset * 60 + mmoffset; offset *= 6e4; if (c === "+") { date.setTime(+date - offset) } else { date.setTime(+date + offset) } } } return date }; asn1.generalizedTimeToDate = function (gentime) { var date = new Date; var YYYY = parseInt(gentime.substr(0, 4), 10); var MM = parseInt(gentime.substr(4, 2), 10) - 1; var DD = parseInt(gentime.substr(6, 2), 10); var hh = parseInt(gentime.substr(8, 2), 10); var mm = parseInt(gentime.substr(10, 2), 10); var ss = parseInt(gentime.substr(12, 2), 10); var fff = 0; var offset = 0; var isUTC = false; if (gentime.charAt(gentime.length - 1) === "Z") { isUTC = true } var end = gentime.length - 5, c = gentime.charAt(end); if (c === "+" || c === "-") { var hhoffset = parseInt(gentime.substr(end + 1, 2), 10); var mmoffset = parseInt(gentime.substr(end + 4, 2), 10); offset = hhoffset * 60 + mmoffset; offset *= 6e4; if (c === "+") { offset *= -1 } isUTC = true } if (gentime.charAt(14) === ".") { fff = parseFloat(gentime.substr(14), 10) * 1e3 } if (isUTC) { date.setUTCFullYear(YYYY, MM, DD); date.setUTCHours(hh, mm, ss, fff); date.setTime(+date + offset) } else { date.setFullYear(YYYY, MM, DD); date.setHours(hh, mm, ss, fff) } return date }; asn1.dateToUtcTime = function (date) { if (typeof date === "string") { return date } var rval = ""; var format = []; format.push(("" + date.getUTCFullYear()).substr(2)); format.push("" + (date.getUTCMonth() + 1)); format.push("" + date.getUTCDate()); format.push("" + date.getUTCHours()); format.push("" + date.getUTCMinutes()); format.push("" + date.getUTCSeconds()); for (var i = 0; i < format.length; ++i) { if (format[i].length < 2) { rval += "0" } rval += format[i] } rval += "Z"; return rval }; asn1.dateToGeneralizedTime = function (date) { if (typeof date === "string") { return date } var rval = ""; var format = []; format.push("" + date.getUTCFullYear()); format.push("" + (date.getUTCMonth() + 1)); format.push("" + date.getUTCDate()); format.push("" + date.getUTCHours()); format.push("" + date.getUTCMinutes()); format.push("" + date.getUTCSeconds()); for (var i = 0; i < format.length; ++i) { if (format[i].length < 2) { rval += "0" } rval += format[i] } rval += "Z"; return rval }; asn1.integerToDer = function (x) { var rval = forge.util.createBuffer(); if (x >= -128 && x < 128) { return rval.putSignedInt(x, 8) } if (x >= -32768 && x < 32768) { return rval.putSignedInt(x, 16) } if (x >= -8388608 && x < 8388608) { return rval.putSignedInt(x, 24) } if (x >= -2147483648 && x < 2147483648) { return rval.putSignedInt(x, 32) } var error = new Error("Integer too large; max is 32-bits."); error.integer = x; throw error }; asn1.derToInteger = function (bytes) { if (typeof bytes === "string") { bytes = forge.util.createBuffer(bytes) } var n = bytes.length() * 8; if (n > 32) { throw new Error("Integer too large; max is 32-bits.") } return bytes.getSignedInt(n) }; asn1.validate = function (obj, v, capture, errors) { var rval = false; if ((obj.tagClass === v.tagClass || typeof v.tagClass === "undefined") && (obj.type === v.type || typeof v.type === "undefined")) { if (obj.constructed === v.constructed || typeof v.constructed === "undefined") { rval = true; if (v.value && forge.util.isArray(v.value)) { var j = 0; for (var i = 0; rval && i < v.value.length; ++i) { rval = v.value[i].optional || false; if (obj.value[j]) { rval = asn1.validate(obj.value[j], v.value[i], capture, errors); if (rval) { ++j } else if (v.value[i].optional) { rval = true } } if (!rval && errors) { errors.push("[" + v.name + "] " + 'Tag class "' + v.tagClass + '", type "' + v.type + '" expected value length "' + v.value.length + '", got "' + obj.value.length + '"') } } } if (rval && capture) { if (v.capture) { capture[v.capture] = obj.value } if (v.captureAsn1) { capture[v.captureAsn1] = obj } if (v.captureBitStringContents && "bitStringContents" in obj) { capture[v.captureBitStringContents] = obj.bitStringContents } if (v.captureBitStringValue && "bitStringContents" in obj) { var value; if (obj.bitStringContents.length < 2) { capture[v.captureBitStringValue] = "" } else { var unused = obj.bitStringContents.charCodeAt(0); if (unused !== 0) { throw new Error("captureBitStringValue only supported for zero unused bits") } capture[v.captureBitStringValue] = obj.bitStringContents.slice(1) } } } } else if (errors) { errors.push("[" + v.name + "] " + 'Expected constructed "' + v.constructed + '", got "' + obj.constructed + '"') } } else if (errors) { if (obj.tagClass !== v.tagClass) { errors.push("[" + v.name + "] " + 'Expected tag class "' + v.tagClass + '", got "' + obj.tagClass + '"') } if (obj.type !== v.type) { errors.push("[" + v.name + "] " + 'Expected type "' + v.type + '", got "' + obj.type + '"') } } return rval }; var _nonLatinRegex = /[^\\u0000-\\u00ff]/; asn1.prettyPrint = function (obj, level, indentation) { var rval = ""; level = level || 0; indentation = indentation || 2; if (level > 0) { rval += "\n" } var indent = ""; for (var i = 0; i < level * indentation; ++i) { indent += " " } rval += indent + "Tag: "; switch (obj.tagClass) { case asn1.Class.UNIVERSAL: rval += "Universal:"; break; case asn1.Class.APPLICATION: rval += "Application:"; break; case asn1.Class.CONTEXT_SPECIFIC: rval += "Context-Specific:"; break; case asn1.Class.PRIVATE: rval += "Private:"; break }if (obj.tagClass === asn1.Class.UNIVERSAL) { rval += obj.type; switch (obj.type) { case asn1.Type.NONE: rval += " (None)"; break; case asn1.Type.BOOLEAN: rval += " (Boolean)"; break; case asn1.Type.INTEGER: rval += " (Integer)"; break; case asn1.Type.BITSTRING: rval += " (Bit string)"; break; case asn1.Type.OCTETSTRING: rval += " (Octet string)"; break; case asn1.Type.NULL: rval += " (Null)"; break; case asn1.Type.OID: rval += " (Object Identifier)"; break; case asn1.Type.ODESC: rval += " (Object Descriptor)"; break; case asn1.Type.EXTERNAL: rval += " (External or Instance of)"; break; case asn1.Type.REAL: rval += " (Real)"; break; case asn1.Type.ENUMERATED: rval += " (Enumerated)"; break; case asn1.Type.EMBEDDED: rval += " (Embedded PDV)"; break; case asn1.Type.UTF8: rval += " (UTF8)"; break; case asn1.Type.ROID: rval += " (Relative Object Identifier)"; break; case asn1.Type.SEQUENCE: rval += " (Sequence)"; break; case asn1.Type.SET: rval += " (Set)"; break; case asn1.Type.PRINTABLESTRING: rval += " (Printable String)"; break; case asn1.Type.IA5String: rval += " (IA5String (ASCII))"; break; case asn1.Type.UTCTIME: rval += " (UTC time)"; break; case asn1.Type.GENERALIZEDTIME: rval += " (Generalized time)"; break; case asn1.Type.BMPSTRING: rval += " (BMP String)"; break } } else { rval += obj.type } rval += "\n"; rval += indent + "Constructed: " + obj.constructed + "\n"; if (obj.composed) { var subvalues = 0; var sub = ""; for (var i = 0; i < obj.value.length; ++i) { if (obj.value[i] !== undefined) { subvalues += 1; sub += asn1.prettyPrint(obj.value[i], level + 1, indentation); if (i + 1 < obj.value.length) { sub += "," } } } rval += indent + "Sub values: " + subvalues + sub } else { rval += indent + "Value: "; if (obj.type === asn1.Type.OID) { var oid = asn1.derToOid(obj.value); rval += oid; if (forge.pki && forge.pki.oids) { if (oid in forge.pki.oids) { rval += " (" + forge.pki.oids[oid] + ") " } } } if (obj.type === asn1.Type.INTEGER) { try { rval += asn1.derToInteger(obj.value) } catch (ex) { rval += "0x" + forge.util.bytesToHex(obj.value) } } else if (obj.type === asn1.Type.BITSTRING) { if (obj.value.length > 1) { rval += "0x" + forge.util.bytesToHex(obj.value.slice(1)) } else { rval += "(none)" } if (obj.value.length > 0) { var unused = obj.value.charCodeAt(0); if (unused == 1) { rval += " (1 unused bit shown)" } else if (unused > 1) { rval += " (" + unused + " unused bits shown)" } } } else if (obj.type === asn1.Type.OCTETSTRING) { if (!_nonLatinRegex.test(obj.value)) { rval += "(" + obj.value + ") " } rval += "0x" + forge.util.bytesToHex(obj.value) } else if (obj.type === asn1.Type.UTF8) { rval += forge.util.decodeUtf8(obj.value) } else if (obj.type === asn1.Type.PRINTABLESTRING || obj.type === asn1.Type.IA5String) { rval += obj.value } else if (_nonLatinRegex.test(obj.value)) { rval += "0x" + forge.util.bytesToHex(obj.value) } else if (obj.value.length === 0) { rval += "[null]" } else { rval += obj.value } } return rval } }, { "./forge": 16, "./oids": 27, "./util": 48 }], 10: [function (require, module, exports) { (function (Buffer) { var api = {}; module.exports = api; var _reverseAlphabets = {}; api.encode = function (input, alphabet, maxline) { if (typeof alphabet !== "string") { throw new TypeError('"alphabet" must be a string.') } if (maxline !== undefined && typeof maxline !== "number") { throw new TypeError('"maxline" must be a number.') } var output = ""; if (!(input instanceof Uint8Array)) { output = _encodeWithByteBuffer(input, alphabet) } else { var i = 0; var base = alphabet.length; var first = alphabet.charAt(0); var digits = [0]; for (i = 0; i < input.length; ++i) { for (var j = 0, carry = input[i]; j < digits.length; ++j) { carry += digits[j] << 8; digits[j] = carry % base; carry = carry / base | 0 } while (carry > 0) { digits.push(carry % base); carry = carry / base | 0 } } for (i = 0; input[i] === 0 && i < input.length - 1; ++i) { output += first } for (i = digits.length - 1; i >= 0; --i) { output += alphabet[digits[i]] } } if (maxline) { var regex = new RegExp(".{1," + maxline + "}", "g"); output = output.match(regex).join("\r\n") } return output }; api.decode = function (input, alphabet) { if (typeof input !== "string") { throw new TypeError('"input" must be a string.') } if (typeof alphabet !== "string") { throw new TypeError('"alphabet" must be a string.') } var table = _reverseAlphabets[alphabet]; if (!table) { table = _reverseAlphabets[alphabet] = []; for (var i = 0; i < alphabet.length; ++i) { table[alphabet.charCodeAt(i)] = i } } input = input.replace(/\s/g, ""); var base = alphabet.length; var first = alphabet.charAt(0); var bytes = [0]; for (var i = 0; i < input.length; i++) { var value = table[input.charCodeAt(i)]; if (value === undefined) { return } for (var j = 0, carry = value; j < bytes.length; ++j) { carry += bytes[j] * base; bytes[j] = carry & 255; carry >>= 8 } while (carry > 0) { bytes.push(carry & 255); carry >>= 8 } } for (var k = 0; input[k] === first && k < input.length - 1; ++k) { bytes.push(0) } if (typeof Buffer !== "undefined") { return Buffer.from(bytes.reverse()) } return new Uint8Array(bytes.reverse()) }; function _encodeWithByteBuffer(input, alphabet) { var i = 0; var base = alphabet.length; var first = alphabet.charAt(0); var digits = [0]; for (i = 0; i < input.length(); ++i) { for (var j = 0, carry = input.at(i); j < digits.length; ++j) { carry += digits[j] << 8; digits[j] = carry % base; carry = carry / base | 0 } while (carry > 0) { digits.push(carry % base); carry = carry / base | 0 } } var output = ""; for (i = 0; input.at(i) === 0 && i < input.length() - 1; ++i) { output += first } for (i = digits.length - 1; i >= 0; --i) { output += alphabet[digits[i]] } return output } }).call(this, require("buffer").Buffer) }, { buffer: 6 }], 11: [function (require, module, exports) { var forge = require("./forge"); require("./util"); module.exports = forge.cipher = forge.cipher || {}; forge.cipher.algorithms = forge.cipher.algorithms || {}; forge.cipher.createCipher = function (algorithm, key) { var api = algorithm; if (typeof api === "string") { api = forge.cipher.getAlgorithm(api); if (api) { api = api() } } if (!api) { throw new Error("Unsupported algorithm: " + algorithm) } return new forge.cipher.BlockCipher({ algorithm: api, key: key, decrypt: false }) }; forge.cipher.createDecipher = function (algorithm, key) { var api = algorithm; if (typeof api === "string") { api = forge.cipher.getAlgorithm(api); if (api) { api = api() } } if (!api) { throw new Error("Unsupported algorithm: " + algorithm) } return new forge.cipher.BlockCipher({ algorithm: api, key: key, decrypt: true }) }; forge.cipher.registerAlgorithm = function (name, algorithm) { name = name.toUpperCase(); forge.cipher.algorithms[name] = algorithm }; forge.cipher.getAlgorithm = function (name) { name = name.toUpperCase(); if (name in forge.cipher.algorithms) { return forge.cipher.algorithms[name] } return null }; var BlockCipher = forge.cipher.BlockCipher = function (options) { this.algorithm = options.algorithm; this.mode = this.algorithm.mode; this.blockSize = this.mode.blockSize; this._finish = false; this._input = null; this.output = null; this._op = options.decrypt ? this.mode.decrypt : this.mode.encrypt; this._decrypt = options.decrypt; this.algorithm.initialize(options) }; BlockCipher.prototype.start = function (options) { options = options || {}; var opts = {}; for (var key in options) { opts[key] = options[key] } opts.decrypt = this._decrypt; this._finish = false; this._input = forge.util.createBuffer(); this.output = options.output || forge.util.createBuffer(); this.mode.start(opts) }; BlockCipher.prototype.update = function (input) { if (input) { this._input.putBuffer(input) } while (!this._op.call(this.mode, this._input, this.output, this._finish) && !this._finish) { } this._input.compact() }; BlockCipher.prototype.finish = function (pad) { if (pad && (this.mode.name === "ECB" || this.mode.name === "CBC")) { this.mode.pad = function (input) { return pad(this.blockSize, input, false) }; this.mode.unpad = function (output) { return pad(this.blockSize, output, true) } } var options = {}; options.decrypt = this._decrypt; options.overflow = this._input.length() % this.blockSize; if (!this._decrypt && this.mode.pad) { if (!this.mode.pad(this._input, options)) { return false } } this._finish = true; this.update(); if (this._decrypt && this.mode.unpad) { if (!this.mode.unpad(this.output, options)) { return false } } if (this.mode.afterFinish) { if (!this.mode.afterFinish(this.output, options)) { return false } } return true } }, { "./forge": 16, "./util": 48 }], 12: [function (require, module, exports) { var forge = require("./forge"); require("./util"); forge.cipher = forge.cipher || {}; var modes = module.exports = forge.cipher.modes = forge.cipher.modes || {}; modes.ecb = function (options) { options = options || {}; this.name = "ECB"; this.cipher = options.cipher; this.blockSize = options.blockSize || 16; this._ints = this.blockSize / 4; this._inBlock = new Array(this._ints); this._outBlock = new Array(this._ints) }; modes.ecb.prototype.start = function (options) { }; modes.ecb.prototype.encrypt = function (input, output, finish) { if (input.length() < this.blockSize && !(finish && input.length() > 0)) { return true } for (var i = 0; i < this._ints; ++i) { this._inBlock[i] = input.getInt32() } this.cipher.encrypt(this._inBlock, this._outBlock); for (var i = 0; i < this._ints; ++i) { output.putInt32(this._outBlock[i]) } }; modes.ecb.prototype.decrypt = function (input, output, finish) { if (input.length() < this.blockSize && !(finish && input.length() > 0)) { return true } for (var i = 0; i < this._ints; ++i) { this._inBlock[i] = input.getInt32() } this.cipher.decrypt(this._inBlock, this._outBlock); for (var i = 0; i < this._ints; ++i) { output.putInt32(this._outBlock[i]) } }; modes.ecb.prototype.pad = function (input, options) { var padding = input.length() === this.blockSize ? this.blockSize : this.blockSize - input.length(); input.fillWithByte(padding, padding); return true }; modes.ecb.prototype.unpad = function (output, options) { if (options.overflow > 0) { return false } var len = output.length(); var count = output.at(len - 1); if (count > this.blockSize << 2) { return false } output.truncate(count); return true }; modes.cbc = function (options) { options = options || {}; this.name = "CBC"; this.cipher = options.cipher; this.blockSize = options.blockSize || 16; this._ints = this.blockSize / 4; this._inBlock = new Array(this._ints); this._outBlock = new Array(this._ints) }; modes.cbc.prototype.start = function (options) { if (options.iv === null) { if (!this._prev) { throw new Error("Invalid IV parameter.") } this._iv = this._prev.slice(0) } else if (!("iv" in options)) { throw new Error("Invalid IV parameter.") } else { this._iv = transformIV(options.iv); this._prev = this._iv.slice(0) } }; modes.cbc.prototype.encrypt = function (input, output, finish) { if (input.length() < this.blockSize && !(finish && input.length() > 0)) { return true } for (var i = 0; i < this._ints; ++i) { this._inBlock[i] = this._prev[i] ^ input.getInt32() } this.cipher.encrypt(this._inBlock, this._outBlock); for (var i = 0; i < this._ints; ++i) { output.putInt32(this._outBlock[i]) } this._prev = this._outBlock }; modes.cbc.prototype.decrypt = function (input, output, finish) { if (input.length() < this.blockSize && !(finish && input.length() > 0)) { return true } for (var i = 0; i < this._ints; ++i) { this._inBlock[i] = input.getInt32() } this.cipher.decrypt(this._inBlock, this._outBlock); for (var i = 0; i < this._ints; ++i) { output.putInt32(this._prev[i] ^ this._outBlock[i]) } this._prev = this._inBlock.slice(0) }; modes.cbc.prototype.pad = function (input, options) { var padding = input.length() === this.blockSize ? this.blockSize : this.blockSize - input.length(); input.fillWithByte(padding, padding); return true }; modes.cbc.prototype.unpad = function (output, options) { if (options.overflow > 0) { return false } var len = output.length(); var count = output.at(len - 1); if (count > this.blockSize << 2) { return false } output.truncate(count); return true }; modes.cfb = function (options) { options = options || {}; this.name = "CFB"; this.cipher = options.cipher; this.blockSize = options.blockSize || 16; this._ints = this.blockSize / 4; this._inBlock = null; this._outBlock = new Array(this._ints); this._partialBlock = new Array(this._ints); this._partialOutput = forge.util.createBuffer(); this._partialBytes = 0 }; modes.cfb.prototype.start = function (options) { if (!("iv" in options)) { throw new Error("Invalid IV parameter.") } this._iv = transformIV(options.iv); this._inBlock = this._iv.slice(0); this._partialBytes = 0 }; modes.cfb.prototype.encrypt = function (input, output, finish) { var inputLength = input.length(); if (inputLength === 0) { return true } this.cipher.encrypt(this._inBlock, this._outBlock); if (this._partialBytes === 0 && inputLength >= this.blockSize) { for (var i = 0; i < this._ints; ++i) { this._inBlock[i] = input.getInt32() ^ this._outBlock[i]; output.putInt32(this._inBlock[i]) } return } var partialBytes = (this.blockSize - inputLength) % this.blockSize; if (partialBytes > 0) { partialBytes = this.blockSize - partialBytes } this._partialOutput.clear(); for (var i = 0; i < this._ints; ++i) { this._partialBlock[i] = input.getInt32() ^ this._outBlock[i]; this._partialOutput.putInt32(this._partialBlock[i]) } if (partialBytes > 0) { input.read -= this.blockSize } else { for (var i = 0; i < this._ints; ++i) { this._inBlock[i] = this._partialBlock[i] } } if (this._partialBytes > 0) { this._partialOutput.getBytes(this._partialBytes) } if (partialBytes > 0 && !finish) { output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes)); this._partialBytes = partialBytes; return true } output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes)); this._partialBytes = 0 }; modes.cfb.prototype.decrypt = function (input, output, finish) { var inputLength = input.length(); if (inputLength === 0) { return true } this.cipher.encrypt(this._inBlock, this._outBlock); if (this._partialBytes === 0 && inputLength >= this.blockSize) { for (var i = 0; i < this._ints; ++i) { this._inBlock[i] = input.getInt32(); output.putInt32(this._inBlock[i] ^ this._outBlock[i]) } return } var partialBytes = (this.blockSize - inputLength) % this.blockSize; if (partialBytes > 0) { partialBytes = this.blockSize - partialBytes } this._partialOutput.clear(); for (var i = 0; i < this._ints; ++i) { this._partialBlock[i] = input.getInt32(); this._partialOutput.putInt32(this._partialBlock[i] ^ this._outBlock[i]) } if (partialBytes > 0) { input.read -= this.blockSize } else { for (var i = 0; i < this._ints; ++i) { this._inBlock[i] = this._partialBlock[i] } } if (this._partialBytes > 0) { this._partialOutput.getBytes(this._partialBytes) } if (partialBytes > 0 && !finish) { output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes)); this._partialBytes = partialBytes; return true } output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes)); this._partialBytes = 0 }; modes.ofb = function (options) { options = options || {}; this.name = "OFB"; this.cipher = options.cipher; this.blockSize = options.blockSize || 16; this._ints = this.blockSize / 4; this._inBlock = null; this._outBlock = new Array(this._ints); this._partialOutput = forge.util.createBuffer(); this._partialBytes = 0 }; modes.ofb.prototype.start = function (options) { if (!("iv" in options)) { throw new Error("Invalid IV parameter.") } this._iv = transformIV(options.iv); this._inBlock = this._iv.slice(0); this._partialBytes = 0 }; modes.ofb.prototype.encrypt = function (input, output, finish) { var inputLength = input.length(); if (input.length() === 0) { return true } this.cipher.encrypt(this._inBlock, this._outBlock); if (this._partialBytes === 0 && inputLength >= this.blockSize) { for (var i = 0; i < this._ints; ++i) { output.putInt32(input.getInt32() ^ this._outBlock[i]); this._inBlock[i] = this._outBlock[i] } return } var partialBytes = (this.blockSize - inputLength) % this.blockSize; if (partialBytes > 0) { partialBytes = this.blockSize - partialBytes } this._partialOutput.clear(); for (var i = 0; i < this._ints; ++i) { this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]) } if (partialBytes > 0) { input.read -= this.blockSize } else { for (var i = 0; i < this._ints; ++i) { this._inBlock[i] = this._outBlock[i] } } if (this._partialBytes > 0) { this._partialOutput.getBytes(this._partialBytes) } if (partialBytes > 0 && !finish) { output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes)); this._partialBytes = partialBytes; return true } output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes)); this._partialBytes = 0 }; modes.ofb.prototype.decrypt = modes.ofb.prototype.encrypt; modes.ctr = function (options) { options = options || {}; this.name = "CTR"; this.cipher = options.cipher; this.blockSize = options.blockSize || 16; this._ints = this.blockSize / 4; this._inBlock = null; this._outBlock = new Array(this._ints); this._partialOutput = forge.util.createBuffer(); this._partialBytes = 0 }; modes.ctr.prototype.start = function (options) { if (!("iv" in options)) { throw new Error("Invalid IV parameter.") } this._iv = transformIV(options.iv); this._inBlock = this._iv.slice(0); this._partialBytes = 0 }; modes.ctr.prototype.encrypt = function (input, output, finish) { var inputLength = input.length(); if (inputLength === 0) { return true } this.cipher.encrypt(this._inBlock, this._outBlock); if (this._partialBytes === 0 && inputLength >= this.blockSize) { for (var i = 0; i < this._ints; ++i) { output.putInt32(input.getInt32() ^ this._outBlock[i]) } } else { var partialBytes = (this.blockSize - inputLength) % this.blockSize; if (partialBytes > 0) { partialBytes = this.blockSize - partialBytes } this._partialOutput.clear(); for (var i = 0; i < this._ints; ++i) { this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]) } if (partialBytes > 0) { input.read -= this.blockSize } if (this._partialBytes > 0) { this._partialOutput.getBytes(this._partialBytes) } if (partialBytes > 0 && !finish) { output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes)); this._partialBytes = partialBytes; return true } output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes)); this._partialBytes = 0 } inc32(this._inBlock) }; modes.ctr.prototype.decrypt = modes.ctr.prototype.encrypt; modes.gcm = function (options) { options = options || {}; this.name = "GCM"; this.cipher = options.cipher; this.blockSize = options.blockSize || 16; this._ints = this.blockSize / 4; this._inBlock = new Array(this._ints); this._outBlock = new Array(this._ints); this._partialOutput = forge.util.createBuffer(); this._partialBytes = 0; this._R = 3774873600 }; modes.gcm.prototype.start = function (options) { if (!("iv" in options)) { throw new Error("Invalid IV parameter.") } var iv = forge.util.createBuffer(options.iv); this._cipherLength = 0; var additionalData; if ("additionalData" in options) { additionalData = forge.util.createBuffer(options.additionalData) } else { additionalData = forge.util.createBuffer() } if ("tagLength" in options) { this._tagLength = options.tagLength } else { this._tagLength = 128 } this._tag = null; if (options.decrypt) { this._tag = forge.util.createBuffer(options.tag).getBytes(); if (this._tag.length !== this._tagLength / 8) { throw new Error("Authentication tag does not match tag length.") } } this._hashBlock = new Array(this._ints); this.tag = null; this._hashSubkey = new Array(this._ints); this.cipher.encrypt([0, 0, 0, 0], this._hashSubkey); this.componentBits = 4; this._m = this.generateHashTable(this._hashSubkey, this.componentBits); var ivLength = iv.length(); if (ivLength === 12) { this._j0 = [iv.getInt32(), iv.getInt32(), iv.getInt32(), 1] } else { this._j0 = [0, 0, 0, 0]; while (iv.length() > 0) { this._j0 = this.ghash(this._hashSubkey, this._j0, [iv.getInt32(), iv.getInt32(), iv.getInt32(), iv.getInt32()]) } this._j0 = this.ghash(this._hashSubkey, this._j0, [0, 0].concat(from64To32(ivLength * 8))) } this._inBlock = this._j0.slice(0); inc32(this._inBlock); this._partialBytes = 0; additionalData = forge.util.createBuffer(additionalData); this._aDataLength = from64To32(additionalData.length() * 8); var overflow = additionalData.length() % this.blockSize; if (overflow) { additionalData.fillWithByte(0, this.blockSize - overflow) } this._s = [0, 0, 0, 0]; while (additionalData.length() > 0) { this._s = this.ghash(this._hashSubkey, this._s, [additionalData.getInt32(), additionalData.getInt32(), additionalData.getInt32(), additionalData.getInt32()]) } }; modes.gcm.prototype.encrypt = function (input, output, finish) { var inputLength = input.length(); if (inputLength === 0) { return true } this.cipher.encrypt(this._inBlock, this._outBlock); if (this._partialBytes === 0 && inputLength >= this.blockSize) { for (var i = 0; i < this._ints; ++i) { output.putInt32(this._outBlock[i] ^= input.getInt32()) } this._cipherLength += this.blockSize } else { var partialBytes = (this.blockSize - inputLength) % this.blockSize; if (partialBytes > 0) { partialBytes = this.blockSize - partialBytes } this._partialOutput.clear(); for (var i = 0; i < this._ints; ++i) { this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]) } if (partialBytes <= 0 || finish) { if (finish) { var overflow = inputLength % this.blockSize; this._cipherLength += overflow; this._partialOutput.truncate(this.blockSize - overflow) } else { this._cipherLength += this.blockSize } for (var i = 0; i < this._ints; ++i) { this._outBlock[i] = this._partialOutput.getInt32() } this._partialOutput.read -= this.blockSize } if (this._partialBytes > 0) { this._partialOutput.getBytes(this._partialBytes) } if (partialBytes > 0 && !finish) { input.read -= this.blockSize; output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes)); this._partialBytes = partialBytes; return true } output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes)); this._partialBytes = 0 } this._s = this.ghash(this._hashSubkey, this._s, this._outBlock); inc32(this._inBlock) }; modes.gcm.prototype.decrypt = function (input, output, finish) { var inputLength = input.length(); if (inputLength < this.blockSize && !(finish && inputLength > 0)) { return true } this.cipher.encrypt(this._inBlock, this._outBlock); inc32(this._inBlock); this._hashBlock[0] = input.getInt32(); this._hashBlock[1] = input.getInt32(); this._hashBlock[2] = input.getInt32(); this._hashBlock[3] = input.getInt32(); this._s = this.ghash(this._hashSubkey, this._s, this._hashBlock); for (var i = 0; i < this._ints; ++i) { output.putInt32(this._outBlock[i] ^ this._hashBlock[i]) } if (inputLength < this.blockSize) { this._cipherLength += inputLength % this.blockSize } else { this._cipherLength += this.blockSize } }; modes.gcm.prototype.afterFinish = function (output, options) { var rval = true; if (options.decrypt && options.overflow) { output.truncate(this.blockSize - options.overflow) } this.tag = forge.util.createBuffer(); var lengths = this._aDataLength.concat(from64To32(this._cipherLength * 8)); this._s = this.ghash(this._hashSubkey, this._s, lengths); var tag = []; this.cipher.encrypt(this._j0, tag); for (var i = 0; i < this._ints; ++i) { this.tag.putInt32(this._s[i] ^ tag[i]) } this.tag.truncate(this.tag.length() % (this._tagLength / 8)); if (options.decrypt && this.tag.bytes() !== this._tag) { rval = false } return rval }; modes.gcm.prototype.multiply = function (x, y) { var z_i = [0, 0, 0, 0]; var v_i = y.slice(0); for (var i = 0; i < 128; ++i) { var x_i = x[i / 32 | 0] & 1 << 31 - i % 32; if (x_i) { z_i[0] ^= v_i[0]; z_i[1] ^= v_i[1]; z_i[2] ^= v_i[2]; z_i[3] ^= v_i[3] } this.pow(v_i, v_i) } return z_i }; modes.gcm.prototype.pow = function (x, out) { var lsb = x[3] & 1; for (var i = 3; i > 0; --i) { out[i] = x[i] >>> 1 | (x[i - 1] & 1) << 31 } out[0] = x[0] >>> 1; if (lsb) { out[0] ^= this._R } }; modes.gcm.prototype.tableMultiply = function (x) { var z = [0, 0, 0, 0]; for (var i = 0; i < 32; ++i) { var idx = i / 8 | 0; var x_i = x[idx] >>> (7 - i % 8) * 4 & 15; var ah = this._m[i][x_i]; z[0] ^= ah[0]; z[1] ^= ah[1]; z[2] ^= ah[2]; z[3] ^= ah[3] } return z }; modes.gcm.prototype.ghash = function (h, y, x) { y[0] ^= x[0]; y[1] ^= x[1]; y[2] ^= x[2]; y[3] ^= x[3]; return this.tableMultiply(y) }; modes.gcm.prototype.generateHashTable = function (h, bits) { var multiplier = 8 / bits; var perInt = 4 * multiplier; var size = 16 * multiplier; var m = new Array(size); for (var i = 0; i < size; ++i) { var tmp = [0, 0, 0, 0]; var idx = i / perInt | 0; var shft = (perInt - 1 - i % perInt) * bits; tmp[idx] = 1 << bits - 1 << shft; m[i] = this.generateSubHashTable(this.multiply(tmp, h), bits) } return m }; modes.gcm.prototype.generateSubHashTable = function (mid, bits) { var size = 1 << bits; var half = size >>> 1; var m = new Array(size); m[half] = mid.slice(0); var i = half >>> 1; while (i > 0) { this.pow(m[2 * i], m[i] = []); i >>= 1 } i = 2; while (i < half) { for (var j = 1; j < i; ++j) { var m_i = m[i]; var m_j = m[j]; m[i + j] = [m_i[0] ^ m_j[0], m_i[1] ^ m_j[1], m_i[2] ^ m_j[2], m_i[3] ^ m_j[3]] } i *= 2 } m[0] = [0, 0, 0, 0]; for (i = half + 1; i < size; ++i) { var c = m[i ^ half]; m[i] = [mid[0] ^ c[0], mid[1] ^ c[1], mid[2] ^ c[2], mid[3] ^ c[3]] } return m }; function transformIV(iv) { if (typeof iv === "string") { iv = forge.util.createBuffer(iv) } if (forge.util.isArray(iv) && iv.length > 4) { var tmp = iv; iv = forge.util.createBuffer(); for (var i = 0; i < tmp.length; ++i) { iv.putByte(tmp[i]) } } if (!forge.util.isArray(iv)) { iv = [iv.getInt32(), iv.getInt32(), iv.getInt32(), iv.getInt32()] } return iv } function inc32(block) { block[block.length - 1] = block[block.length - 1] + 1 & 4294967295 } function from64To32(num) { return [num / 4294967296 | 0, num & 4294967295] } }, { "./forge": 16, "./util": 48 }], 13: [function (require, module, exports) { var forge = require("./forge"); module.exports = forge.debug = forge.debug || {}; forge.debug.storage = {}; forge.debug.get = function (cat, name) { var rval; if (typeof cat === "undefined") { rval = forge.debug.storage } else if (cat in forge.debug.storage) { if (typeof name === "undefined") { rval = forge.debug.storage[cat] } else { rval = forge.debug.storage[cat][name] } } return rval }; forge.debug.set = function (cat, name, data) { if (!(cat in forge.debug.storage)) { forge.debug.storage[cat] = {} } forge.debug.storage[cat][name] = data }; forge.debug.clear = function (cat, name) { if (typeof cat === "undefined") { forge.debug.storage = {} } else if (cat in forge.debug.storage) { if (typeof name === "undefined") { delete forge.debug.storage[cat] } else { delete forge.debug.storage[cat][name] } } } }, { "./forge": 16 }], 14: [function (require, module, exports) { var forge = require("./forge"); require("./cipher"); require("./cipherModes"); require("./util"); module.exports = forge.des = forge.des || {}; forge.des.startEncrypting = function (key, iv, output, mode) { var cipher = _createCipher({ key: key, output: output, decrypt: false, mode: mode || (iv === null ? "ECB" : "CBC") }); cipher.start(iv); return cipher }; forge.des.createEncryptionCipher = function (key, mode) { return _createCipher({ key: key, output: null, decrypt: false, mode: mode }) }; forge.des.startDecrypting = function (key, iv, output, mode) { var cipher = _createCipher({ key: key, output: output, decrypt: true, mode: mode || (iv === null ? "ECB" : "CBC") }); cipher.start(iv); return cipher }; forge.des.createDecryptionCipher = function (key, mode) { return _createCipher({ key: key, output: null, decrypt: true, mode: mode }) }; forge.des.Algorithm = function (name, mode) { var self = this; self.name = name; self.mode = new mode({ blockSize: 8, cipher: { encrypt: function (inBlock, outBlock) { return _updateBlock(self._keys, inBlock, outBlock, false) }, decrypt: function (inBlock, outBlock) { return _updateBlock(self._keys, inBlock, outBlock, true) } } }); self._init = false }; forge.des.Algorithm.prototype.initialize = function (options) { if (this._init) { return } var key = forge.util.createBuffer(options.key); if (this.name.indexOf("3DES") === 0) { if (key.length() !== 24) { throw new Error("Invalid Triple-DES key size: " + key.length() * 8) } } this._keys = _createKeys(key); this._init = true }; registerAlgorithm("DES-ECB", forge.cipher.modes.ecb); registerAlgorithm("DES-CBC", forge.cipher.modes.cbc); registerAlgorithm("DES-CFB", forge.cipher.modes.cfb); registerAlgorithm("DES-OFB", forge.cipher.modes.ofb); registerAlgorithm("DES-CTR", forge.cipher.modes.ctr); registerAlgorithm("3DES-ECB", forge.cipher.modes.ecb); registerAlgorithm("3DES-CBC", forge.cipher.modes.cbc); registerAlgorithm("3DES-CFB", forge.cipher.modes.cfb); registerAlgorithm("3DES-OFB", forge.cipher.modes.ofb); registerAlgorithm("3DES-CTR", forge.cipher.modes.ctr); function registerAlgorithm(name, mode) { var factory = function () { return new forge.des.Algorithm(name, mode) }; forge.cipher.registerAlgorithm(name, factory) } var spfunction1 = [16843776, 0, 65536, 16843780, 16842756, 66564, 4, 65536, 1024, 16843776, 16843780, 1024, 16778244, 16842756, 16777216, 4, 1028, 16778240, 16778240, 66560, 66560, 16842752, 16842752, 16778244, 65540, 16777220, 16777220, 65540, 0, 1028, 66564, 16777216, 65536, 16843780, 4, 16842752, 16843776, 16777216, 16777216, 1024, 16842756, 65536, 66560, 16777220, 1024, 4, 16778244, 66564, 16843780, 65540, 16842752, 16778244, 16777220, 1028, 66564, 16843776, 1028, 16778240, 16778240, 0, 65540, 66560, 0, 16842756]; var spfunction2 = [-2146402272, -2147450880, 32768, 1081376, 1048576, 32, -2146435040, -2147450848, -2147483616, -2146402272, -2146402304, -2147483648, -2147450880, 1048576, 32, -2146435040, 1081344, 1048608, -2147450848, 0, -2147483648, 32768, 1081376, -2146435072, 1048608, -2147483616, 0, 1081344, 32800, -2146402304, -2146435072, 32800, 0, 1081376, -2146435040, 1048576, -2147450848, -2146435072, -2146402304, 32768, -2146435072, -2147450880, 32, -2146402272, 1081376, 32, 32768, -2147483648, 32800, -2146402304, 1048576, -2147483616, 1048608, -2147450848, -2147483616, 1048608, 1081344, 0, -2147450880, 32800, -2147483648, -2146435040, -2146402272, 1081344]; var spfunction3 = [520, 134349312, 0, 134348808, 134218240, 0, 131592, 134218240, 131080, 134217736, 134217736, 131072, 134349320, 131080, 134348800, 520, 134217728, 8, 134349312, 512, 131584, 134348800, 134348808, 131592, 134218248, 131584, 131072, 134218248, 8, 134349320, 512, 134217728, 134349312, 134217728, 131080, 520, 131072, 134349312, 134218240, 0, 512, 131080, 134349320, 134218240, 134217736, 512, 0, 134348808, 134218248, 131072, 134217728, 134349320, 8, 131592, 131584, 134217736, 134348800, 134218248, 520, 134348800, 131592, 8, 134348808, 131584]; var spfunction4 = [8396801, 8321, 8321, 128, 8396928, 8388737, 8388609, 8193, 0, 8396800, 8396800, 8396929, 129, 0, 8388736, 8388609, 1, 8192, 8388608, 8396801, 128, 8388608, 8193, 8320, 8388737, 1, 8320, 8388736, 8192, 8396928, 8396929, 129, 8388736, 8388609, 8396800, 8396929, 129, 0, 0, 8396800, 8320, 8388736, 8388737, 1, 8396801, 8321, 8321, 128, 8396929, 129, 1, 8192, 8388609, 8193, 8396928, 8388737, 8193, 8320, 8388608, 8396801, 128, 8388608, 8192, 8396928]; var spfunction5 = [256, 34078976, 34078720, 1107296512, 524288, 256, 1073741824, 34078720, 1074266368, 524288, 33554688, 1074266368, 1107296512, 1107820544, 524544, 1073741824, 33554432, 1074266112, 1074266112, 0, 1073742080, 1107820800, 1107820800, 33554688, 1107820544, 1073742080, 0, 1107296256, 34078976, 33554432, 1107296256, 524544, 524288, 1107296512, 256, 33554432, 1073741824, 34078720, 1107296512, 1074266368, 33554688, 1073741824, 1107820544, 34078976, 1074266368, 256, 33554432, 1107820544, 1107820800, 524544, 1107296256, 1107820800, 34078720, 0, 1074266112, 1107296256, 524544, 33554688, 1073742080, 524288, 0, 1074266112, 34078976, 1073742080]; var spfunction6 = [536870928, 541065216, 16384, 541081616, 541065216, 16, 541081616, 4194304, 536887296, 4210704, 4194304, 536870928, 4194320, 536887296, 536870912, 16400, 0, 4194320, 536887312, 16384, 4210688, 536887312, 16, 541065232, 541065232, 0, 4210704, 541081600, 16400, 4210688, 541081600, 536870912, 536887296, 16, 541065232, 4210688, 541081616, 4194304, 16400, 536870928, 4194304, 536887296, 536870912, 16400, 536870928, 541081616, 4210688, 541065216, 4210704, 541081600, 0, 541065232, 16, 16384, 541065216, 4210704, 16384, 4194320, 536887312, 0, 541081600, 536870912, 4194320, 536887312]; var spfunction7 = [2097152, 69206018, 67110914, 0, 2048, 67110914, 2099202, 69208064, 69208066, 2097152, 0, 67108866, 2, 67108864, 69206018, 2050, 67110912, 2099202, 2097154, 67110912, 67108866, 69206016, 69208064, 2097154, 69206016, 2048, 2050, 69208066, 2099200, 2, 67108864, 2099200, 67108864, 2099200, 2097152, 67110914, 67110914, 69206018, 69206018, 2, 2097154, 67108864, 67110912, 2097152, 69208064, 2050, 2099202, 69208064, 2050, 67108866, 69208066, 69206016, 2099200, 0, 2, 69208066, 0, 2099202, 69206016, 2048, 67108866, 67110912, 2048, 2097154]; var spfunction8 = [268439616, 4096, 262144, 268701760, 268435456, 268439616, 64, 268435456, 262208, 268697600, 268701760, 266240, 268701696, 266304, 4096, 64, 268697600, 268435520, 268439552, 4160, 266240, 262208, 268697664, 268701696, 4160, 0, 0, 268697664, 268435520, 268439552, 266304, 262144, 266304, 262144, 268701696, 4096, 64, 268697664, 4096, 266304, 268439552, 64, 268435520, 268697600, 268697664, 268435456, 262144, 268439616, 0, 268701760, 262208, 268435520, 268697600, 268439552, 268439616, 0, 268701760, 266240, 266240, 4160, 4160, 262208, 268435456, 268701696]; function _createKeys(key) { var pc2bytes0 = [0, 4, 536870912, 536870916, 65536, 65540, 536936448, 536936452, 512, 516, 536871424, 536871428, 66048, 66052, 536936960, 536936964], pc2bytes1 = [0, 1, 1048576, 1048577, 67108864, 67108865, 68157440, 68157441, 256, 257, 1048832, 1048833, 67109120, 67109121, 68157696, 68157697], pc2bytes2 = [0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272, 0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272], pc2bytes3 = [0, 2097152, 134217728, 136314880, 8192, 2105344, 134225920, 136323072, 131072, 2228224, 134348800, 136445952, 139264, 2236416, 134356992, 136454144], pc2bytes4 = [0, 262144, 16, 262160, 0, 262144, 16, 262160, 4096, 266240, 4112, 266256, 4096, 266240, 4112, 266256], pc2bytes5 = [0, 1024, 32, 1056, 0, 1024, 32, 1056, 33554432, 33555456, 33554464, 33555488, 33554432, 33555456, 33554464, 33555488], pc2bytes6 = [0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746, 0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746], pc2bytes7 = [0, 65536, 2048, 67584, 536870912, 536936448, 536872960, 536938496, 131072, 196608, 133120, 198656, 537001984, 537067520, 537004032, 537069568], pc2bytes8 = [0, 262144, 0, 262144, 2, 262146, 2, 262146, 33554432, 33816576, 33554432, 33816576, 33554434, 33816578, 33554434, 33816578], pc2bytes9 = [0, 268435456, 8, 268435464, 0, 268435456, 8, 268435464, 1024, 268436480, 1032, 268436488, 1024, 268436480, 1032, 268436488], pc2bytes10 = [0, 32, 0, 32, 1048576, 1048608, 1048576, 1048608, 8192, 8224, 8192, 8224, 1056768, 1056800, 1056768, 1056800], pc2bytes11 = [0, 16777216, 512, 16777728, 2097152, 18874368, 2097664, 18874880, 67108864, 83886080, 67109376, 83886592, 69206016, 85983232, 69206528, 85983744], pc2bytes12 = [0, 4096, 134217728, 134221824, 524288, 528384, 134742016, 134746112, 16, 4112, 134217744, 134221840, 524304, 528400, 134742032, 134746128], pc2bytes13 = [0, 4, 256, 260, 0, 4, 256, 260, 1, 5, 257, 261, 1, 5, 257, 261]; var iterations = key.length() > 8 ? 3 : 1; var keys = []; var shifts = [0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0]; var n = 0, tmp; for (var j = 0; j < iterations; j++) { var left = key.getInt32(); var right = key.getInt32(); tmp = (left >>> 4 ^ right) & 252645135; right ^= tmp; left ^= tmp << 4; tmp = (right >>> -16 ^ left) & 65535; left ^= tmp; right ^= tmp << -16; tmp = (left >>> 2 ^ right) & 858993459; right ^= tmp; left ^= tmp << 2; tmp = (right >>> -16 ^ left) & 65535; left ^= tmp; right ^= tmp << -16; tmp = (left >>> 1 ^ right) & 1431655765; right ^= tmp; left ^= tmp << 1; tmp = (right >>> 8 ^ left) & 16711935; left ^= tmp; right ^= tmp << 8; tmp = (left >>> 1 ^ right) & 1431655765; right ^= tmp; left ^= tmp << 1; tmp = left << 8 | right >>> 20 & 240; left = right << 24 | right << 8 & 16711680 | right >>> 8 & 65280 | right >>> 24 & 240; right = tmp; for (var i = 0; i < shifts.length; ++i) { if (shifts[i]) { left = left << 2 | left >>> 26; right = right << 2 | right >>> 26 } else { left = left << 1 | left >>> 27; right = right << 1 | right >>> 27 } left &= -15; right &= -15; var lefttmp = pc2bytes0[left >>> 28] | pc2bytes1[left >>> 24 & 15] | pc2bytes2[left >>> 20 & 15] | pc2bytes3[left >>> 16 & 15] | pc2bytes4[left >>> 12 & 15] | pc2bytes5[left >>> 8 & 15] | pc2bytes6[left >>> 4 & 15]; var righttmp = pc2bytes7[right >>> 28] | pc2bytes8[right >>> 24 & 15] | pc2bytes9[right >>> 20 & 15] | pc2bytes10[right >>> 16 & 15] | pc2bytes11[right >>> 12 & 15] | pc2bytes12[right >>> 8 & 15] | pc2bytes13[right >>> 4 & 15]; tmp = (righttmp >>> 16 ^ lefttmp) & 65535; keys[n++] = lefttmp ^ tmp; keys[n++] = righttmp ^ tmp << 16 } } return keys } function _updateBlock(keys, input, output, decrypt) { var iterations = keys.length === 32 ? 3 : 9; var looping; if (iterations === 3) { looping = decrypt ? [30, -2, -2] : [0, 32, 2] } else { looping = decrypt ? [94, 62, -2, 32, 64, 2, 30, -2, -2] : [0, 32, 2, 62, 30, -2, 64, 96, 2] } var tmp; var left = input[0]; var right = input[1]; tmp = (left >>> 4 ^ right) & 252645135; right ^= tmp; left ^= tmp << 4; tmp = (left >>> 16 ^ right) & 65535; right ^= tmp; left ^= tmp << 16; tmp = (right >>> 2 ^ left) & 858993459; left ^= tmp; right ^= tmp << 2; tmp = (right >>> 8 ^ left) & 16711935; left ^= tmp; right ^= tmp << 8; tmp = (left >>> 1 ^ right) & 1431655765; right ^= tmp; left ^= tmp << 1; left = left << 1 | left >>> 31; right = right << 1 | right >>> 31; for (var j = 0; j < iterations; j += 3) { var endloop = looping[j + 1]; var loopinc = looping[j + 2]; for (var i = looping[j]; i != endloop; i += loopinc) { var right1 = right ^ keys[i]; var right2 = (right >>> 4 | right << 28) ^ keys[i + 1]; tmp = left; left = right; right = tmp ^ (spfunction2[right1 >>> 24 & 63] | spfunction4[right1 >>> 16 & 63] | spfunction6[right1 >>> 8 & 63] | spfunction8[right1 & 63] | spfunction1[right2 >>> 24 & 63] | spfunction3[right2 >>> 16 & 63] | spfunction5[right2 >>> 8 & 63] | spfunction7[right2 & 63]) } tmp = left; left = right; right = tmp } left = left >>> 1 | left << 31; right = right >>> 1 | right << 31; tmp = (left >>> 1 ^ right) & 1431655765; right ^= tmp; left ^= tmp << 1; tmp = (right >>> 8 ^ left) & 16711935; left ^= tmp; right ^= tmp << 8; tmp = (right >>> 2 ^ left) & 858993459; left ^= tmp; right ^= tmp << 2; tmp = (left >>> 16 ^ right) & 65535; right ^= tmp; left ^= tmp << 16; tmp = (left >>> 4 ^ right) & 252645135; right ^= tmp; left ^= tmp << 4; output[0] = left; output[1] = right } function _createCipher(options) { options = options || {}; var mode = (options.mode || "CBC").toUpperCase(); var algorithm = "DES-" + mode; var cipher; if (options.decrypt) { cipher = forge.cipher.createDecipher(algorithm, options.key) } else { cipher = forge.cipher.createCipher(algorithm, options.key) } var start = cipher.start; cipher.start = function (iv, options) { var output = null; if (options instanceof forge.util.ByteBuffer) { output = options; options = {} } options = options || {}; options.output = output; options.iv = iv; start.call(cipher, options) }; return cipher } }, { "./cipher": 11, "./cipherModes": 12, "./forge": 16, "./util": 48 }], 15: [function (require, module, exports) { (function (Buffer) { var forge = require("./forge"); require("./jsbn"); require("./random"); require("./sha512"); require("./util"); if (typeof BigInteger === "undefined") { var BigInteger = forge.jsbn.BigInteger } var ByteBuffer = forge.util.ByteBuffer; var NativeBuffer = typeof Buffer === "undefined" ? Uint8Array : Buffer; forge.pki = forge.pki || {}; module.exports = forge.pki.ed25519 = forge.ed25519 = forge.ed25519 || {}; var ed25519 = forge.ed25519; ed25519.constants = {}; ed25519.constants.PUBLIC_KEY_BYTE_LENGTH = 32; ed25519.constants.PRIVATE_KEY_BYTE_LENGTH = 64; ed25519.constants.SEED_BYTE_LENGTH = 32; ed25519.constants.SIGN_BYTE_LENGTH = 64; ed25519.constants.HASH_BYTE_LENGTH = 64; ed25519.generateKeyPair = function (options) { options = options || {}; var seed = options.seed; if (seed === undefined) { seed = forge.random.getBytesSync(ed25519.constants.SEED_BYTE_LENGTH) } else if (typeof seed === "string") { if (seed.length !== ed25519.constants.SEED_BYTE_LENGTH) { throw new TypeError('"seed" must be ' + ed25519.constants.SEED_BYTE_LENGTH + " bytes in length.") } } else if (!(seed instanceof Uint8Array)) { throw new TypeError('"seed" must be a node.js Buffer, Uint8Array, or a binary string.') } seed = messageToNativeBuffer({ message: seed, encoding: "binary" }); var pk = new NativeBuffer(ed25519.constants.PUBLIC_KEY_BYTE_LENGTH); var sk = new NativeBuffer(ed25519.constants.PRIVATE_KEY_BYTE_LENGTH); for (var i = 0; i < 32; ++i) { sk[i] = seed[i] } crypto_sign_keypair(pk, sk); return { publicKey: pk, privateKey: sk } }; ed25519.publicKeyFromPrivateKey = function (options) { options = options || {}; var privateKey = messageToNativeBuffer({ message: options.privateKey, encoding: "binary" }); if (privateKey.length !== ed25519.constants.PRIVATE_KEY_BYTE_LENGTH) { throw new TypeError('"options.privateKey" must have a byte length of ' + ed25519.constants.PRIVATE_KEY_BYTE_LENGTH) } var pk = new NativeBuffer(ed25519.constants.PUBLIC_KEY_BYTE_LENGTH); for (var i = 0; i < pk.length; ++i) { pk[i] = privateKey[32 + i] } return pk }; ed25519.sign = function (options) { options = options || {}; var msg = messageToNativeBuffer(options); var privateKey = messageToNativeBuffer({ message: options.privateKey, encoding: "binary" }); if (privateKey.length !== ed25519.constants.PRIVATE_KEY_BYTE_LENGTH) { throw new TypeError('"options.privateKey" must have a byte length of ' + ed25519.constants.PRIVATE_KEY_BYTE_LENGTH) } var signedMsg = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH + msg.length); crypto_sign(signedMsg, msg, msg.length, privateKey); var sig = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH); for (var i = 0; i < sig.length; ++i) { sig[i] = signedMsg[i] } return sig }; ed25519.verify = function (options) { options = options || {}; var msg = messageToNativeBuffer(options); if (options.signature === undefined) { throw new TypeError('"options.signature" must be a node.js Buffer, a Uint8Array, a forge ' + "ByteBuffer, or a binary string.") } var sig = messageToNativeBuffer({ message: options.signature, encoding: "binary" }); if (sig.length !== ed25519.constants.SIGN_BYTE_LENGTH) { throw new TypeError('"options.signature" must have a byte length of ' + ed25519.constants.SIGN_BYTE_LENGTH) } var publicKey = messageToNativeBuffer({ message: options.publicKey, encoding: "binary" }); if (publicKey.length !== ed25519.constants.PUBLIC_KEY_BYTE_LENGTH) { throw new TypeError('"options.publicKey" must have a byte length of ' + ed25519.constants.PUBLIC_KEY_BYTE_LENGTH) } var sm = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH + msg.length); var m = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH + msg.length); var i; for (i = 0; i < ed25519.constants.SIGN_BYTE_LENGTH; ++i) { sm[i] = sig[i] } for (i = 0; i < msg.length; ++i) { sm[i + ed25519.constants.SIGN_BYTE_LENGTH] = msg[i] } return crypto_sign_open(m, sm, sm.length, publicKey) >= 0 }; function messageToNativeBuffer(options) { var message = options.message; if (message instanceof Uint8Array) { return message } var encoding = options.encoding; if (message === undefined) { if (options.md) { message = options.md.digest().getBytes(); encoding = "binary" } else { throw new TypeError('"options.message" or "options.md" not specified.') } } if (typeof message === "string" && !encoding) { throw new TypeError('"options.encoding" must be "binary" or "utf8".') } if (typeof message === "string") { if (typeof Buffer !== "undefined") { return Buffer.from(message, encoding) } message = new ByteBuffer(message, encoding) } else if (!(message instanceof ByteBuffer)) { throw new TypeError('"options.message" must be a node.js Buffer, a Uint8Array, a forge ' + 'ByteBuffer, or a string with "options.encoding" specifying its ' + "encoding.") } var buffer = new NativeBuffer(message.length()); for (var i = 0; i < buffer.length; ++i) { buffer[i] = message.at(i) } return buffer } var gf0 = gf(); var gf1 = gf([1]); var D = gf([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]); var D2 = gf([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]); var X = gf([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]); var Y = gf([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]); var L = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]); var I = gf([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]); function sha512(msg, msgLen) { var md = forge.md.sha512.create(); var buffer = new ByteBuffer(msg); md.update(buffer.getBytes(msgLen), "binary"); var hash = md.digest().getBytes(); if (typeof Buffer !== "undefined") { return Buffer.from(hash, "binary") } var out = new NativeBuffer(ed25519.constants.HASH_BYTE_LENGTH); for (var i = 0; i < 64; ++i) { out[i] = hash.charCodeAt(i) } return out } function crypto_sign_keypair(pk, sk) { var p = [gf(), gf(), gf(), gf()]; var i; var d = sha512(sk, 32); d[0] &= 248; d[31] &= 127; d[31] |= 64; scalarbase(p, d); pack(pk, p); for (i = 0; i < 32; ++i) { sk[i + 32] = pk[i] } return 0 } function crypto_sign(sm, m, n, sk) { var i, j, x = new Float64Array(64); var p = [gf(), gf(), gf(), gf()]; var d = sha512(sk, 32); d[0] &= 248; d[31] &= 127; d[31] |= 64; var smlen = n + 64; for (i = 0; i < n; ++i) { sm[64 + i] = m[i] } for (i = 0; i < 32; ++i) { sm[32 + i] = d[32 + i] } var r = sha512(sm.subarray(32), n + 32); reduce(r); scalarbase(p, r); pack(sm, p); for (i = 32; i < 64; ++i) { sm[i] = sk[i] } var h = sha512(sm, n + 64); reduce(h); for (i = 32; i < 64; ++i) { x[i] = 0 } for (i = 0; i < 32; ++i) { x[i] = r[i] } for (i = 0; i < 32; ++i) { for (j = 0; j < 32; j++) { x[i + j] += h[i] * d[j] } } modL(sm.subarray(32), x); return smlen } function crypto_sign_open(m, sm, n, pk) { var i, mlen; var t = new NativeBuffer(32); var p = [gf(), gf(), gf(), gf()], q = [gf(), gf(), gf(), gf()]; mlen = -1; if (n < 64) { return -1 } if (unpackneg(q, pk)) { return -1 } for (i = 0; i < n; ++i) { m[i] = sm[i] } for (i = 0; i < 32; ++i) { m[i + 32] = pk[i] } var h = sha512(m, n); reduce(h); scalarmult(p, q, h); scalarbase(q, sm.subarray(32)); add(p, q); pack(t, p); n -= 64; if (crypto_verify_32(sm, 0, t, 0)) { for (i = 0; i < n; ++i) { m[i] = 0 } return -1 } for (i = 0; i < n; ++i) { m[i] = sm[i + 64] } mlen = n; return mlen } function modL(r, x) { var carry, i, j, k; for (i = 63; i >= 32; --i) { carry = 0; for (j = i - 32, k = i - 12; j < k; ++j) { x[j] += carry - 16 * x[i] * L[j - (i - 32)]; carry = x[j] + 128 >> 8; x[j] -= carry * 256 } x[j] += carry; x[i] = 0 } carry = 0; for (j = 0; j < 32; ++j) { x[j] += carry - (x[31] >> 4) * L[j]; carry = x[j] >> 8; x[j] &= 255 } for (j = 0; j < 32; ++j) { x[j] -= carry * L[j] } for (i = 0; i < 32; ++i) { x[i + 1] += x[i] >> 8; r[i] = x[i] & 255 } } function reduce(r) { var x = new Float64Array(64); for (var i = 0; i < 64; ++i) { x[i] = r[i]; r[i] = 0 } modL(r, x) } function add(p, q) { var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf(), g = gf(), h = gf(), t = gf(); Z(a, p[1], p[0]); Z(t, q[1], q[0]); M(a, a, t); A(b, p[0], p[1]); A(t, q[0], q[1]); M(b, b, t); M(c, p[3], q[3]); M(c, c, D2); M(d, p[2], q[2]); A(d, d, d); Z(e, b, a); Z(f, d, c); A(g, d, c); A(h, b, a); M(p[0], e, f); M(p[1], h, g); M(p[2], g, f); M(p[3], e, h) } function cswap(p, q, b) { for (var i = 0; i < 4; ++i) { sel25519(p[i], q[i], b) } } function pack(r, p) { var tx = gf(), ty = gf(), zi = gf(); inv25519(zi, p[2]); M(tx, p[0], zi); M(ty, p[1], zi); pack25519(r, ty); r[31] ^= par25519(tx) << 7 } function pack25519(o, n) { var i, j, b; var m = gf(), t = gf(); for (i = 0; i < 16; ++i) { t[i] = n[i] } car25519(t); car25519(t); car25519(t); for (j = 0; j < 2; ++j) { m[0] = t[0] - 65517; for (i = 1; i < 15; ++i) { m[i] = t[i] - 65535 - (m[i - 1] >> 16 & 1); m[i - 1] &= 65535 } m[15] = t[15] - 32767 - (m[14] >> 16 & 1); b = m[15] >> 16 & 1; m[14] &= 65535; sel25519(t, m, 1 - b) } for (i = 0; i < 16; i++) { o[2 * i] = t[i] & 255; o[2 * i + 1] = t[i] >> 8 } } function unpackneg(r, p) { var t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf(); set25519(r[2], gf1); unpack25519(r[1], p); S(num, r[1]); M(den, num, D); Z(num, num, r[2]); A(den, r[2], den); S(den2, den); S(den4, den2); M(den6, den4, den2); M(t, den6, num); M(t, t, den); pow2523(t, t); M(t, t, num); M(t, t, den); M(t, t, den); M(r[0], t, den); S(chk, r[0]); M(chk, chk, den); if (neq25519(chk, num)) { M(r[0], r[0], I) } S(chk, r[0]); M(chk, chk, den); if (neq25519(chk, num)) { return -1 } if (par25519(r[0]) === p[31] >> 7) { Z(r[0], gf0, r[0]) } M(r[3], r[0], r[1]); return 0 } function unpack25519(o, n) { var i; for (i = 0; i < 16; ++i) { o[i] = n[2 * i] + (n[2 * i + 1] << 8) } o[15] &= 32767 } function pow2523(o, i) { var c = gf(); var a; for (a = 0; a < 16; ++a) { c[a] = i[a] } for (a = 250; a >= 0; --a) { S(c, c); if (a !== 1) { M(c, c, i) } } for (a = 0; a < 16; ++a) { o[a] = c[a] } } function neq25519(a, b) { var c = new NativeBuffer(32); var d = new NativeBuffer(32); pack25519(c, a); pack25519(d, b); return crypto_verify_32(c, 0, d, 0) } function crypto_verify_32(x, xi, y, yi) { return vn(x, xi, y, yi, 32) } function vn(x, xi, y, yi, n) { var i, d = 0; for (i = 0; i < n; ++i) { d |= x[xi + i] ^ y[yi + i] } return (1 & d - 1 >>> 8) - 1 } function par25519(a) { var d = new NativeBuffer(32); pack25519(d, a); return d[0] & 1 } function scalarmult(p, q, s) { var b, i; set25519(p[0], gf0); set25519(p[1], gf1); set25519(p[2], gf1); set25519(p[3], gf0); for (i = 255; i >= 0; --i) { b = s[i / 8 | 0] >> (i & 7) & 1; cswap(p, q, b); add(q, p); add(p, p); cswap(p, q, b) } } function scalarbase(p, s) { var q = [gf(), gf(), gf(), gf()]; set25519(q[0], X); set25519(q[1], Y); set25519(q[2], gf1); M(q[3], X, Y); scalarmult(p, q, s) } function set25519(r, a) { var i; for (i = 0; i < 16; i++) { r[i] = a[i] | 0 } } function inv25519(o, i) { var c = gf(); var a; for (a = 0; a < 16; ++a) { c[a] = i[a] } for (a = 253; a >= 0; --a) { S(c, c); if (a !== 2 && a !== 4) { M(c, c, i) } } for (a = 0; a < 16; ++a) { o[a] = c[a] } } function car25519(o) { var i, v, c = 1; for (i = 0; i < 16; ++i) { v = o[i] + c + 65535; c = Math.floor(v / 65536); o[i] = v - c * 65536 } o[0] += c - 1 + 37 * (c - 1) } function sel25519(p, q, b) { var t, c = ~(b - 1); for (var i = 0; i < 16; ++i) { t = c & (p[i] ^ q[i]); p[i] ^= t; q[i] ^= t } } function gf(init) { var i, r = new Float64Array(16); if (init) { for (i = 0; i < init.length; ++i) { r[i] = init[i] } } return r } function A(o, a, b) { for (var i = 0; i < 16; ++i) { o[i] = a[i] + b[i] } } function Z(o, a, b) { for (var i = 0; i < 16; ++i) { o[i] = a[i] - b[i] } } function S(o, a) { M(o, a, a) } function M(o, a, b) { var v, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15]; v = a[0]; t0 += v * b0; t1 += v * b1; t2 += v * b2; t3 += v * b3; t4 += v * b4; t5 += v * b5; t6 += v * b6; t7 += v * b7; t8 += v * b8; t9 += v * b9; t10 += v * b10; t11 += v * b11; t12 += v * b12; t13 += v * b13; t14 += v * b14; t15 += v * b15; v = a[1]; t1 += v * b0; t2 += v * b1; t3 += v * b2; t4 += v * b3; t5 += v * b4; t6 += v * b5; t7 += v * b6; t8 += v * b7; t9 += v * b8; t10 += v * b9; t11 += v * b10; t12 += v * b11; t13 += v * b12; t14 += v * b13; t15 += v * b14; t16 += v * b15; v = a[2]; t2 += v * b0; t3 += v * b1; t4 += v * b2; t5 += v * b3; t6 += v * b4; t7 += v * b5; t8 += v * b6; t9 += v * b7; t10 += v * b8; t11 += v * b9; t12 += v * b10; t13 += v * b11; t14 += v * b12; t15 += v * b13; t16 += v * b14; t17 += v * b15; v = a[3]; t3 += v * b0; t4 += v * b1; t5 += v * b2; t6 += v * b3; t7 += v * b4; t8 += v * b5; t9 += v * b6; t10 += v * b7; t11 += v * b8; t12 += v * b9; t13 += v * b10; t14 += v * b11; t15 += v * b12; t16 += v * b13; t17 += v * b14; t18 += v * b15; v = a[4]; t4 += v * b0; t5 += v * b1; t6 += v * b2; t7 += v * b3; t8 += v * b4; t9 += v * b5; t10 += v * b6; t11 += v * b7; t12 += v * b8; t13 += v * b9; t14 += v * b10; t15 += v * b11; t16 += v * b12; t17 += v * b13; t18 += v * b14; t19 += v * b15; v = a[5]; t5 += v * b0; t6 += v * b1; t7 += v * b2; t8 += v * b3; t9 += v * b4; t10 += v * b5; t11 += v * b6; t12 += v * b7; t13 += v * b8; t14 += v * b9; t15 += v * b10; t16 += v * b11; t17 += v * b12; t18 += v * b13; t19 += v * b14; t20 += v * b15; v = a[6]; t6 += v * b0; t7 += v * b1; t8 += v * b2; t9 += v * b3; t10 += v * b4; t11 += v * b5; t12 += v * b6; t13 += v * b7; t14 += v * b8; t15 += v * b9; t16 += v * b10; t17 += v * b11; t18 += v * b12; t19 += v * b13; t20 += v * b14; t21 += v * b15; v = a[7]; t7 += v * b0; t8 += v * b1; t9 += v * b2; t10 += v * b3; t11 += v * b4; t12 += v * b5; t13 += v * b6; t14 += v * b7; t15 += v * b8; t16 += v * b9; t17 += v * b10; t18 += v * b11; t19 += v * b12; t20 += v * b13; t21 += v * b14; t22 += v * b15; v = a[8]; t8 += v * b0; t9 += v * b1; t10 += v * b2; t11 += v * b3; t12 += v * b4; t13 += v * b5; t14 += v * b6; t15 += v * b7; t16 += v * b8; t17 += v * b9; t18 += v * b10; t19 += v * b11; t20 += v * b12; t21 += v * b13; t22 += v * b14; t23 += v * b15; v = a[9]; t9 += v * b0; t10 += v * b1; t11 += v * b2; t12 += v * b3; t13 += v * b4; t14 += v * b5; t15 += v * b6; t16 += v * b7; t17 += v * b8; t18 += v * b9; t19 += v * b10; t20 += v * b11; t21 += v * b12; t22 += v * b13; t23 += v * b14; t24 += v * b15; v = a[10]; t10 += v * b0; t11 += v * b1; t12 += v * b2; t13 += v * b3; t14 += v * b4; t15 += v * b5; t16 += v * b6; t17 += v * b7; t18 += v * b8; t19 += v * b9; t20 += v * b10; t21 += v * b11; t22 += v * b12; t23 += v * b13; t24 += v * b14; t25 += v * b15; v = a[11]; t11 += v * b0; t12 += v * b1; t13 += v * b2; t14 += v * b3; t15 += v * b4; t16 += v * b5; t17 += v * b6; t18 += v * b7; t19 += v * b8; t20 += v * b9; t21 += v * b10; t22 += v * b11; t23 += v * b12; t24 += v * b13; t25 += v * b14; t26 += v * b15; v = a[12]; t12 += v * b0; t13 += v * b1; t14 += v * b2; t15 += v * b3; t16 += v * b4; t17 += v * b5; t18 += v * b6; t19 += v * b7; t20 += v * b8; t21 += v * b9; t22 += v * b10; t23 += v * b11; t24 += v * b12; t25 += v * b13; t26 += v * b14; t27 += v * b15; v = a[13]; t13 += v * b0; t14 += v * b1; t15 += v * b2; t16 += v * b3; t17 += v * b4; t18 += v * b5; t19 += v * b6; t20 += v * b7; t21 += v * b8; t22 += v * b9; t23 += v * b10; t24 += v * b11; t25 += v * b12; t26 += v * b13; t27 += v * b14; t28 += v * b15; v = a[14]; t14 += v * b0; t15 += v * b1; t16 += v * b2; t17 += v * b3; t18 += v * b4; t19 += v * b5; t20 += v * b6; t21 += v * b7; t22 += v * b8; t23 += v * b9; t24 += v * b10; t25 += v * b11; t26 += v * b12; t27 += v * b13; t28 += v * b14; t29 += v * b15; v = a[15]; t15 += v * b0; t16 += v * b1; t17 += v * b2; t18 += v * b3; t19 += v * b4; t20 += v * b5; t21 += v * b6; t22 += v * b7; t23 += v * b8; t24 += v * b9; t25 += v * b10; t26 += v * b11; t27 += v * b12; t28 += v * b13; t29 += v * b14; t30 += v * b15; t0 += 38 * t16; t1 += 38 * t17; t2 += 38 * t18; t3 += 38 * t19; t4 += 38 * t20; t5 += 38 * t21; t6 += 38 * t22; t7 += 38 * t23; t8 += 38 * t24; t9 += 38 * t25; t10 += 38 * t26; t11 += 38 * t27; t12 += 38 * t28; t13 += 38 * t29; t14 += 38 * t30; c = 1; v = t0 + c + 65535; c = Math.floor(v / 65536); t0 = v - c * 65536; v = t1 + c + 65535; c = Math.floor(v / 65536); t1 = v - c * 65536; v = t2 + c + 65535; c = Math.floor(v / 65536); t2 = v - c * 65536; v = t3 + c + 65535; c = Math.floor(v / 65536); t3 = v - c * 65536; v = t4 + c + 65535; c = Math.floor(v / 65536); t4 = v - c * 65536; v = t5 + c + 65535; c = Math.floor(v / 65536); t5 = v - c * 65536; v = t6 + c + 65535; c = Math.floor(v / 65536); t6 = v - c * 65536; v = t7 + c + 65535; c = Math.floor(v / 65536); t7 = v - c * 65536; v = t8 + c + 65535; c = Math.floor(v / 65536); t8 = v - c * 65536; v = t9 + c + 65535; c = Math.floor(v / 65536); t9 = v - c * 65536; v = t10 + c + 65535; c = Math.floor(v / 65536); t10 = v - c * 65536; v = t11 + c + 65535; c = Math.floor(v / 65536); t11 = v - c * 65536; v = t12 + c + 65535; c = Math.floor(v / 65536); t12 = v - c * 65536; v = t13 + c + 65535; c = Math.floor(v / 65536); t13 = v - c * 65536; v = t14 + c + 65535; c = Math.floor(v / 65536); t14 = v - c * 65536; v = t15 + c + 65535; c = Math.floor(v / 65536); t15 = v - c * 65536; t0 += c - 1 + 37 * (c - 1); c = 1; v = t0 + c + 65535; c = Math.floor(v / 65536); t0 = v - c * 65536; v = t1 + c + 65535; c = Math.floor(v / 65536); t1 = v - c * 65536; v = t2 + c + 65535; c = Math.floor(v / 65536); t2 = v - c * 65536; v = t3 + c + 65535; c = Math.floor(v / 65536); t3 = v - c * 65536; v = t4 + c + 65535; c = Math.floor(v / 65536); t4 = v - c * 65536; v = t5 + c + 65535; c = Math.floor(v / 65536); t5 = v - c * 65536; v = t6 + c + 65535; c = Math.floor(v / 65536); t6 = v - c * 65536; v = t7 + c + 65535; c = Math.floor(v / 65536); t7 = v - c * 65536; v = t8 + c + 65535; c = Math.floor(v / 65536); t8 = v - c * 65536; v = t9 + c + 65535; c = Math.floor(v / 65536); t9 = v - c * 65536; v = t10 + c + 65535; c = Math.floor(v / 65536); t10 = v - c * 65536; v = t11 + c + 65535; c = Math.floor(v / 65536); t11 = v - c * 65536; v = t12 + c + 65535; c = Math.floor(v / 65536); t12 = v - c * 65536; v = t13 + c + 65535; c = Math.floor(v / 65536); t13 = v - c * 65536; v = t14 + c + 65535; c = Math.floor(v / 65536); t14 = v - c * 65536; v = t15 + c + 65535; c = Math.floor(v / 65536); t15 = v - c * 65536; t0 += c - 1 + 37 * (c - 1); o[0] = t0; o[1] = t1; o[2] = t2; o[3] = t3; o[4] = t4; o[5] = t5; o[6] = t6; o[7] = t7; o[8] = t8; o[9] = t9; o[10] = t10; o[11] = t11; o[12] = t12; o[13] = t13; o[14] = t14; o[15] = t15 } }).call(this, require("buffer").Buffer) }, { "./forge": 16, "./jsbn": 19, "./random": 39, "./sha512": 44, "./util": 48, buffer: 6 }], 16: [function (require, module, exports) { module.exports = { options: { usePureJavaScript: false } } }, {}], 17: [function (require, module, exports) { var forge = require("./forge"); require("./md"); require("./util"); var hmac = module.exports = forge.hmac = forge.hmac || {}; hmac.create = function () { var _key = null; var _md = null; var _ipadding = null; var _opadding = null; var ctx = {}; ctx.start = function (md, key) { if (md !== null) { if (typeof md === "string") { md = md.toLowerCase(); if (md in forge.md.algorithms) { _md = forge.md.algorithms[md].create() } else { throw new Error('Unknown hash algorithm "' + md + '"') } } else { _md = md } } if (key === null) { key = _key } else { if (typeof key === "string") { key = forge.util.createBuffer(key) } else if (forge.util.isArray(key)) { var tmp = key; key = forge.util.createBuffer(); for (var i = 0; i < tmp.length; ++i) { key.putByte(tmp[i]) } } var keylen = key.length(); if (keylen > _md.blockLength) { _md.start(); _md.update(key.bytes()); key = _md.digest() } _ipadding = forge.util.createBuffer(); _opadding = forge.util.createBuffer(); keylen = key.length(); for (var i = 0; i < keylen; ++i) { var tmp = key.at(i); _ipadding.putByte(54 ^ tmp); _opadding.putByte(92 ^ tmp) } if (keylen < _md.blockLength) { var tmp = _md.blockLength - keylen; for (var i = 0; i < tmp; ++i) { _ipadding.putByte(54); _opadding.putByte(92) } } _key = key; _ipadding = _ipadding.bytes(); _opadding = _opadding.bytes() } _md.start(); _md.update(_ipadding) }; ctx.update = function (bytes) { _md.update(bytes) }; ctx.getMac = function () { var inner = _md.digest().bytes(); _md.start(); _md.update(_opadding); _md.update(inner); return _md.digest() }; ctx.digest = ctx.getMac; return ctx } }, { "./forge": 16, "./md": 23, "./util": 48 }], 18: [function (require, module, exports) { module.exports = require("./forge"); require("./aes"); require("./aesCipherSuites"); require("./asn1"); require("./cipher"); require("./debug"); require("./des"); require("./ed25519"); require("./hmac"); require("./kem"); require("./log"); require("./md.all"); require("./mgf1"); require("./pbkdf2"); require("./pem"); require("./pkcs1"); require("./pkcs12"); require("./pkcs7"); require("./pki"); require("./prime"); require("./prng"); require("./pss"); require("./random"); require("./rc2"); require("./ssh"); require("./task"); require("./tls"); require("./util") }, { "./aes": 7, "./aesCipherSuites": 8, "./asn1": 9, "./cipher": 11, "./debug": 13, "./des": 14, "./ed25519": 15, "./forge": 16, "./hmac": 17, "./kem": 20, "./log": 21, "./md.all": 22, "./mgf1": 26, "./pbkdf2": 29, "./pem": 30, "./pkcs1": 31, "./pkcs12": 32, "./pkcs7": 33, "./pki": 35, "./prime": 36, "./prng": 37, "./pss": 38, "./random": 39, "./rc2": 40, "./ssh": 45, "./task": 46, "./tls": 47, "./util": 48 }], 19: [function (require, module, exports) { var forge = require("./forge"); module.exports = forge.jsbn = forge.jsbn || {}; var dbits; var canary = 0xdeadbeefcafe; var j_lm = (canary & 16777215) == 15715070; function BigInteger(a, b, c) { this.data = []; if (a != null) if ("number" == typeof a) this.fromNumber(a, b, c); else if (b == null && "string" != typeof a) this.fromString(a, 256); else this.fromString(a, b) } forge.jsbn.BigInteger = BigInteger; function nbi() { return new BigInteger(null) } function am1(i, x, w, j, c, n) { while (--n >= 0) { var v = x * this.data[i++] + w.data[j] + c; c = Math.floor(v / 67108864); w.data[j++] = v & 67108863 } return c } function am2(i, x, w, j, c, n) { var xl = x & 32767, xh = x >> 15; while (--n >= 0) { var l = this.data[i] & 32767; var h = this.data[i++] >> 15; var m = xh * l + h * xl; l = xl * l + ((m & 32767) << 15) + w.data[j] + (c & 1073741823); c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30); w.data[j++] = l & 1073741823 } return c } function am3(i, x, w, j, c, n) { var xl = x & 16383, xh = x >> 14; while (--n >= 0) { var l = this.data[i] & 16383; var h = this.data[i++] >> 14; var m = xh * l + h * xl; l = xl * l + ((m & 16383) << 14) + w.data[j] + c; c = (l >> 28) + (m >> 14) + xh * h; w.data[j++] = l & 268435455 } return c } if (typeof navigator === "undefined") { BigInteger.prototype.am = am3; dbits = 28 } else if (j_lm && navigator.appName == "Microsoft Internet Explorer") { BigInteger.prototype.am = am2; dbits = 30 } else if (j_lm && navigator.appName != "Netscape") { BigInteger.prototype.am = am1; dbits = 26 } else { BigInteger.prototype.am = am3; dbits = 28 } BigInteger.prototype.DB = dbits; BigInteger.prototype.DM = (1 << dbits) - 1; BigInteger.prototype.DV = 1 << dbits; var BI_FP = 52; BigInteger.prototype.FV = Math.pow(2, BI_FP); BigInteger.prototype.F1 = BI_FP - dbits; BigInteger.prototype.F2 = 2 * dbits - BI_FP; var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz"; var BI_RC = new Array; var rr, vv; rr = "0".charCodeAt(0); for (vv = 0; vv <= 9; ++vv)BI_RC[rr++] = vv; rr = "a".charCodeAt(0); for (vv = 10; vv < 36; ++vv)BI_RC[rr++] = vv; rr = "A".charCodeAt(0); for (vv = 10; vv < 36; ++vv)BI_RC[rr++] = vv; function int2char(n) { return BI_RM.charAt(n) } function intAt(s, i) { var c = BI_RC[s.charCodeAt(i)]; return c == null ? -1 : c } function bnpCopyTo(r) { for (var i = this.t - 1; i >= 0; --i)r.data[i] = this.data[i]; r.t = this.t; r.s = this.s } function bnpFromInt(x) { this.t = 1; this.s = x < 0 ? -1 : 0; if (x > 0) this.data[0] = x; else if (x < -1) this.data[0] = x + this.DV; else this.t = 0 } function nbv(i) { var r = nbi(); r.fromInt(i); return r } function bnpFromString(s, b) { var k; if (b == 16) k = 4; else if (b == 8) k = 3; else if (b == 256) k = 8; else if (b == 2) k = 1; else if (b == 32) k = 5; else if (b == 4) k = 2; else { this.fromRadix(s, b); return } this.t = 0; this.s = 0; var i = s.length, mi = false, sh = 0; while (--i >= 0) { var x = k == 8 ? s[i] & 255 : intAt(s, i); if (x < 0) { if (s.charAt(i) == "-") mi = true; continue } mi = false; if (sh == 0) this.data[this.t++] = x; else if (sh + k > this.DB) { this.data[this.t - 1] |= (x & (1 << this.DB - sh) - 1) << sh; this.data[this.t++] = x >> this.DB - sh } else this.data[this.t - 1] |= x << sh; sh += k; if (sh >= this.DB) sh -= this.DB } if (k == 8 && (s[0] & 128) != 0) { this.s = -1; if (sh > 0) this.data[this.t - 1] |= (1 << this.DB - sh) - 1 << sh } this.clamp(); if (mi) BigInteger.ZERO.subTo(this, this) } function bnpClamp() { var c = this.s & this.DM; while (this.t > 0 && this.data[this.t - 1] == c) --this.t } function bnToString(b) { if (this.s < 0) return "-" + this.negate().toString(b); var k; if (b == 16) k = 4; else if (b == 8) k = 3; else if (b == 2) k = 1; else if (b == 32) k = 5; else if (b == 4) k = 2; else return this.toRadix(b); var km = (1 << k) - 1, d, m = false, r = "", i = this.t; var p = this.DB - i * this.DB % k; if (i-- > 0) { if (p < this.DB && (d = this.data[i] >> p) > 0) { m = true; r = int2char(d) } while (i >= 0) { if (p < k) { d = (this.data[i] & (1 << p) - 1) << k - p; d |= this.data[--i] >> (p += this.DB - k) } else { d = this.data[i] >> (p -= k) & km; if (p <= 0) { p += this.DB; --i } } if (d > 0) m = true; if (m) r += int2char(d) } } return m ? r : "0" } function bnNegate() { var r = nbi(); BigInteger.ZERO.subTo(this, r); return r } function bnAbs() { return this.s < 0 ? this.negate() : this } function bnCompareTo(a) { var r = this.s - a.s; if (r != 0) return r; var i = this.t; r = i - a.t; if (r != 0) return this.s < 0 ? -r : r; while (--i >= 0) if ((r = this.data[i] - a.data[i]) != 0) return r; return 0 } function nbits(x) { var r = 1, t; if ((t = x >>> 16) != 0) { x = t; r += 16 } if ((t = x >> 8) != 0) { x = t; r += 8 } if ((t = x >> 4) != 0) { x = t; r += 4 } if ((t = x >> 2) != 0) { x = t; r += 2 } if ((t = x >> 1) != 0) { x = t; r += 1 } return r } function bnBitLength() { if (this.t <= 0) return 0; return this.DB * (this.t - 1) + nbits(this.data[this.t - 1] ^ this.s & this.DM) } function bnpDLShiftTo(n, r) { var i; for (i = this.t - 1; i >= 0; --i)r.data[i + n] = this.data[i]; for (i = n - 1; i >= 0; --i)r.data[i] = 0; r.t = this.t + n; r.s = this.s } function bnpDRShiftTo(n, r) { for (var i = n; i < this.t; ++i)r.data[i - n] = this.data[i]; r.t = Math.max(this.t - n, 0); r.s = this.s } function bnpLShiftTo(n, r) { var bs = n % this.DB; var cbs = this.DB - bs; var bm = (1 << cbs) - 1; var ds = Math.floor(n / this.DB), c = this.s << bs & this.DM, i; for (i = this.t - 1; i >= 0; --i) { r.data[i + ds + 1] = this.data[i] >> cbs | c; c = (this.data[i] & bm) << bs } for (i = ds - 1; i >= 0; --i)r.data[i] = 0; r.data[ds] = c; r.t = this.t + ds + 1; r.s = this.s; r.clamp() } function bnpRShiftTo(n, r) { r.s = this.s; var ds = Math.floor(n / this.DB); if (ds >= this.t) { r.t = 0; return } var bs = n % this.DB; var cbs = this.DB - bs; var bm = (1 << bs) - 1; r.data[0] = this.data[ds] >> bs; for (var i = ds + 1; i < this.t; ++i) { r.data[i - ds - 1] |= (this.data[i] & bm) << cbs; r.data[i - ds] = this.data[i] >> bs } if (bs > 0) r.data[this.t - ds - 1] |= (this.s & bm) << cbs; r.t = this.t - ds; r.clamp() } function bnpSubTo(a, r) { var i = 0, c = 0, m = Math.min(a.t, this.t); while (i < m) { c += this.data[i] - a.data[i]; r.data[i++] = c & this.DM; c >>= this.DB } if (a.t < this.t) { c -= a.s; while (i < this.t) { c += this.data[i]; r.data[i++] = c & this.DM; c >>= this.DB } c += this.s } else { c += this.s; while (i < a.t) { c -= a.data[i]; r.data[i++] = c & this.DM; c >>= this.DB } c -= a.s } r.s = c < 0 ? -1 : 0; if (c < -1) r.data[i++] = this.DV + c; else if (c > 0) r.data[i++] = c; r.t = i; r.clamp() } function bnpMultiplyTo(a, r) { var x = this.abs(), y = a.abs(); var i = x.t; r.t = i + y.t; while (--i >= 0) r.data[i] = 0; for (i = 0; i < y.t; ++i)r.data[i + x.t] = x.am(0, y.data[i], r, i, 0, x.t); r.s = 0; r.clamp(); if (this.s != a.s) BigInteger.ZERO.subTo(r, r) } function bnpSquareTo(r) { var x = this.abs(); var i = r.t = 2 * x.t; while (--i >= 0) r.data[i] = 0; for (i = 0; i < x.t - 1; ++i) { var c = x.am(i, x.data[i], r, 2 * i, 0, 1); if ((r.data[i + x.t] += x.am(i + 1, 2 * x.data[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV) { r.data[i + x.t] -= x.DV; r.data[i + x.t + 1] = 1 } } if (r.t > 0) r.data[r.t - 1] += x.am(i, x.data[i], r, 2 * i, 0, 1); r.s = 0; r.clamp() } function bnpDivRemTo(m, q, r) { var pm = m.abs(); if (pm.t <= 0) return; var pt = this.abs(); if (pt.t < pm.t) { if (q != null) q.fromInt(0); if (r != null) this.copyTo(r); return } if (r == null) r = nbi(); var y = nbi(), ts = this.s, ms = m.s; var nsh = this.DB - nbits(pm.data[pm.t - 1]); if (nsh > 0) { pm.lShiftTo(nsh, y); pt.lShiftTo(nsh, r) } else { pm.copyTo(y); pt.copyTo(r) } var ys = y.t; var y0 = y.data[ys - 1]; if (y0 == 0) return; var yt = y0 * (1 << this.F1) + (ys > 1 ? y.data[ys - 2] >> this.F2 : 0); var d1 = this.FV / yt, d2 = (1 << this.F1) / yt, e = 1 << this.F2; var i = r.t, j = i - ys, t = q == null ? nbi() : q; y.dlShiftTo(j, t); if (r.compareTo(t) >= 0) { r.data[r.t++] = 1; r.subTo(t, r) } BigInteger.ONE.dlShiftTo(ys, t); t.subTo(y, y); while (y.t < ys) y.data[y.t++] = 0; while (--j >= 0) { var qd = r.data[--i] == y0 ? this.DM : Math.floor(r.data[i] * d1 + (r.data[i - 1] + e) * d2); if ((r.data[i] += y.am(0, qd, r, j, 0, ys)) < qd) { y.dlShiftTo(j, t); r.subTo(t, r); while (r.data[i] < --qd) r.subTo(t, r) } } if (q != null) { r.drShiftTo(ys, q); if (ts != ms) BigInteger.ZERO.subTo(q, q) } r.t = ys; r.clamp(); if (nsh > 0) r.rShiftTo(nsh, r); if (ts < 0) BigInteger.ZERO.subTo(r, r) } function bnMod(a) { var r = nbi(); this.abs().divRemTo(a, null, r); if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r, r); return r } function Classic(m) { this.m = m } function cConvert(x) { if (x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m); else return x } function cRevert(x) { return x } function cReduce(x) { x.divRemTo(this.m, null, x) } function cMulTo(x, y, r) { x.multiplyTo(y, r); this.reduce(r) } function cSqrTo(x, r) { x.squareTo(r); this.reduce(r) } Classic.prototype.convert = cConvert; Classic.prototype.revert = cRevert; Classic.prototype.reduce = cReduce; Classic.prototype.mulTo = cMulTo; Classic.prototype.sqrTo = cSqrTo; function bnpInvDigit() { if (this.t < 1) return 0; var x = this.data[0]; if ((x & 1) == 0) return 0; var y = x & 3; y = y * (2 - (x & 15) * y) & 15; y = y * (2 - (x & 255) * y) & 255; y = y * (2 - ((x & 65535) * y & 65535)) & 65535; y = y * (2 - x * y % this.DV) % this.DV; return y > 0 ? this.DV - y : -y } function Montgomery(m) { this.m = m; this.mp = m.invDigit(); this.mpl = this.mp & 32767; this.mph = this.mp >> 15; this.um = (1 << m.DB - 15) - 1; this.mt2 = 2 * m.t } function montConvert(x) { var r = nbi(); x.abs().dlShiftTo(this.m.t, r); r.divRemTo(this.m, null, r); if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r, r); return r } function montRevert(x) { var r = nbi(); x.copyTo(r); this.reduce(r); return r } function montReduce(x) { while (x.t <= this.mt2) x.data[x.t++] = 0; for (var i = 0; i < this.m.t; ++i) { var j = x.data[i] & 32767; var u0 = j * this.mpl + ((j * this.mph + (x.data[i] >> 15) * this.mpl & this.um) << 15) & x.DM; j = i + this.m.t; x.data[j] += this.m.am(0, u0, x, i, 0, this.m.t); while (x.data[j] >= x.DV) { x.data[j] -= x.DV; x.data[++j]++ } } x.clamp(); x.drShiftTo(this.m.t, x); if (x.compareTo(this.m) >= 0) x.subTo(this.m, x) } function montSqrTo(x, r) { x.squareTo(r); this.reduce(r) } function montMulTo(x, y, r) { x.multiplyTo(y, r); this.reduce(r) } Montgomery.prototype.convert = montConvert; Montgomery.prototype.revert = montRevert; Montgomery.prototype.reduce = montReduce; Montgomery.prototype.mulTo = montMulTo; Montgomery.prototype.sqrTo = montSqrTo; function bnpIsEven() { return (this.t > 0 ? this.data[0] & 1 : this.s) == 0 } function bnpExp(e, z) { if (e > 4294967295 || e < 1) return BigInteger.ONE; var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e) - 1; g.copyTo(r); while (--i >= 0) { z.sqrTo(r, r2); if ((e & 1 << i) > 0) z.mulTo(r2, g, r); else { var t = r; r = r2; r2 = t } } return z.revert(r) } function bnModPowInt(e, m) { var z; if (e < 256 || m.isEven()) z = new Classic(m); else z = new Montgomery(m); return this.exp(e, z) } BigInteger.prototype.copyTo = bnpCopyTo; BigInteger.prototype.fromInt = bnpFromInt; BigInteger.prototype.fromString = bnpFromString; BigInteger.prototype.clamp = bnpClamp; BigInteger.prototype.dlShiftTo = bnpDLShiftTo; BigInteger.prototype.drShiftTo = bnpDRShiftTo; BigInteger.prototype.lShiftTo = bnpLShiftTo; BigInteger.prototype.rShiftTo = bnpRShiftTo; BigInteger.prototype.subTo = bnpSubTo; BigInteger.prototype.multiplyTo = bnpMultiplyTo; BigInteger.prototype.squareTo = bnpSquareTo; BigInteger.prototype.divRemTo = bnpDivRemTo; BigInteger.prototype.invDigit = bnpInvDigit; BigInteger.prototype.isEven = bnpIsEven; BigInteger.prototype.exp = bnpExp; BigInteger.prototype.toString = bnToString; BigInteger.prototype.negate = bnNegate; BigInteger.prototype.abs = bnAbs; BigInteger.prototype.compareTo = bnCompareTo; BigInteger.prototype.bitLength = bnBitLength; BigInteger.prototype.mod = bnMod; BigInteger.prototype.modPowInt = bnModPowInt; BigInteger.ZERO = nbv(0); BigInteger.ONE = nbv(1); function bnClone() { var r = nbi(); this.copyTo(r); return r } function bnIntValue() { if (this.s < 0) { if (this.t == 1) return this.data[0] - this.DV; else if (this.t == 0) return -1 } else if (this.t == 1) return this.data[0]; else if (this.t == 0) return 0; return (this.data[1] & (1 << 32 - this.DB) - 1) << this.DB | this.data[0] } function bnByteValue() { return this.t == 0 ? this.s : this.data[0] << 24 >> 24 } function bnShortValue() { return this.t == 0 ? this.s : this.data[0] << 16 >> 16 } function bnpChunkSize(r) { return Math.floor(Math.LN2 * this.DB / Math.log(r)) } function bnSigNum() { if (this.s < 0) return -1; else if (this.t <= 0 || this.t == 1 && this.data[0] <= 0) return 0; else return 1 } function bnpToRadix(b) { if (b == null) b = 10; if (this.signum() == 0 || b < 2 || b > 36) return "0"; var cs = this.chunkSize(b); var a = Math.pow(b, cs); var d = nbv(a), y = nbi(), z = nbi(), r = ""; this.divRemTo(d, y, z); while (y.signum() > 0) { r = (a + z.intValue()).toString(b).substr(1) + r; y.divRemTo(d, y, z) } return z.intValue().toString(b) + r } function bnpFromRadix(s, b) { this.fromInt(0); if (b == null) b = 10; var cs = this.chunkSize(b); var d = Math.pow(b, cs), mi = false, j = 0, w = 0; for (var i = 0; i < s.length; ++i) { var x = intAt(s, i); if (x < 0) { if (s.charAt(i) == "-" && this.signum() == 0) mi = true; continue } w = b * w + x; if (++j >= cs) { this.dMultiply(d); this.dAddOffset(w, 0); j = 0; w = 0 } } if (j > 0) { this.dMultiply(Math.pow(b, j)); this.dAddOffset(w, 0) } if (mi) BigInteger.ZERO.subTo(this, this) } function bnpFromNumber(a, b, c) { if ("number" == typeof b) { if (a < 2) this.fromInt(1); else { this.fromNumber(a, c); if (!this.testBit(a - 1)) this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this); if (this.isEven()) this.dAddOffset(1, 0); while (!this.isProbablePrime(b)) { this.dAddOffset(2, 0); if (this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a - 1), this) } } } else { var x = new Array, t = a & 7; x.length = (a >> 3) + 1; b.nextBytes(x); if (t > 0) x[0] &= (1 << t) - 1; else x[0] = 0; this.fromString(x, 256) } } function bnToByteArray() { var i = this.t, r = new Array; r[0] = this.s; var p = this.DB - i * this.DB % 8, d, k = 0; if (i-- > 0) { if (p < this.DB && (d = this.data[i] >> p) != (this.s & this.DM) >> p) r[k++] = d | this.s << this.DB - p; while (i >= 0) { if (p < 8) { d = (this.data[i] & (1 << p) - 1) << 8 - p; d |= this.data[--i] >> (p += this.DB - 8) } else { d = this.data[i] >> (p -= 8) & 255; if (p <= 0) { p += this.DB; --i } } if ((d & 128) != 0) d |= -256; if (k == 0 && (this.s & 128) != (d & 128)) ++k; if (k > 0 || d != this.s) r[k++] = d } } return r } function bnEquals(a) { return this.compareTo(a) == 0 } function bnMin(a) { return this.compareTo(a) < 0 ? this : a } function bnMax(a) { return this.compareTo(a) > 0 ? this : a } function bnpBitwiseTo(a, op, r) { var i, f, m = Math.min(a.t, this.t); for (i = 0; i < m; ++i)r.data[i] = op(this.data[i], a.data[i]); if (a.t < this.t) { f = a.s & this.DM; for (i = m; i < this.t; ++i)r.data[i] = op(this.data[i], f); r.t = this.t } else { f = this.s & this.DM; for (i = m; i < a.t; ++i)r.data[i] = op(f, a.data[i]); r.t = a.t } r.s = op(this.s, a.s); r.clamp() } function op_and(x, y) { return x & y } function bnAnd(a) { var r = nbi(); this.bitwiseTo(a, op_and, r); return r } function op_or(x, y) { return x | y } function bnOr(a) { var r = nbi(); this.bitwiseTo(a, op_or, r); return r } function op_xor(x, y) { return x ^ y } function bnXor(a) { var r = nbi(); this.bitwiseTo(a, op_xor, r); return r } function op_andnot(x, y) { return x & ~y } function bnAndNot(a) { var r = nbi(); this.bitwiseTo(a, op_andnot, r); return r } function bnNot() { var r = nbi(); for (var i = 0; i < this.t; ++i)r.data[i] = this.DM & ~this.data[i]; r.t = this.t; r.s = ~this.s; return r } function bnShiftLeft(n) { var r = nbi(); if (n < 0) this.rShiftTo(-n, r); else this.lShiftTo(n, r); return r } function bnShiftRight(n) { var r = nbi(); if (n < 0) this.lShiftTo(-n, r); else this.rShiftTo(n, r); return r } function lbit(x) { if (x == 0) return -1; var r = 0; if ((x & 65535) == 0) { x >>= 16; r += 16 } if ((x & 255) == 0) { x >>= 8; r += 8 } if ((x & 15) == 0) { x >>= 4; r += 4 } if ((x & 3) == 0) { x >>= 2; r += 2 } if ((x & 1) == 0) ++r; return r } function bnGetLowestSetBit() { for (var i = 0; i < this.t; ++i)if (this.data[i] != 0) return i * this.DB + lbit(this.data[i]); if (this.s < 0) return this.t * this.DB; return -1 } function cbit(x) { var r = 0; while (x != 0) { x &= x - 1; ++r } return r } function bnBitCount() { var r = 0, x = this.s & this.DM; for (var i = 0; i < this.t; ++i)r += cbit(this.data[i] ^ x); return r } function bnTestBit(n) { var j = Math.floor(n / this.DB); if (j >= this.t) return this.s != 0; return (this.data[j] & 1 << n % this.DB) != 0 } function bnpChangeBit(n, op) { var r = BigInteger.ONE.shiftLeft(n); this.bitwiseTo(r, op, r); return r } function bnSetBit(n) { return this.changeBit(n, op_or) } function bnClearBit(n) { return this.changeBit(n, op_andnot) } function bnFlipBit(n) { return this.changeBit(n, op_xor) } function bnpAddTo(a, r) { var i = 0, c = 0, m = Math.min(a.t, this.t); while (i < m) { c += this.data[i] + a.data[i]; r.data[i++] = c & this.DM; c >>= this.DB } if (a.t < this.t) { c += a.s; while (i < this.t) { c += this.data[i]; r.data[i++] = c & this.DM; c >>= this.DB } c += this.s } else { c += this.s; while (i < a.t) { c += a.data[i]; r.data[i++] = c & this.DM; c >>= this.DB } c += a.s } r.s = c < 0 ? -1 : 0; if (c > 0) r.data[i++] = c; else if (c < -1) r.data[i++] = this.DV + c; r.t = i; r.clamp() } function bnAdd(a) { var r = nbi(); this.addTo(a, r); return r } function bnSubtract(a) { var r = nbi(); this.subTo(a, r); return r } function bnMultiply(a) { var r = nbi(); this.multiplyTo(a, r); return r } function bnDivide(a) { var r = nbi(); this.divRemTo(a, r, null); return r } function bnRemainder(a) { var r = nbi(); this.divRemTo(a, null, r); return r } function bnDivideAndRemainder(a) { var q = nbi(), r = nbi(); this.divRemTo(a, q, r); return new Array(q, r) } function bnpDMultiply(n) { this.data[this.t] = this.am(0, n - 1, this, 0, 0, this.t); ++this.t; this.clamp() } function bnpDAddOffset(n, w) { if (n == 0) return; while (this.t <= w) this.data[this.t++] = 0; this.data[w] += n; while (this.data[w] >= this.DV) { this.data[w] -= this.DV; if (++w >= this.t) this.data[this.t++] = 0; ++this.data[w] } } function NullExp() { } function nNop(x) { return x } function nMulTo(x, y, r) { x.multiplyTo(y, r) } function nSqrTo(x, r) { x.squareTo(r) } NullExp.prototype.convert = nNop; NullExp.prototype.revert = nNop; NullExp.prototype.mulTo = nMulTo; NullExp.prototype.sqrTo = nSqrTo; function bnPow(e) { return this.exp(e, new NullExp) } function bnpMultiplyLowerTo(a, n, r) { var i = Math.min(this.t + a.t, n); r.s = 0; r.t = i; while (i > 0) r.data[--i] = 0; var j; for (j = r.t - this.t; i < j; ++i)r.data[i + this.t] = this.am(0, a.data[i], r, i, 0, this.t); for (j = Math.min(a.t, n); i < j; ++i)this.am(0, a.data[i], r, i, 0, n - i); r.clamp() } function bnpMultiplyUpperTo(a, n, r) { --n; var i = r.t = this.t + a.t - n; r.s = 0; while (--i >= 0) r.data[i] = 0; for (i = Math.max(n - this.t, 0); i < a.t; ++i)r.data[this.t + i - n] = this.am(n - i, a.data[i], r, 0, 0, this.t + i - n); r.clamp(); r.drShiftTo(1, r) } function Barrett(m) { this.r2 = nbi(); this.q3 = nbi(); BigInteger.ONE.dlShiftTo(2 * m.t, this.r2); this.mu = this.r2.divide(m); this.m = m } function barrettConvert(x) { if (x.s < 0 || x.t > 2 * this.m.t) return x.mod(this.m); else if (x.compareTo(this.m) < 0) return x; else { var r = nbi(); x.copyTo(r); this.reduce(r); return r } } function barrettRevert(x) { return x } function barrettReduce(x) { x.drShiftTo(this.m.t - 1, this.r2); if (x.t > this.m.t + 1) { x.t = this.m.t + 1; x.clamp() } this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3); this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2); while (x.compareTo(this.r2) < 0) x.dAddOffset(1, this.m.t + 1); x.subTo(this.r2, x); while (x.compareTo(this.m) >= 0) x.subTo(this.m, x) } function barrettSqrTo(x, r) { x.squareTo(r); this.reduce(r) } function barrettMulTo(x, y, r) { x.multiplyTo(y, r); this.reduce(r) } Barrett.prototype.convert = barrettConvert; Barrett.prototype.revert = barrettRevert; Barrett.prototype.reduce = barrettReduce; Barrett.prototype.mulTo = barrettMulTo; Barrett.prototype.sqrTo = barrettSqrTo; function bnModPow(e, m) { var i = e.bitLength(), k, r = nbv(1), z; if (i <= 0) return r; else if (i < 18) k = 1; else if (i < 48) k = 3; else if (i < 144) k = 4; else if (i < 768) k = 5; else k = 6; if (i < 8) z = new Classic(m); else if (m.isEven()) z = new Barrett(m); else z = new Montgomery(m); var g = new Array, n = 3, k1 = k - 1, km = (1 << k) - 1; g[1] = z.convert(this); if (k > 1) { var g2 = nbi(); z.sqrTo(g[1], g2); while (n <= km) { g[n] = nbi(); z.mulTo(g2, g[n - 2], g[n]); n += 2 } } var j = e.t - 1, w, is1 = true, r2 = nbi(), t; i = nbits(e.data[j]) - 1; while (j >= 0) { if (i >= k1) w = e.data[j] >> i - k1 & km; else { w = (e.data[j] & (1 << i + 1) - 1) << k1 - i; if (j > 0) w |= e.data[j - 1] >> this.DB + i - k1 } n = k; while ((w & 1) == 0) { w >>= 1; --n } if ((i -= n) < 0) { i += this.DB; --j } if (is1) { g[w].copyTo(r); is1 = false } else { while (n > 1) { z.sqrTo(r, r2); z.sqrTo(r2, r); n -= 2 } if (n > 0) z.sqrTo(r, r2); else { t = r; r = r2; r2 = t } z.mulTo(r2, g[w], r) } while (j >= 0 && (e.data[j] & 1 << i) == 0) { z.sqrTo(r, r2); t = r; r = r2; r2 = t; if (--i < 0) { i = this.DB - 1; --j } } } return z.revert(r) } function bnGCD(a) { var x = this.s < 0 ? this.negate() : this.clone(); var y = a.s < 0 ? a.negate() : a.clone(); if (x.compareTo(y) < 0) { var t = x; x = y; y = t } var i = x.getLowestSetBit(), g = y.getLowestSetBit(); if (g < 0) return x; if (i < g) g = i; if (g > 0) { x.rShiftTo(g, x); y.rShiftTo(g, y) } while (x.signum() > 0) { if ((i = x.getLowestSetBit()) > 0) x.rShiftTo(i, x); if ((i = y.getLowestSetBit()) > 0) y.rShiftTo(i, y); if (x.compareTo(y) >= 0) { x.subTo(y, x); x.rShiftTo(1, x) } else { y.subTo(x, y); y.rShiftTo(1, y) } } if (g > 0) y.lShiftTo(g, y); return y } function bnpModInt(n) { if (n <= 0) return 0; var d = this.DV % n, r = this.s < 0 ? n - 1 : 0; if (this.t > 0) if (d == 0) r = this.data[0] % n; else for (var i = this.t - 1; i >= 0; --i)r = (d * r + this.data[i]) % n; return r } function bnModInverse(m) { var ac = m.isEven(); if (this.isEven() && ac || m.signum() == 0) return BigInteger.ZERO; var u = m.clone(), v = this.clone(); var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1); while (u.signum() != 0) { while (u.isEven()) { u.rShiftTo(1, u); if (ac) { if (!a.isEven() || !b.isEven()) { a.addTo(this, a); b.subTo(m, b) } a.rShiftTo(1, a) } else if (!b.isEven()) b.subTo(m, b); b.rShiftTo(1, b) } while (v.isEven()) { v.rShiftTo(1, v); if (ac) { if (!c.isEven() || !d.isEven()) { c.addTo(this, c); d.subTo(m, d) } c.rShiftTo(1, c) } else if (!d.isEven()) d.subTo(m, d); d.rShiftTo(1, d) } if (u.compareTo(v) >= 0) { u.subTo(v, u); if (ac) a.subTo(c, a); b.subTo(d, b) } else { v.subTo(u, v); if (ac) c.subTo(a, c); d.subTo(b, d) } } if (v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO; if (d.compareTo(m) >= 0) return d.subtract(m); if (d.signum() < 0) d.addTo(m, d); else return d; if (d.signum() < 0) return d.add(m); else return d } var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509]; var lplim = (1 << 26) / lowprimes[lowprimes.length - 1]; function bnIsProbablePrime(t) { var i, x = this.abs(); if (x.t == 1 && x.data[0] <= lowprimes[lowprimes.length - 1]) { for (i = 0; i < lowprimes.length; ++i)if (x.data[0] == lowprimes[i]) return true; return false } if (x.isEven()) return false; i = 1; while (i < lowprimes.length) { var m = lowprimes[i], j = i + 1; while (j < lowprimes.length && m < lplim) m *= lowprimes[j++]; m = x.modInt(m); while (i < j) if (m % lowprimes[i++] == 0) return false } return x.millerRabin(t) } function bnpMillerRabin(t) { var n1 = this.subtract(BigInteger.ONE); var k = n1.getLowestSetBit(); if (k <= 0) return false; var r = n1.shiftRight(k); var prng = bnGetPrng(); var a; for (var i = 0; i < t; ++i) { do { a = new BigInteger(this.bitLength(), prng) } while (a.compareTo(BigInteger.ONE) <= 0 || a.compareTo(n1) >= 0); var y = a.modPow(r, this); if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) { var j = 1; while (j++ < k && y.compareTo(n1) != 0) { y = y.modPowInt(2, this); if (y.compareTo(BigInteger.ONE) == 0) return false } if (y.compareTo(n1) != 0) return false } } return true } function bnGetPrng() { return { nextBytes: function (x) { for (var i = 0; i < x.length; ++i) { x[i] = Math.floor(Math.random() * 256) } } } } BigInteger.prototype.chunkSize = bnpChunkSize; BigInteger.prototype.toRadix = bnpToRadix; BigInteger.prototype.fromRadix = bnpFromRadix; BigInteger.prototype.fromNumber = bnpFromNumber; BigInteger.prototype.bitwiseTo = bnpBitwiseTo; BigInteger.prototype.changeBit = bnpChangeBit; BigInteger.prototype.addTo = bnpAddTo; BigInteger.prototype.dMultiply = bnpDMultiply; BigInteger.prototype.dAddOffset = bnpDAddOffset; BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo; BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo; BigInteger.prototype.modInt = bnpModInt; BigInteger.prototype.millerRabin = bnpMillerRabin; BigInteger.prototype.clone = bnClone; BigInteger.prototype.intValue = bnIntValue; BigInteger.prototype.byteValue = bnByteValue; BigInteger.prototype.shortValue = bnShortValue; BigInteger.prototype.signum = bnSigNum; BigInteger.prototype.toByteArray = bnToByteArray; BigInteger.prototype.equals = bnEquals; BigInteger.prototype.min = bnMin; BigInteger.prototype.max = bnMax; BigInteger.prototype.and = bnAnd; BigInteger.prototype.or = bnOr; BigInteger.prototype.xor = bnXor; BigInteger.prototype.andNot = bnAndNot; BigInteger.prototype.not = bnNot; BigInteger.prototype.shiftLeft = bnShiftLeft; BigInteger.prototype.shiftRight = bnShiftRight; BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit; BigInteger.prototype.bitCount = bnBitCount; BigInteger.prototype.testBit = bnTestBit; BigInteger.prototype.setBit = bnSetBit; BigInteger.prototype.clearBit = bnClearBit; BigInteger.prototype.flipBit = bnFlipBit; BigInteger.prototype.add = bnAdd; BigInteger.prototype.subtract = bnSubtract; BigInteger.prototype.multiply = bnMultiply; BigInteger.prototype.divide = bnDivide; BigInteger.prototype.remainder = bnRemainder; BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder; BigInteger.prototype.modPow = bnModPow; BigInteger.prototype.modInverse = bnModInverse; BigInteger.prototype.pow = bnPow; BigInteger.prototype.gcd = bnGCD; BigInteger.prototype.isProbablePrime = bnIsProbablePrime }, { "./forge": 16 }], 20: [function (require, module, exports) { var forge = require("./forge"); require("./util"); require("./random"); require("./jsbn"); module.exports = forge.kem = forge.kem || {}; var BigInteger = forge.jsbn.BigInteger; forge.kem.rsa = {}; forge.kem.rsa.create = function (kdf, options) { options = options || {}; var prng = options.prng || forge.random; var kem = {}; kem.encrypt = function (publicKey, keyLength) { var byteLength = Math.ceil(publicKey.n.bitLength() / 8); var r; do { r = new BigInteger(forge.util.bytesToHex(prng.getBytesSync(byteLength)), 16).mod(publicKey.n) } while (r.compareTo(BigInteger.ONE) <= 0); r = forge.util.hexToBytes(r.toString(16)); var zeros = byteLength - r.length; if (zeros > 0) { r = forge.util.fillString(String.fromCharCode(0), zeros) + r } var encapsulation = publicKey.encrypt(r, "NONE"); var key = kdf.generate(r, keyLength); return { encapsulation: encapsulation, key: key } }; kem.decrypt = function (privateKey, encapsulation, keyLength) { var r = privateKey.decrypt(encapsulation, "NONE"); return kdf.generate(r, keyLength) }; return kem }; forge.kem.kdf1 = function (md, digestLength) { _createKDF(this, md, 0, digestLength || md.digestLength) }; forge.kem.kdf2 = function (md, digestLength) { _createKDF(this, md, 1, digestLength || md.digestLength) }; function _createKDF(kdf, md, counterStart, digestLength) { kdf.generate = function (x, length) { var key = new forge.util.ByteBuffer; var k = Math.ceil(length / digestLength) + counterStart; var c = new forge.util.ByteBuffer; for (var i = counterStart; i < k; ++i) { c.putInt32(i); md.start(); md.update(x + c.getBytes()); var hash = md.digest(); key.putBytes(hash.getBytes(digestLength)) } key.truncate(key.length() - length); return key.getBytes() } } }, { "./forge": 16, "./jsbn": 19, "./random": 39, "./util": 48 }], 21: [function (require, module, exports) { var forge = require("./forge"); require("./util"); module.exports = forge.log = forge.log || {}; forge.log.levels = ["none", "error", "warning", "info", "debug", "verbose", "max"]; var sLevelInfo = {}; var sLoggers = []; var sConsoleLogger = null; forge.log.LEVEL_LOCKED = 1 << 1; forge.log.NO_LEVEL_CHECK = 1 << 2; forge.log.INTERPOLATE = 1 << 3; for (var i = 0; i < forge.log.levels.length; ++i) { var level = forge.log.levels[i]; sLevelInfo[level] = { index: i, name: level.toUpperCase() } } forge.log.logMessage = function (message) { var messageLevelIndex = sLevelInfo[message.level].index; for (var i = 0; i < sLoggers.length; ++i) { var logger = sLoggers[i]; if (logger.flags & forge.log.NO_LEVEL_CHECK) { logger.f(message) } else { var loggerLevelIndex = sLevelInfo[logger.level].index; if (messageLevelIndex <= loggerLevelIndex) { logger.f(logger, message) } } } }; forge.log.prepareStandard = function (message) { if (!("standard" in message)) { message.standard = sLevelInfo[message.level].name + " [" + message.category + "] " + message.message } }; forge.log.prepareFull = function (message) { if (!("full" in message)) { var args = [message.message]; args = args.concat([] || message["arguments"]); message.full = forge.util.format.apply(this, args) } }; forge.log.prepareStandardFull = function (message) { if (!("standardFull" in message)) { forge.log.prepareStandard(message); message.standardFull = message.standard } }; if (true) { var levels = ["error", "warning", "info", "debug", "verbose"]; for (var i = 0; i < levels.length; ++i) { (function (level) { forge.log[level] = function (category, message) { var args = Array.prototype.slice.call(arguments).slice(2); var msg = { timestamp: new Date, level: level, category: category, message: message, arguments: args }; forge.log.logMessage(msg) } })(levels[i]) } } forge.log.makeLogger = function (logFunction) { var logger = { flags: 0, f: logFunction }; forge.log.setLevel(logger, "none"); return logger }; forge.log.setLevel = function (logger, level) { var rval = false; if (logger && !(logger.flags & forge.log.LEVEL_LOCKED)) { for (var i = 0; i < forge.log.levels.length; ++i) { var aValidLevel = forge.log.levels[i]; if (level == aValidLevel) { logger.level = level; rval = true; break } } } return rval }; forge.log.lock = function (logger, lock) { if (typeof lock === "undefined" || lock) { logger.flags |= forge.log.LEVEL_LOCKED } else { logger.flags &= ~forge.log.LEVEL_LOCKED } }; forge.log.addLogger = function (logger) { sLoggers.push(logger) }; if (typeof console !== "undefined" && "log" in console) { var logger; if (console.error && console.warn && console.info && console.debug) { var levelHandlers = { error: console.error, warning: console.warn, info: console.info, debug: console.debug, verbose: console.debug }; var f = function (logger, message) { forge.log.prepareStandard(message); var handler = levelHandlers[message.level]; var args = [message.standard]; args = args.concat(message["arguments"].slice()); handler.apply(console, args) }; logger = forge.log.makeLogger(f) } else { var f = function (logger, message) { forge.log.prepareStandardFull(message); console.log(message.standardFull) }; logger = forge.log.makeLogger(f) } forge.log.setLevel(logger, "debug"); forge.log.addLogger(logger); sConsoleLogger = logger } else { console = { log: function () { } } } if (sConsoleLogger !== null) { var query = forge.util.getQueryVariables(); if ("console.level" in query) { forge.log.setLevel(sConsoleLogger, query["console.level"].slice(-1)[0]) } if ("console.lock" in query) { var lock = query["console.lock"].slice(-1)[0]; if (lock == "true") { forge.log.lock(sConsoleLogger) } } } forge.log.consoleLogger = sConsoleLogger }, { "./forge": 16, "./util": 48 }], 22: [function (require, module, exports) { module.exports = require("./md"); require("./md5"); require("./sha1"); require("./sha256"); require("./sha512") }, { "./md": 23, "./md5": 24, "./sha1": 42, "./sha256": 43, "./sha512": 44 }], 23: [function (require, module, exports) { var forge = require("./forge"); module.exports = forge.md = forge.md || {}; forge.md.algorithms = forge.md.algorithms || {} }, { "./forge": 16 }], 24: [function (require, module, exports) { var forge = require("./forge"); require("./md"); require("./util"); var md5 = module.exports = forge.md5 = forge.md5 || {}; forge.md.md5 = forge.md.algorithms.md5 = md5; md5.create = function () { if (!_initialized) { _init() } var _state = null; var _input = forge.util.createBuffer(); var _w = new Array(16); var md = { algorithm: "md5", blockLength: 64, digestLength: 16, messageLength: 0, fullMessageLength: null, messageLengthSize: 8 }; md.start = function () { md.messageLength = 0; md.fullMessageLength = md.messageLength64 = []; var int32s = md.messageLengthSize / 4; for (var i = 0; i < int32s; ++i) { md.fullMessageLength.push(0) } _input = forge.util.createBuffer(); _state = { h0: 1732584193, h1: 4023233417, h2: 2562383102, h3: 271733878 }; return md }; md.start(); md.update = function (msg, encoding) { if (encoding === "utf8") { msg = forge.util.encodeUtf8(msg) } var len = msg.length; md.messageLength += len; len = [len / 4294967296 >>> 0, len >>> 0]; for (var i = md.fullMessageLength.length - 1; i >= 0; --i) { md.fullMessageLength[i] += len[1]; len[1] = len[0] + (md.fullMessageLength[i] / 4294967296 >>> 0); md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0; len[0] = len[1] / 4294967296 >>> 0 } _input.putBytes(msg); _update(_state, _w, _input); if (_input.read > 2048 || _input.length() === 0) { _input.compact() } return md }; md.digest = function () { var finalBlock = forge.util.createBuffer(); finalBlock.putBytes(_input.bytes()); var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize; var overflow = remaining & md.blockLength - 1; finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow)); var bits, carry = 0; for (var i = md.fullMessageLength.length - 1; i >= 0; --i) { bits = md.fullMessageLength[i] * 8 + carry; carry = bits / 4294967296 >>> 0; finalBlock.putInt32Le(bits >>> 0) } var s2 = { h0: _state.h0, h1: _state.h1, h2: _state.h2, h3: _state.h3 }; _update(s2, _w, finalBlock); var rval = forge.util.createBuffer(); rval.putInt32Le(s2.h0); rval.putInt32Le(s2.h1); rval.putInt32Le(s2.h2); rval.putInt32Le(s2.h3); return rval }; return md }; var _padding = null; var _g = null; var _r = null; var _k = null; var _initialized = false; function _init() { _padding = String.fromCharCode(128); _padding += forge.util.fillString(String.fromCharCode(0), 64); _g = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 1, 6, 11, 0, 5, 10, 15, 4, 9, 14, 3, 8, 13, 2, 7, 12, 5, 8, 11, 14, 1, 4, 7, 10, 13, 0, 3, 6, 9, 12, 15, 2, 0, 7, 14, 5, 12, 3, 10, 1, 8, 15, 6, 13, 4, 11, 2, 9]; _r = [7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21]; _k = new Array(64); for (var i = 0; i < 64; ++i) { _k[i] = Math.floor(Math.abs(Math.sin(i + 1)) * 4294967296) } _initialized = true } function _update(s, w, bytes) { var t, a, b, c, d, f, r, i; var len = bytes.length(); while (len >= 64) { a = s.h0; b = s.h1; c = s.h2; d = s.h3; for (i = 0; i < 16; ++i) { w[i] = bytes.getInt32Le(); f = d ^ b & (c ^ d); t = a + f + _k[i] + w[i]; r = _r[i]; a = d; d = c; c = b; b += t << r | t >>> 32 - r } for (; i < 32; ++i) { f = c ^ d & (b ^ c); t = a + f + _k[i] + w[_g[i]]; r = _r[i]; a = d; d = c; c = b; b += t << r | t >>> 32 - r } for (; i < 48; ++i) { f = b ^ c ^ d; t = a + f + _k[i] + w[_g[i]]; r = _r[i]; a = d; d = c; c = b; b += t << r | t >>> 32 - r } for (; i < 64; ++i) { f = c ^ (b | ~d); t = a + f + _k[i] + w[_g[i]]; r = _r[i]; a = d; d = c; c = b; b += t << r | t >>> 32 - r } s.h0 = s.h0 + a | 0; s.h1 = s.h1 + b | 0; s.h2 = s.h2 + c | 0; s.h3 = s.h3 + d | 0; len -= 64 } } }, { "./forge": 16, "./md": 23, "./util": 48 }], 25: [function (require, module, exports) { var forge = require("./forge"); require("./mgf1"); module.exports = forge.mgf = forge.mgf || {}; forge.mgf.mgf1 = forge.mgf1 }, { "./forge": 16, "./mgf1": 26 }], 26: [function (require, module, exports) { var forge = require("./forge"); require("./util"); forge.mgf = forge.mgf || {}; var mgf1 = module.exports = forge.mgf.mgf1 = forge.mgf1 = forge.mgf1 || {}; mgf1.create = function (md) { var mgf = { generate: function (seed, maskLen) { var t = new forge.util.ByteBuffer; var len = Math.ceil(maskLen / md.digestLength); for (var i = 0; i < len; i++) { var c = new forge.util.ByteBuffer; c.putInt32(i); md.start(); md.update(seed + c.getBytes()); t.putBuffer(md.digest()) } t.truncate(t.length() - maskLen); return t.getBytes() } }; return mgf } }, { "./forge": 16, "./util": 48 }], 27: [function (require, module, exports) { var forge = require("./forge"); forge.pki = forge.pki || {}; var oids = module.exports = forge.pki.oids = forge.oids = forge.oids || {}; function _IN(id, name) { oids[id] = name; oids[name] = id } function _I_(id, name) { oids[id] = name } _IN("1.2.840.113549.1.1.1", "rsaEncryption"); _IN("1.2.840.113549.1.1.4", "md5WithRSAEncryption"); _IN("1.2.840.113549.1.1.5", "sha1WithRSAEncryption"); _IN("1.2.840.113549.1.1.7", "RSAES-OAEP"); _IN("1.2.840.113549.1.1.8", "mgf1"); _IN("1.2.840.113549.1.1.9", "pSpecified"); _IN("1.2.840.113549.1.1.10", "RSASSA-PSS"); _IN("1.2.840.113549.1.1.11", "sha256WithRSAEncryption"); _IN("1.2.840.113549.1.1.12", "sha384WithRSAEncryption"); _IN("1.2.840.113549.1.1.13", "sha512WithRSAEncryption"); _IN("1.2.840.10040.4.3", "dsa-with-sha1"); _IN("1.3.14.3.2.7", "desCBC"); _IN("1.3.14.3.2.26", "sha1"); _IN("2.16.840.1.101.3.4.2.1", "sha256"); _IN("2.16.840.1.101.3.4.2.2", "sha384"); _IN("2.16.840.1.101.3.4.2.3", "sha512"); _IN("1.2.840.113549.2.5", "md5"); _IN("1.2.840.113549.1.7.1", "data"); _IN("1.2.840.113549.1.7.2", "signedData"); _IN("1.2.840.113549.1.7.3", "envelopedData"); _IN("1.2.840.113549.1.7.4", "signedAndEnvelopedData"); _IN("1.2.840.113549.1.7.5", "digestedData"); _IN("1.2.840.113549.1.7.6", "encryptedData"); _IN("1.2.840.113549.1.9.1", "emailAddress"); _IN("1.2.840.113549.1.9.2", "unstructuredName"); _IN("1.2.840.113549.1.9.3", "contentType"); _IN("1.2.840.113549.1.9.4", "messageDigest"); _IN("1.2.840.113549.1.9.5", "signingTime"); _IN("1.2.840.113549.1.9.6", "counterSignature"); _IN("1.2.840.113549.1.9.7", "challengePassword"); _IN("1.2.840.113549.1.9.8", "unstructuredAddress"); _IN("1.2.840.113549.1.9.14", "extensionRequest"); _IN("1.2.840.113549.1.9.20", "friendlyName"); _IN("1.2.840.113549.1.9.21", "localKeyId"); _IN("1.2.840.113549.1.9.22.1", "x509Certificate"); _IN("1.2.840.113549.1.12.10.1.1", "keyBag"); _IN("1.2.840.113549.1.12.10.1.2", "pkcs8ShroudedKeyBag"); _IN("1.2.840.113549.1.12.10.1.3", "certBag"); _IN("1.2.840.113549.1.12.10.1.4", "crlBag"); _IN("1.2.840.113549.1.12.10.1.5", "secretBag"); _IN("1.2.840.113549.1.12.10.1.6", "safeContentsBag"); _IN("1.2.840.113549.1.5.13", "pkcs5PBES2"); _IN("1.2.840.113549.1.5.12", "pkcs5PBKDF2"); _IN("1.2.840.113549.1.12.1.1", "pbeWithSHAAnd128BitRC4"); _IN("1.2.840.113549.1.12.1.2", "pbeWithSHAAnd40BitRC4"); _IN("1.2.840.113549.1.12.1.3", "pbeWithSHAAnd3-KeyTripleDES-CBC"); _IN("1.2.840.113549.1.12.1.4", "pbeWithSHAAnd2-KeyTripleDES-CBC"); _IN("1.2.840.113549.1.12.1.5", "pbeWithSHAAnd128BitRC2-CBC"); _IN("1.2.840.113549.1.12.1.6", "pbewithSHAAnd40BitRC2-CBC"); _IN("1.2.840.113549.2.7", "hmacWithSHA1"); _IN("1.2.840.113549.2.8", "hmacWithSHA224"); _IN("1.2.840.113549.2.9", "hmacWithSHA256"); _IN("1.2.840.113549.2.10", "hmacWithSHA384"); _IN("1.2.840.113549.2.11", "hmacWithSHA512"); _IN("1.2.840.113549.3.7", "des-EDE3-CBC"); _IN("2.16.840.1.101.3.4.1.2", "aes128-CBC"); _IN("2.16.840.1.101.3.4.1.22", "aes192-CBC"); _IN("2.16.840.1.101.3.4.1.42", "aes256-CBC"); _IN("2.5.4.3", "commonName"); _IN("2.5.4.5", "serialName"); _IN("2.5.4.6", "countryName"); _IN("2.5.4.7", "localityName"); _IN("2.5.4.8", "stateOrProvinceName"); _IN("2.5.4.10", "organizationName"); _IN("2.5.4.11", "organizationalUnitName"); _IN("2.5.4.13", "description"); _IN("2.16.840.1.113730.1.1", "nsCertType"); _IN("2.16.840.1.113730.1.13", "nsComment"); _I_("2.5.29.1", "authorityKeyIdentifier"); _I_("2.5.29.2", "keyAttributes"); _I_("2.5.29.3", "certificatePolicies"); _I_("2.5.29.4", "keyUsageRestriction"); _I_("2.5.29.5", "policyMapping"); _I_("2.5.29.6", "subtreesConstraint"); _I_("2.5.29.7", "subjectAltName"); _I_("2.5.29.8", "issuerAltName"); _I_("2.5.29.9", "subjectDirectoryAttributes"); _I_("2.5.29.10", "basicConstraints"); _I_("2.5.29.11", "nameConstraints"); _I_("2.5.29.12", "policyConstraints"); _I_("2.5.29.13", "basicConstraints"); _IN("2.5.29.14", "subjectKeyIdentifier"); _IN("2.5.29.15", "keyUsage"); _I_("2.5.29.16", "privateKeyUsagePeriod"); _IN("2.5.29.17", "subjectAltName"); _IN("2.5.29.18", "issuerAltName"); _IN("2.5.29.19", "basicConstraints"); _I_("2.5.29.20", "cRLNumber"); _I_("2.5.29.21", "cRLReason"); _I_("2.5.29.22", "expirationDate"); _I_("2.5.29.23", "instructionCode"); _I_("2.5.29.24", "invalidityDate"); _I_("2.5.29.25", "cRLDistributionPoints"); _I_("2.5.29.26", "issuingDistributionPoint"); _I_("2.5.29.27", "deltaCRLIndicator"); _I_("2.5.29.28", "issuingDistributionPoint"); _I_("2.5.29.29", "certificateIssuer"); _I_("2.5.29.30", "nameConstraints"); _IN("2.5.29.31", "cRLDistributionPoints"); _IN("2.5.29.32", "certificatePolicies"); _I_("2.5.29.33", "policyMappings"); _I_("2.5.29.34", "policyConstraints"); _IN("2.5.29.35", "authorityKeyIdentifier"); _I_("2.5.29.36", "policyConstraints"); _IN("2.5.29.37", "extKeyUsage"); _I_("2.5.29.46", "freshestCRL"); _I_("2.5.29.54", "inhibitAnyPolicy"); _IN("1.3.6.1.4.1.11129.2.4.2", "timestampList"); _IN("1.3.6.1.5.5.7.1.1", "authorityInfoAccess"); _IN("1.3.6.1.5.5.7.3.1", "serverAuth"); _IN("1.3.6.1.5.5.7.3.2", "clientAuth"); _IN("1.3.6.1.5.5.7.3.3", "codeSigning"); _IN("1.3.6.1.5.5.7.3.4", "emailProtection"); _IN("1.3.6.1.5.5.7.3.8", "timeStamping") }, { "./forge": 16 }], 28: [function (require, module, exports) { var forge = require("./forge"); require("./aes"); require("./asn1"); require("./des"); require("./md"); require("./oids"); require("./pbkdf2"); require("./pem"); require("./random"); require("./rc2"); require("./rsa"); require("./util"); if (typeof BigInteger === "undefined") { var BigInteger = forge.jsbn.BigInteger } var asn1 = forge.asn1; var pki = forge.pki = forge.pki || {}; module.exports = pki.pbe = forge.pbe = forge.pbe || {}; var oids = pki.oids; var encryptedPrivateKeyValidator = { name: "EncryptedPrivateKeyInfo", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.SEQUENCE, constructed: true, value: [{ name: "EncryptedPrivateKeyInfo.encryptionAlgorithm", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.SEQUENCE, constructed: true, value: [{ name: "AlgorithmIdentifier.algorithm", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.OID, constructed: false, capture: "encryptionOid" }, { name: "AlgorithmIdentifier.parameters", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.SEQUENCE, constructed: true, captureAsn1: "encryptionParams" }] }, { name: "EncryptedPrivateKeyInfo.encryptedData", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.OCTETSTRING, constructed: false, capture: "encryptedData" }] }; var PBES2AlgorithmsValidator = { name: "PBES2Algorithms", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.SEQUENCE, constructed: true, value: [{ name: "PBES2Algorithms.keyDerivationFunc", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.SEQUENCE, constructed: true, value: [{ name: "PBES2Algorithms.keyDerivationFunc.oid", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.OID, constructed: false, capture: "kdfOid" }, { name: "PBES2Algorithms.params", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.SEQUENCE, constructed: true, value: [{ name: "PBES2Algorithms.params.salt", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.OCTETSTRING, constructed: false, capture: "kdfSalt" }, { name: "PBES2Algorithms.params.iterationCount", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.INTEGER, constructed: false, capture: "kdfIterationCount" }, { name: "PBES2Algorithms.params.keyLength", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.INTEGER, constructed: false, optional: true, capture: "keyLength" }, { name: "PBES2Algorithms.params.prf", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.SEQUENCE, constructed: true, optional: true, value: [{ name: "PBES2Algorithms.params.prf.algorithm", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.OID, constructed: false, capture: "prfOid" }] }] }] }, { name: "PBES2Algorithms.encryptionScheme", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.SEQUENCE, constructed: true, value: [{ name: "PBES2Algorithms.encryptionScheme.oid", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.OID, constructed: false, capture: "encOid" }, { name: "PBES2Algorithms.encryptionScheme.iv", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.OCTETSTRING, constructed: false, capture: "encIv" }] }] }; var pkcs12PbeParamsValidator = { name: "pkcs-12PbeParams", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.SEQUENCE, constructed: true, value: [{ name: "pkcs-12PbeParams.salt", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.OCTETSTRING, constructed: false, capture: "salt" }, { name: "pkcs-12PbeParams.iterations", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.INTEGER, constructed: false, capture: "iterations" }] }; pki.encryptPrivateKeyInfo = function (obj, password, options) { options = options || {}; options.saltSize = options.saltSize || 8; options.count = options.count || 2048; options.algorithm = options.algorithm || "aes128"; options.prfAlgorithm = options.prfAlgorithm || "sha1"; var salt = forge.random.getBytesSync(options.saltSize); var count = options.count; var countBytes = asn1.integerToDer(count); var dkLen; var encryptionAlgorithm; var encryptedData; if (options.algorithm.indexOf("aes") === 0 || options.algorithm === "des") { var ivLen, encOid, cipherFn; switch (options.algorithm) { case "aes128": dkLen = 16; ivLen = 16; encOid = oids["aes128-CBC"]; cipherFn = forge.aes.createEncryptionCipher; break; case "aes192": dkLen = 24; ivLen = 16; encOid = oids["aes192-CBC"]; cipherFn = forge.aes.createEncryptionCipher; break; case "aes256": dkLen = 32; ivLen = 16; encOid = oids["aes256-CBC"]; cipherFn = forge.aes.createEncryptionCipher; break; case "des": dkLen = 8; ivLen = 8; encOid = oids["desCBC"]; cipherFn = forge.des.createEncryptionCipher; break; default: var error = new Error("Cannot encrypt private key. Unknown encryption algorithm."); error.algorithm = options.algorithm; throw error }var prfAlgorithm = "hmacWith" + options.prfAlgorithm.toUpperCase(); var md = prfAlgorithmToMessageDigest(prfAlgorithm); var dk = forge.pkcs5.pbkdf2(password, salt, count, dkLen, md); var iv = forge.random.getBytesSync(ivLen); var cipher = cipherFn(dk); cipher.start(iv); cipher.update(asn1.toDer(obj)); cipher.finish(); encryptedData = cipher.output.getBytes(); var params = createPbkdf2Params(salt, countBytes, dkLen, prfAlgorithm); encryptionAlgorithm = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(oids["pkcs5PBES2"]).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(oids["pkcs5PBKDF2"]).getBytes()), params]), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(encOid).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, iv)])])]) } else if (options.algorithm === "3des") { dkLen = 24; var saltBytes = new forge.util.ByteBuffer(salt); var dk = pki.pbe.generatePkcs12Key(password, saltBytes, 1, count, dkLen); var iv = pki.pbe.generatePkcs12Key(password, saltBytes, 2, count, dkLen); var cipher = forge.des.createEncryptionCipher(dk); cipher.start(iv); cipher.update(asn1.toDer(obj)); cipher.finish(); encryptedData = cipher.output.getBytes(); encryptionAlgorithm = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, salt), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, countBytes.getBytes())])]) } else { var error = new Error("Cannot encrypt private key. Unknown encryption algorithm."); error.algorithm = options.algorithm; throw error } var rval = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [encryptionAlgorithm, asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, encryptedData)]); return rval }; pki.decryptPrivateKeyInfo = function (obj, password) { var rval = null; var capture = {}; var errors = []; if (!asn1.validate(obj, encryptedPrivateKeyValidator, capture, errors)) { var error = new Error("Cannot read encrypted private key. " + "ASN.1 object is not a supported EncryptedPrivateKeyInfo."); error.errors = errors; throw error } var oid = asn1.derToOid(capture.encryptionOid); var cipher = pki.pbe.getCipher(oid, capture.encryptionParams, password); var encrypted = forge.util.createBuffer(capture.encryptedData); cipher.update(encrypted); if (cipher.finish()) { rval = asn1.fromDer(cipher.output) } return rval }; pki.encryptedPrivateKeyToPem = function (epki, maxline) { var msg = { type: "ENCRYPTED PRIVATE KEY", body: asn1.toDer(epki).getBytes() }; return forge.pem.encode(msg, { maxline: maxline }) }; pki.encryptedPrivateKeyFromPem = function (pem) { var msg = forge.pem.decode(pem)[0]; if (msg.type !== "ENCRYPTED PRIVATE KEY") { var error = new Error("Could not convert encrypted private key from PEM; " + 'PEM header type is "ENCRYPTED PRIVATE KEY".'); error.headerType = msg.type; throw error } if (msg.procType && msg.procType.type === "ENCRYPTED") { throw new Error("Could not convert encrypted private key from PEM; " + "PEM is encrypted.") } return asn1.fromDer(msg.body) }; pki.encryptRsaPrivateKey = function (rsaKey, password, options) { options = options || {}; if (!options.legacy) { var rval = pki.wrapRsaPrivateKey(pki.privateKeyToAsn1(rsaKey)); rval = pki.encryptPrivateKeyInfo(rval, password, options); return pki.encryptedPrivateKeyToPem(rval) } var algorithm; var iv; var dkLen; var cipherFn; switch (options.algorithm) { case "aes128": algorithm = "AES-128-CBC"; dkLen = 16; iv = forge.random.getBytesSync(16); cipherFn = forge.aes.createEncryptionCipher; break; case "aes192": algorithm = "AES-192-CBC"; dkLen = 24; iv = forge.random.getBytesSync(16); cipherFn = forge.aes.createEncryptionCipher; break; case "aes256": algorithm = "AES-256-CBC"; dkLen = 32; iv = forge.random.getBytesSync(16); cipherFn = forge.aes.createEncryptionCipher; break; case "3des": algorithm = "DES-EDE3-CBC"; dkLen = 24; iv = forge.random.getBytesSync(8); cipherFn = forge.des.createEncryptionCipher; break; case "des": algorithm = "DES-CBC"; dkLen = 8; iv = forge.random.getBytesSync(8); cipherFn = forge.des.createEncryptionCipher; break; default: var error = new Error("Could not encrypt RSA private key; unsupported " + 'encryption algorithm "' + options.algorithm + '".'); error.algorithm = options.algorithm; throw error }var dk = forge.pbe.opensslDeriveBytes(password, iv.substr(0, 8), dkLen); var cipher = cipherFn(dk); cipher.start(iv); cipher.update(asn1.toDer(pki.privateKeyToAsn1(rsaKey))); cipher.finish(); var msg = { type: "RSA PRIVATE KEY", procType: { version: "4", type: "ENCRYPTED" }, dekInfo: { algorithm: algorithm, parameters: forge.util.bytesToHex(iv).toUpperCase() }, body: cipher.output.getBytes() }; return forge.pem.encode(msg) }; pki.decryptRsaPrivateKey = function (pem, password) { var rval = null; var msg = forge.pem.decode(pem)[0]; if (msg.type !== "ENCRYPTED PRIVATE KEY" && msg.type !== "PRIVATE KEY" && msg.type !== "RSA PRIVATE KEY") { var error = new Error("Could not convert private key from PEM; PEM header type " + 'is not "ENCRYPTED PRIVATE KEY", "PRIVATE KEY", or "RSA PRIVATE KEY".'); error.headerType = error; throw error } if (msg.procType && msg.procType.type === "ENCRYPTED") { var dkLen; var cipherFn; switch (msg.dekInfo.algorithm) { case "DES-CBC": dkLen = 8; cipherFn = forge.des.createDecryptionCipher; break; case "DES-EDE3-CBC": dkLen = 24; cipherFn = forge.des.createDecryptionCipher; break; case "AES-128-CBC": dkLen = 16; cipherFn = forge.aes.createDecryptionCipher; break; case "AES-192-CBC": dkLen = 24; cipherFn = forge.aes.createDecryptionCipher; break; case "AES-256-CBC": dkLen = 32; cipherFn = forge.aes.createDecryptionCipher; break; case "RC2-40-CBC": dkLen = 5; cipherFn = function (key) { return forge.rc2.createDecryptionCipher(key, 40) }; break; case "RC2-64-CBC": dkLen = 8; cipherFn = function (key) { return forge.rc2.createDecryptionCipher(key, 64) }; break; case "RC2-128-CBC": dkLen = 16; cipherFn = function (key) { return forge.rc2.createDecryptionCipher(key, 128) }; break; default: var error = new Error("Could not decrypt private key; unsupported " + 'encryption algorithm "' + msg.dekInfo.algorithm + '".'); error.algorithm = msg.dekInfo.algorithm; throw error }var iv = forge.util.hexToBytes(msg.dekInfo.parameters); var dk = forge.pbe.opensslDeriveBytes(password, iv.substr(0, 8), dkLen); var cipher = cipherFn(dk); cipher.start(iv); cipher.update(forge.util.createBuffer(msg.body)); if (cipher.finish()) { rval = cipher.output.getBytes() } else { return rval } } else { rval = msg.body } if (msg.type === "ENCRYPTED PRIVATE KEY") { rval = pki.decryptPrivateKeyInfo(asn1.fromDer(rval), password) } else { rval = asn1.fromDer(rval) } if (rval !== null) { rval = pki.privateKeyFromAsn1(rval) } return rval }; pki.pbe.generatePkcs12Key = function (password, salt, id, iter, n, md) { var j, l; if (typeof md === "undefined" || md === null) { if (!("sha1" in forge.md)) { throw new Error('"sha1" hash algorithm unavailable.') } md = forge.md.sha1.create() } var u = md.digestLength; var v = md.blockLength; var result = new forge.util.ByteBuffer; var passBuf = new forge.util.ByteBuffer; if (password !== null && password !== undefined) { for (l = 0; l < password.length; l++) { passBuf.putInt16(password.charCodeAt(l)) } passBuf.putInt16(0) } var p = passBuf.length(); var s = salt.length(); var D = new forge.util.ByteBuffer; D.fillWithByte(id, v); var Slen = v * Math.ceil(s / v); var S = new forge.util.ByteBuffer; for (l = 0; l < Slen; l++) { S.putByte(salt.at(l % s)) } var Plen = v * Math.ceil(p / v); var P = new forge.util.ByteBuffer; for (l = 0; l < Plen; l++) { P.putByte(passBuf.at(l % p)) } var I = S; I.putBuffer(P); var c = Math.ceil(n / u); for (var i = 1; i <= c; i++) { var buf = new forge.util.ByteBuffer; buf.putBytes(D.bytes()); buf.putBytes(I.bytes()); for (var round = 0; round < iter; round++) { md.start(); md.update(buf.getBytes()); buf = md.digest() } var B = new forge.util.ByteBuffer; for (l = 0; l < v; l++) { B.putByte(buf.at(l % u)) } var k = Math.ceil(s / v) + Math.ceil(p / v); var Inew = new forge.util.ByteBuffer; for (j = 0; j < k; j++) { var chunk = new forge.util.ByteBuffer(I.getBytes(v)); var x = 511; for (l = B.length() - 1; l >= 0; l--) { x = x >> 8; x += B.at(l) + chunk.at(l); chunk.setAt(l, x & 255) } Inew.putBuffer(chunk) } I = Inew; result.putBuffer(buf) } result.truncate(result.length() - n); return result }; pki.pbe.getCipher = function (oid, params, password) { switch (oid) { case pki.oids["pkcs5PBES2"]: return pki.pbe.getCipherForPBES2(oid, params, password); case pki.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]: case pki.oids["pbewithSHAAnd40BitRC2-CBC"]: return pki.pbe.getCipherForPKCS12PBE(oid, params, password); default: var error = new Error("Cannot read encrypted PBE data block. Unsupported OID."); error.oid = oid; error.supportedOids = ["pkcs5PBES2", "pbeWithSHAAnd3-KeyTripleDES-CBC", "pbewithSHAAnd40BitRC2-CBC"]; throw error } }; pki.pbe.getCipherForPBES2 = function (oid, params, password) { var capture = {}; var errors = []; if (!asn1.validate(params, PBES2AlgorithmsValidator, capture, errors)) { var error = new Error("Cannot read password-based-encryption algorithm " + "parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo."); error.errors = errors; throw error } oid = asn1.derToOid(capture.kdfOid); if (oid !== pki.oids["pkcs5PBKDF2"]) { var error = new Error("Cannot read encrypted private key. " + "Unsupported key derivation function OID."); error.oid = oid; error.supportedOids = ["pkcs5PBKDF2"]; throw error } oid = asn1.derToOid(capture.encOid); if (oid !== pki.oids["aes128-CBC"] && oid !== pki.oids["aes192-CBC"] && oid !== pki.oids["aes256-CBC"] && oid !== pki.oids["des-EDE3-CBC"] && oid !== pki.oids["desCBC"]) { var error = new Error("Cannot read encrypted private key. " + "Unsupported encryption scheme OID."); error.oid = oid; error.supportedOids = ["aes128-CBC", "aes192-CBC", "aes256-CBC", "des-EDE3-CBC", "desCBC"]; throw error } var salt = capture.kdfSalt; var count = forge.util.createBuffer(capture.kdfIterationCount); count = count.getInt(count.length() << 3); var dkLen; var cipherFn; switch (pki.oids[oid]) { case "aes128-CBC": dkLen = 16; cipherFn = forge.aes.createDecryptionCipher; break; case "aes192-CBC": dkLen = 24; cipherFn = forge.aes.createDecryptionCipher; break; case "aes256-CBC": dkLen = 32; cipherFn = forge.aes.createDecryptionCipher; break; case "des-EDE3-CBC": dkLen = 24; cipherFn = forge.des.createDecryptionCipher; break; case "desCBC": dkLen = 8; cipherFn = forge.des.createDecryptionCipher; break }var md = prfOidToMessageDigest(capture.prfOid); var dk = forge.pkcs5.pbkdf2(password, salt, count, dkLen, md); var iv = capture.encIv; var cipher = cipherFn(dk); cipher.start(iv); return cipher }; pki.pbe.getCipherForPKCS12PBE = function (oid, params, password) { var capture = {}; var errors = []; if (!asn1.validate(params, pkcs12PbeParamsValidator, capture, errors)) { var error = new Error("Cannot read password-based-encryption algorithm " + "parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo."); error.errors = errors; throw error } var salt = forge.util.createBuffer(capture.salt); var count = forge.util.createBuffer(capture.iterations); count = count.getInt(count.length() << 3); var dkLen, dIvLen, cipherFn; switch (oid) { case pki.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]: dkLen = 24; dIvLen = 8; cipherFn = forge.des.startDecrypting; break; case pki.oids["pbewithSHAAnd40BitRC2-CBC"]: dkLen = 5; dIvLen = 8; cipherFn = function (key, iv) { var cipher = forge.rc2.createDecryptionCipher(key, 40); cipher.start(iv, null); return cipher }; break; default: var error = new Error("Cannot read PKCS #12 PBE data block. Unsupported OID."); error.oid = oid; throw error }var md = prfOidToMessageDigest(capture.prfOid); var key = pki.pbe.generatePkcs12Key(password, salt, 1, count, dkLen, md); md.start(); var iv = pki.pbe.generatePkcs12Key(password, salt, 2, count, dIvLen, md); return cipherFn(key, iv) }; pki.pbe.opensslDeriveBytes = function (password, salt, dkLen, md) { if (typeof md === "undefined" || md === null) { if (!("md5" in forge.md)) { throw new Error('"md5" hash algorithm unavailable.') } md = forge.md.md5.create() } if (salt === null) { salt = "" } var digests = [hash(md, password + salt)]; for (var length = 16, i = 1; length < dkLen; ++i, length += 16) { digests.push(hash(md, digests[i - 1] + password + salt)) } return digests.join("").substr(0, dkLen) }; function hash(md, bytes) { return md.start().update(bytes).digest().getBytes() } function prfOidToMessageDigest(prfOid) { var prfAlgorithm; if (!prfOid) { prfAlgorithm = "hmacWithSHA1" } else { prfAlgorithm = pki.oids[asn1.derToOid(prfOid)]; if (!prfAlgorithm) { var error = new Error("Unsupported PRF OID."); error.oid = prfOid; error.supported = ["hmacWithSHA1", "hmacWithSHA224", "hmacWithSHA256", "hmacWithSHA384", "hmacWithSHA512"]; throw error } } return prfAlgorithmToMessageDigest(prfAlgorithm) } function prfAlgorithmToMessageDigest(prfAlgorithm) { var factory = forge.md; switch (prfAlgorithm) { case "hmacWithSHA224": factory = forge.md.sha512; case "hmacWithSHA1": case "hmacWithSHA256": case "hmacWithSHA384": case "hmacWithSHA512": prfAlgorithm = prfAlgorithm.substr(8).toLowerCase(); break; default: var error = new Error("Unsupported PRF algorithm."); error.algorithm = prfAlgorithm; error.supported = ["hmacWithSHA1", "hmacWithSHA224", "hmacWithSHA256", "hmacWithSHA384", "hmacWithSHA512"]; throw error }if (!factory || !(prfAlgorithm in factory)) { throw new Error("Unknown hash algorithm: " + prfAlgorithm) } return factory[prfAlgorithm].create() } function createPbkdf2Params(salt, countBytes, dkLen, prfAlgorithm) { var params = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, salt), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, countBytes.getBytes())]); if (prfAlgorithm !== "hmacWithSHA1") { params.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, forge.util.hexToBytes(dkLen.toString(16))), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids[prfAlgorithm]).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")])) } return params } }, { "./aes": 7, "./asn1": 9, "./des": 14, "./forge": 16, "./md": 23, "./oids": 27, "./pbkdf2": 29, "./pem": 30, "./random": 39, "./rc2": 40, "./rsa": 41, "./util": 48 }], 29: [function (require, module, exports) { (function (Buffer) { var forge = require("./forge"); require("./hmac"); require("./md"); require("./util"); var pkcs5 = forge.pkcs5 = forge.pkcs5 || {}; var crypto; if (forge.util.isNodejs && !forge.options.usePureJavaScript) { crypto = require("crypto") } module.exports = forge.pbkdf2 = pkcs5.pbkdf2 = function (p, s, c, dkLen, md, callback) { if (typeof md === "function") { callback = md; md = null } if (forge.util.isNodejs && !forge.options.usePureJavaScript && crypto.pbkdf2 && (md === null || typeof md !== "object") && (crypto.pbkdf2Sync.length > 4 || (!md || md === "sha1"))) { if (typeof md !== "string") { md = "sha1" } p = Buffer.from(p, "binary"); s = Buffer.from(s, "binary"); if (!callback) { if (crypto.pbkdf2Sync.length === 4) { return crypto.pbkdf2Sync(p, s, c, dkLen).toString("binary") } return crypto.pbkdf2Sync(p, s, c, dkLen, md).toString("binary") } if (crypto.pbkdf2Sync.length === 4) { return crypto.pbkdf2(p, s, c, dkLen, function (err, key) { if (err) { return callback(err) } callback(null, key.toString("binary")) }) } return crypto.pbkdf2(p, s, c, dkLen, md, function (err, key) { if (err) { return callback(err) } callback(null, key.toString("binary")) }) } if (typeof md === "undefined" || md === null) { md = "sha1" } if (typeof md === "string") { if (!(md in forge.md.algorithms)) { throw new Error("Unknown hash algorithm: " + md) } md = forge.md[md].create() } var hLen = md.digestLength; if (dkLen > 4294967295 * hLen) { var err = new Error("Derived key is too long."); if (callback) { return callback(err) } throw err } var len = Math.ceil(dkLen / hLen); var r = dkLen - (len - 1) * hLen; var prf = forge.hmac.create(); prf.start(md, p); var dk = ""; var xor, u_c, u_c1; if (!callback) { for (var i = 1; i <= len; ++i) { prf.start(null, null); prf.update(s); prf.update(forge.util.int32ToBytes(i)); xor = u_c1 = prf.digest().getBytes(); for (var j = 2; j <= c; ++j) { prf.start(null, null); prf.update(u_c1); u_c = prf.digest().getBytes(); xor = forge.util.xorBytes(xor, u_c, hLen); u_c1 = u_c } dk += i < len ? xor : xor.substr(0, r) } return dk } var i = 1, j; function outer() { if (i > len) { return callback(null, dk) } prf.start(null, null); prf.update(s); prf.update(forge.util.int32ToBytes(i)); xor = u_c1 = prf.digest().getBytes(); j = 2; inner() } function inner() { if (j <= c) { prf.start(null, null); prf.update(u_c1); u_c = prf.digest().getBytes(); xor = forge.util.xorBytes(xor, u_c, hLen); u_c1 = u_c; ++j; return forge.util.setImmediate(inner) } dk += i < len ? xor : xor.substr(0, r); ++i; outer() } outer() } }).call(this, require("buffer").Buffer) }, { "./forge": 16, "./hmac": 17, "./md": 23, "./util": 48, buffer: 6, crypto: 6 }], 30: [function (require, module, exports) { var forge = require("./forge"); require("./util"); var pem = module.exports = forge.pem = forge.pem || {}; pem.encode = function (msg, options) { options = options || {}; var rval = "-----BEGIN " + msg.type + "-----\r\n"; var header; if (msg.procType) { header = { name: "Proc-Type", values: [String(msg.procType.version), msg.procType.type] }; rval += foldHeader(header) } if (msg.contentDomain) { header = { name: "Content-Domain", values: [msg.contentDomain] }; rval += foldHeader(header) } if (msg.dekInfo) { header = { name: "DEK-Info", values: [msg.dekInfo.algorithm] }; if (msg.dekInfo.parameters) { header.values.push(msg.dekInfo.parameters) } rval += foldHeader(header) } if (msg.headers) { for (var i = 0; i < msg.headers.length; ++i) { rval += foldHeader(msg.headers[i]) } } if (msg.procType) { rval += "\r\n" } rval += forge.util.encode64(msg.body, options.maxline || 64) + "\r\n"; rval += "-----END " + msg.type + "-----\r\n"; return rval }; pem.decode = function (str) { var rval = []; var rMessage = /\s*-----BEGIN ([A-Z0-9- ]+)-----\r?\n?([\x21-\x7e\s]+?(?:\r?\n\r?\n))?([:A-Za-z0-9+\/=\s]+?)-----END \1-----/g; var rHeader = /([\x21-\x7e]+):\s*([\x21-\x7e\s^:]+)/; var rCRLF = /\r?\n/; var match; while (true) { match = rMessage.exec(str); if (!match) { break } var msg = { type: match[1], procType: null, contentDomain: null, dekInfo: null, headers: [], body: forge.util.decode64(match[3]) }; rval.push(msg); if (!match[2]) { continue } var lines = match[2].split(rCRLF); var li = 0; while (match && li < lines.length) { var line = lines[li].replace(/\s+$/, ""); for (var nl = li + 1; nl < lines.length; ++nl) { var next = lines[nl]; if (!/\s/.test(next[0])) { break } line += next; li = nl } match = line.match(rHeader); if (match) { var header = { name: match[1], values: [] }; var values = match[2].split(","); for (var vi = 0; vi < values.length; ++vi) { header.values.push(ltrim(values[vi])) } if (!msg.procType) { if (header.name !== "Proc-Type") { throw new Error("Invalid PEM formatted message. The first " + 'encapsulated header must be "Proc-Type".') } else if (header.values.length !== 2) { throw new Error('Invalid PEM formatted message. The "Proc-Type" ' + "header must have two subfields.") } msg.procType = { version: values[0], type: values[1] } } else if (!msg.contentDomain && header.name === "Content-Domain") { msg.contentDomain = values[0] || "" } else if (!msg.dekInfo && header.name === "DEK-Info") { if (header.values.length === 0) { throw new Error('Invalid PEM formatted message. The "DEK-Info" ' + "header must have at least one subfield.") } msg.dekInfo = { algorithm: values[0], parameters: values[1] || null } } else { msg.headers.push(header) } } ++li } if (msg.procType === "ENCRYPTED" && !msg.dekInfo) { throw new Error('Invalid PEM formatted message. The "DEK-Info" ' + 'header must be present if "Proc-Type" is "ENCRYPTED".') } } if (rval.length === 0) { throw new Error("Invalid PEM formatted message.") } return rval }; function foldHeader(header) { var rval = header.name + ": "; var values = []; var insertSpace = function (match, $1) { return " " + $1 }; for (var i = 0; i < header.values.length; ++i) { values.push(header.values[i].replace(/^(\S+\r\n)/, insertSpace)) } rval += values.join(",") + "\r\n"; var length = 0; var candidate = -1; for (var i = 0; i < rval.length; ++i, ++length) { if (length > 65 && candidate !== -1) { var insert = rval[candidate]; if (insert === ",") { ++candidate; rval = rval.substr(0, candidate) + "\r\n " + rval.substr(candidate) } else { rval = rval.substr(0, candidate) + "\r\n" + insert + rval.substr(candidate + 1) } length = i - candidate - 1; candidate = -1; ++i } else if (rval[i] === " " || rval[i] === "\t" || rval[i] === ",") { candidate = i } } return rval } function ltrim(str) { return str.replace(/^\s+/, "") } }, { "./forge": 16, "./util": 48 }], 31: [function (require, module, exports) { var forge = require("./forge"); require("./util"); require("./random"); require("./sha1"); var pkcs1 = module.exports = forge.pkcs1 = forge.pkcs1 || {}; pkcs1.encode_rsa_oaep = function (key, message, options) { var label; var seed; var md; var mgf1Md; if (typeof options === "string") { label = options; seed = arguments[3] || undefined; md = arguments[4] || undefined } else if (options) { label = options.label || undefined; seed = options.seed || undefined; md = options.md || undefined; if (options.mgf1 && options.mgf1.md) { mgf1Md = options.mgf1.md } } if (!md) { md = forge.md.sha1.create() } else { md.start() } if (!mgf1Md) { mgf1Md = md } var keyLength = Math.ceil(key.n.bitLength() / 8); var maxLength = keyLength - 2 * md.digestLength - 2; if (message.length > maxLength) { var error = new Error("RSAES-OAEP input message length is too long."); error.length = message.length; error.maxLength = maxLength; throw error } if (!label) { label = "" } md.update(label, "raw"); var lHash = md.digest(); var PS = ""; var PS_length = maxLength - message.length; for (var i = 0; i < PS_length; i++) { PS += "\0" } var DB = lHash.getBytes() + PS + "" + message; if (!seed) { seed = forge.random.getBytes(md.digestLength) } else if (seed.length !== md.digestLength) { var error = new Error("Invalid RSAES-OAEP seed. The seed length must " + "match the digest length."); error.seedLength = seed.length; error.digestLength = md.digestLength; throw error } var dbMask = rsa_mgf1(seed, keyLength - md.digestLength - 1, mgf1Md); var maskedDB = forge.util.xorBytes(DB, dbMask, DB.length); var seedMask = rsa_mgf1(maskedDB, md.digestLength, mgf1Md); var maskedSeed = forge.util.xorBytes(seed, seedMask, seed.length); return "\0" + maskedSeed + maskedDB }; pkcs1.decode_rsa_oaep = function (key, em, options) { var label; var md; var mgf1Md; if (typeof options === "string") { label = options; md = arguments[3] || undefined } else if (options) { label = options.label || undefined; md = options.md || undefined; if (options.mgf1 && options.mgf1.md) { mgf1Md = options.mgf1.md } } var keyLength = Math.ceil(key.n.bitLength() / 8); if (em.length !== keyLength) { var error = new Error("RSAES-OAEP encoded message length is invalid."); error.length = em.length; error.expectedLength = keyLength; throw error } if (md === undefined) { md = forge.md.sha1.create() } else { md.start() } if (!mgf1Md) { mgf1Md = md } if (keyLength < 2 * md.digestLength + 2) { throw new Error("RSAES-OAEP key is too short for the hash function.") } if (!label) { label = "" } md.update(label, "raw"); var lHash = md.digest().getBytes(); var y = em.charAt(0); var maskedSeed = em.substring(1, md.digestLength + 1); var maskedDB = em.substring(1 + md.digestLength); var seedMask = rsa_mgf1(maskedDB, md.digestLength, mgf1Md); var seed = forge.util.xorBytes(maskedSeed, seedMask, maskedSeed.length); var dbMask = rsa_mgf1(seed, keyLength - md.digestLength - 1, mgf1Md); var db = forge.util.xorBytes(maskedDB, dbMask, maskedDB.length); var lHashPrime = db.substring(0, md.digestLength); var error = y !== "\0"; for (var i = 0; i < md.digestLength; ++i) { error |= lHash.charAt(i) !== lHashPrime.charAt(i) } var in_ps = 1; var index = md.digestLength; for (var j = md.digestLength; j < db.length; j++) { var code = db.charCodeAt(j); var is_0 = code & 1 ^ 1; var error_mask = in_ps ? 65534 : 0; error |= code & error_mask; in_ps = in_ps & is_0; index += in_ps } if (error || db.charCodeAt(index) !== 1) { throw new Error("Invalid RSAES-OAEP padding.") } return db.substring(index + 1) }; function rsa_mgf1(seed, maskLength, hash) { if (!hash) { hash = forge.md.sha1.create() } var t = ""; var count = Math.ceil(maskLength / hash.digestLength); for (var i = 0; i < count; ++i) { var c = String.fromCharCode(i >> 24 & 255, i >> 16 & 255, i >> 8 & 255, i & 255); hash.start(); hash.update(seed + c); t += hash.digest().getBytes() } return t.substring(0, maskLength) } }, { "./forge": 16, "./random": 39, "./sha1": 42, "./util": 48 }], 32: [function (require, module, exports) { var forge = require("./forge"); require("./asn1"); require("./hmac"); require("./oids"); require("./pkcs7asn1"); require("./pbe"); require("./random"); require("./rsa"); require("./sha1"); require("./util"); require("./x509"); var asn1 = forge.asn1; var pki = forge.pki; var p12 = module.exports = forge.pkcs12 = forge.pkcs12 || {}; var contentInfoValidator = { name: "ContentInfo", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.SEQUENCE, constructed: true, value: [{ name: "ContentInfo.contentType", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.OID, constructed: false, capture: "contentType" }, { name: "ContentInfo.content", tagClass: asn1.Class.CONTEXT_SPECIFIC, constructed: true, captureAsn1: "content" }] }; var pfxValidator = { name: "PFX", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.SEQUENCE, constructed: true, value: [{ name: "PFX.version", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.INTEGER, constructed: false, capture: "version" }, contentInfoValidator, { name: "PFX.macData", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.SEQUENCE, constructed: true, optional: true, captureAsn1: "mac", value: [{ name: "PFX.macData.mac", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.SEQUENCE, constructed: true, value: [{ name: "PFX.macData.mac.digestAlgorithm", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.SEQUENCE, constructed: true, value: [{ name: "PFX.macData.mac.digestAlgorithm.algorithm", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.OID, constructed: false, capture: "macAlgorithm" }, { name: "PFX.macData.mac.digestAlgorithm.parameters", tagClass: asn1.Class.UNIVERSAL, captureAsn1: "macAlgorithmParameters" }] }, { name: "PFX.macData.mac.digest", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.OCTETSTRING, constructed: false, capture: "macDigest" }] }, { name: "PFX.macData.macSalt", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.OCTETSTRING, constructed: false, capture: "macSalt" }, { name: "PFX.macData.iterations", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.INTEGER, constructed: false, optional: true, capture: "macIterations" }] }] }; var safeBagValidator = { name: "SafeBag", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.SEQUENCE, constructed: true, value: [{ name: "SafeBag.bagId", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.OID, constructed: false, capture: "bagId" }, { name: "SafeBag.bagValue", tagClass: asn1.Class.CONTEXT_SPECIFIC, constructed: true, captureAsn1: "bagValue" }, { name: "SafeBag.bagAttributes", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.SET, constructed: true, optional: true, capture: "bagAttributes" }] }; var attributeValidator = { name: "Attribute", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.SEQUENCE, constructed: true, value: [{ name: "Attribute.attrId", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.OID, constructed: false, capture: "oid" }, { name: "Attribute.attrValues", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.SET, constructed: true, capture: "values" }] }; var certBagValidator = { name: "CertBag", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.SEQUENCE, constructed: true, value: [{ name: "CertBag.certId", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.OID, constructed: false, capture: "certId" }, { name: "CertBag.certValue", tagClass: asn1.Class.CONTEXT_SPECIFIC, constructed: true, value: [{ name: "CertBag.certValue[0]", tagClass: asn1.Class.UNIVERSAL, type: asn1.Class.OCTETSTRING, constructed: false, capture: "cert" }] }] }; function _getBagsByAttribute(safeContents, attrName, attrValue, bagType) { var result = []; for (var i = 0; i < safeContents.length; i++) { for (var j = 0; j < safeContents[i].safeBags.length; j++) { var bag = safeContents[i].safeBags[j]; if (bagType !== undefined && bag.type !== bagType) { continue } if (attrName === null) { result.push(bag); continue } if (bag.attributes[attrName] !== undefined && bag.attributes[attrName].indexOf(attrValue) >= 0) { result.push(bag) } } } return result } p12.pkcs12FromAsn1 = function (obj, strict, password) { if (typeof strict === "string") { password = strict; strict = true } else if (strict === undefined) { strict = true } var capture = {}; var errors = []; if (!asn1.validate(obj, pfxValidator, capture, errors)) { var error = new Error("Cannot read PKCS#12 PFX. " + "ASN.1 object is not an PKCS#12 PFX."); error.errors = error; throw error } var pfx = { version: capture.version.charCodeAt(0), safeContents: [], getBags: function (filter) { var rval = {}; var localKeyId; if ("localKeyId" in filter) { localKeyId = filter.localKeyId } else if ("localKeyIdHex" in filter) { localKeyId = forge.util.hexToBytes(filter.localKeyIdHex) } if (localKeyId === undefined && !("friendlyName" in filter) && "bagType" in filter) { rval[filter.bagType] = _getBagsByAttribute(pfx.safeContents, null, null, filter.bagType) } if (localKeyId !== undefined) { rval.localKeyId = _getBagsByAttribute(pfx.safeContents, "localKeyId", localKeyId, filter.bagType) } if ("friendlyName" in filter) { rval.friendlyName = _getBagsByAttribute(pfx.safeContents, "friendlyName", filter.friendlyName, filter.bagType) } return rval }, getBagsByFriendlyName: function (friendlyName, bagType) { return _getBagsByAttribute(pfx.safeContents, "friendlyName", friendlyName, bagType) }, getBagsByLocalKeyId: function (localKeyId, bagType) { return _getBagsByAttribute(pfx.safeContents, "localKeyId", localKeyId, bagType) } }; if (capture.version.charCodeAt(0) !== 3) { var error = new Error("PKCS#12 PFX of version other than 3 not supported."); error.version = capture.version.charCodeAt(0); throw error } if (asn1.derToOid(capture.contentType) !== pki.oids.data) { var error = new Error("Only PKCS#12 PFX in password integrity mode supported."); error.oid = asn1.derToOid(capture.contentType); throw error } var data = capture.content.value[0]; if (data.tagClass !== asn1.Class.UNIVERSAL || data.type !== asn1.Type.OCTETSTRING) { throw new Error("PKCS#12 authSafe content data is not an OCTET STRING.") } data = _decodePkcs7Data(data); if (capture.mac) { var md = null; var macKeyBytes = 0; var macAlgorithm = asn1.derToOid(capture.macAlgorithm); switch (macAlgorithm) { case pki.oids.sha1: md = forge.md.sha1.create(); macKeyBytes = 20; break; case pki.oids.sha256: md = forge.md.sha256.create(); macKeyBytes = 32; break; case pki.oids.sha384: md = forge.md.sha384.create(); macKeyBytes = 48; break; case pki.oids.sha512: md = forge.md.sha512.create(); macKeyBytes = 64; break; case pki.oids.md5: md = forge.md.md5.create(); macKeyBytes = 16; break }if (md === null) { throw new Error("PKCS#12 uses unsupported MAC algorithm: " + macAlgorithm) } var macSalt = new forge.util.ByteBuffer(capture.macSalt); var macIterations = "macIterations" in capture ? parseInt(forge.util.bytesToHex(capture.macIterations), 16) : 1; var macKey = p12.generateKey(password, macSalt, 3, macIterations, macKeyBytes, md); var mac = forge.hmac.create(); mac.start(md, macKey); mac.update(data.value); var macValue = mac.getMac(); if (macValue.getBytes() !== capture.macDigest) { throw new Error("PKCS#12 MAC could not be verified. Invalid password?") } } _decodeAuthenticatedSafe(pfx, data.value, strict, password); return pfx }; function _decodePkcs7Data(data) { if (data.composed || data.constructed) { var value = forge.util.createBuffer(); for (var i = 0; i < data.value.length; ++i) { value.putBytes(data.value[i].value) } data.composed = data.constructed = false; data.value = value.getBytes() } return data } function _decodeAuthenticatedSafe(pfx, authSafe, strict, password) { authSafe = asn1.fromDer(authSafe, strict); if (authSafe.tagClass !== asn1.Class.UNIVERSAL || authSafe.type !== asn1.Type.SEQUENCE || authSafe.constructed !== true) { throw new Error("PKCS#12 AuthenticatedSafe expected to be a " + "SEQUENCE OF ContentInfo") } for (var i = 0; i < authSafe.value.length; i++) { var contentInfo = authSafe.value[i]; var capture = {}; var errors = []; if (!asn1.validate(contentInfo, contentInfoValidator, capture, errors)) { var error = new Error("Cannot read ContentInfo."); error.errors = errors; throw error } var obj = { encrypted: false }; var safeContents = null; var data = capture.content.value[0]; switch (asn1.derToOid(capture.contentType)) { case pki.oids.data: if (data.tagClass !== asn1.Class.UNIVERSAL || data.type !== asn1.Type.OCTETSTRING) { throw new Error("PKCS#12 SafeContents Data is not an OCTET STRING.") } safeContents = _decodePkcs7Data(data).value; break; case pki.oids.encryptedData: safeContents = _decryptSafeContents(data, password); obj.encrypted = true; break; default: var error = new Error("Unsupported PKCS#12 contentType."); error.contentType = asn1.derToOid(capture.contentType); throw error }obj.safeBags = _decodeSafeContents(safeContents, strict, password); pfx.safeContents.push(obj) } } function _decryptSafeContents(data, password) { var capture = {}; var errors = []; if (!asn1.validate(data, forge.pkcs7.asn1.encryptedDataValidator, capture, errors)) { var error = new Error("Cannot read EncryptedContentInfo."); error.errors = errors; throw error } var oid = asn1.derToOid(capture.contentType); if (oid !== pki.oids.data) { var error = new Error("PKCS#12 EncryptedContentInfo ContentType is not Data."); error.oid = oid; throw error } oid = asn1.derToOid(capture.encAlgorithm); var cipher = pki.pbe.getCipher(oid, capture.encParameter, password); var encryptedContentAsn1 = _decodePkcs7Data(capture.encryptedContentAsn1); var encrypted = forge.util.createBuffer(encryptedContentAsn1.value); cipher.update(encrypted); if (!cipher.finish()) { throw new Error("Failed to decrypt PKCS#12 SafeContents.") } return cipher.output.getBytes() } function _decodeSafeContents(safeContents, strict, password) { if (!strict && safeContents.length === 0) { return [] } safeContents = asn1.fromDer(safeContents, strict); if (safeContents.tagClass !== asn1.Class.UNIVERSAL || safeContents.type !== asn1.Type.SEQUENCE || safeContents.constructed !== true) { throw new Error("PKCS#12 SafeContents expected to be a SEQUENCE OF SafeBag.") } var res = []; for (var i = 0; i < safeContents.value.length; i++) { var safeBag = safeContents.value[i]; var capture = {}; var errors = []; if (!asn1.validate(safeBag, safeBagValidator, capture, errors)) { var error = new Error("Cannot read SafeBag."); error.errors = errors; throw error } var bag = { type: asn1.derToOid(capture.bagId), attributes: _decodeBagAttributes(capture.bagAttributes) }; res.push(bag); var validator, decoder; var bagAsn1 = capture.bagValue.value[0]; switch (bag.type) { case pki.oids.pkcs8ShroudedKeyBag: bagAsn1 = pki.decryptPrivateKeyInfo(bagAsn1, password); if (bagAsn1 === null) { throw new Error("Unable to decrypt PKCS#8 ShroudedKeyBag, wrong password?") } case pki.oids.keyBag: try { bag.key = pki.privateKeyFromAsn1(bagAsn1) } catch (e) { bag.key = null; bag.asn1 = bagAsn1 } continue; case pki.oids.certBag: validator = certBagValidator; decoder = function () { if (asn1.derToOid(capture.certId) !== pki.oids.x509Certificate) { var error = new Error("Unsupported certificate type, only X.509 supported."); error.oid = asn1.derToOid(capture.certId); throw error } var certAsn1 = asn1.fromDer(capture.cert, strict); try { bag.cert = pki.certificateFromAsn1(certAsn1, true) } catch (e) { bag.cert = null; bag.asn1 = certAsn1 } }; break; default: var error = new Error("Unsupported PKCS#12 SafeBag type."); error.oid = bag.type; throw error }if (validator !== undefined && !asn1.validate(bagAsn1, validator, capture, errors)) { var error = new Error("Cannot read PKCS#12 " + validator.name); error.errors = errors; throw error } decoder() } return res } function _decodeBagAttributes(attributes) { var decodedAttrs = {}; if (attributes !== undefined) { for (var i = 0; i < attributes.length; ++i) { var capture = {}; var errors = []; if (!asn1.validate(attributes[i], attributeValidator, capture, errors)) { var error = new Error("Cannot read PKCS#12 BagAttribute."); error.errors = errors; throw error } var oid = asn1.derToOid(capture.oid); if (pki.oids[oid] === undefined) { continue } decodedAttrs[pki.oids[oid]] = []; for (var j = 0; j < capture.values.length; ++j) { decodedAttrs[pki.oids[oid]].push(capture.values[j].value) } } } return decodedAttrs } p12.toPkcs12Asn1 = function (key, cert, password, options) { options = options || {}; options.saltSize = options.saltSize || 8; options.count = options.count || 2048; options.algorithm = options.algorithm || options.encAlgorithm || "aes128"; if (!("useMac" in options)) { options.useMac = true } if (!("localKeyId" in options)) { options.localKeyId = null } if (!("generateLocalKeyId" in options)) { options.generateLocalKeyId = true } var localKeyId = options.localKeyId; var bagAttrs; if (localKeyId !== null) { localKeyId = forge.util.hexToBytes(localKeyId) } else if (options.generateLocalKeyId) { if (cert) { var pairedCert = forge.util.isArray(cert) ? cert[0] : cert; if (typeof pairedCert === "string") { pairedCert = pki.certificateFromPem(pairedCert) } var sha1 = forge.md.sha1.create(); sha1.update(asn1.toDer(pki.certificateToAsn1(pairedCert)).getBytes()); localKeyId = sha1.digest().getBytes() } else { localKeyId = forge.random.getBytes(20) } } var attrs = []; if (localKeyId !== null) { attrs.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.localKeyId).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, localKeyId)])])) } if ("friendlyName" in options) { attrs.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.friendlyName).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BMPSTRING, false, options.friendlyName)])])) } if (attrs.length > 0) { bagAttrs = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, attrs) } var contents = []; var chain = []; if (cert !== null) { if (forge.util.isArray(cert)) { chain = cert } else { chain = [cert] } } var certSafeBags = []; for (var i = 0; i < chain.length; ++i) { cert = chain[i]; if (typeof cert === "string") { cert = pki.certificateFromPem(cert) } var certBagAttrs = i === 0 ? bagAttrs : undefined; var certAsn1 = pki.certificateToAsn1(cert); var certSafeBag = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.certBag).getBytes()), asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.x509Certificate).getBytes()), asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, asn1.toDer(certAsn1).getBytes())])])]), certBagAttrs]); certSafeBags.push(certSafeBag) } if (certSafeBags.length > 0) { var certSafeContents = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, certSafeBags); var certCI = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.data).getBytes()), asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, asn1.toDer(certSafeContents).getBytes())])]); contents.push(certCI) } var keyBag = null; if (key !== null) { var pkAsn1 = pki.wrapRsaPrivateKey(pki.privateKeyToAsn1(key)); if (password === null) { keyBag = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.keyBag).getBytes()), asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [pkAsn1]), bagAttrs]) } else { keyBag = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.pkcs8ShroudedKeyBag).getBytes()), asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [pki.encryptPrivateKeyInfo(pkAsn1, password, options)]), bagAttrs]) } var keySafeContents = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [keyBag]); var keyCI = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.data).getBytes()), asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, asn1.toDer(keySafeContents).getBytes())])]); contents.push(keyCI) } var safe = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, contents); var macData; if (options.useMac) { var sha1 = forge.md.sha1.create(); var macSalt = new forge.util.ByteBuffer(forge.random.getBytes(options.saltSize)); var count = options.count; var key = p12.generateKey(password, macSalt, 3, count, 20); var mac = forge.hmac.create(); mac.start(sha1, key); mac.update(asn1.toDer(safe).getBytes()); var macValue = mac.getMac(); macData = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.sha1).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")]), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, macValue.getBytes())]), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, macSalt.getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(count).getBytes())]) } return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(3).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.data).getBytes()), asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, asn1.toDer(safe).getBytes())])]), macData]) }; p12.generateKey = forge.pbe.generatePkcs12Key }, { "./asn1": 9, "./forge": 16, "./hmac": 17, "./oids": 27, "./pbe": 28, "./pkcs7asn1": 34, "./random": 39, "./rsa": 41, "./sha1": 42, "./util": 48, "./x509": 49 }], 33: [function (require, module, exports) { var forge = require("./forge"); require("./aes"); require("./asn1"); require("./des"); require("./oids"); require("./pem"); require("./pkcs7asn1"); require("./random"); require("./util"); require("./x509"); var asn1 = forge.asn1; var p7 = module.exports = forge.pkcs7 = forge.pkcs7 || {}; p7.messageFromPem = function (pem) { var msg = forge.pem.decode(pem)[0]; if (msg.type !== "PKCS7") { var error = new Error("Could not convert PKCS#7 message from PEM; PEM " + 'header type is not "PKCS#7".'); error.headerType = msg.type; throw error } if (msg.procType && msg.procType.type === "ENCRYPTED") { throw new Error("Could not convert PKCS#7 message from PEM; PEM is encrypted.") } var obj = asn1.fromDer(msg.body); return p7.messageFromAsn1(obj) }; p7.messageToPem = function (msg, maxline) { var pemObj = { type: "PKCS7", body: asn1.toDer(msg.toAsn1()).getBytes() }; return forge.pem.encode(pemObj, { maxline: maxline }) }; p7.messageFromAsn1 = function (obj) { var capture = {}; var errors = []; if (!asn1.validate(obj, p7.asn1.contentInfoValidator, capture, errors)) { var error = new Error("Cannot read PKCS#7 message. " + "ASN.1 object is not an PKCS#7 ContentInfo."); error.errors = errors; throw error } var contentType = asn1.derToOid(capture.contentType); var msg; switch (contentType) { case forge.pki.oids.envelopedData: msg = p7.createEnvelopedData(); break; case forge.pki.oids.encryptedData: msg = p7.createEncryptedData(); break; case forge.pki.oids.signedData: msg = p7.createSignedData(); break; default: throw new Error("Cannot read PKCS#7 message. ContentType with OID " + contentType + " is not (yet) supported.") }msg.fromAsn1(capture.content.value[0]); return msg }; p7.createSignedData = function () { var msg = null; msg = { type: forge.pki.oids.signedData, version: 1, certificates: [], crls: [], signers: [], digestAlgorithmIdentifiers: [], contentInfo: null, signerInfos: [], fromAsn1: function (obj) { _fromAsn1(msg, obj, p7.asn1.signedDataValidator); msg.certificates = []; msg.crls = []; msg.digestAlgorithmIdentifiers = []; msg.contentInfo = null; msg.signerInfos = []; if (msg.rawCapture.certificates) { var certs = msg.rawCapture.certificates.value; for (var i = 0; i < certs.length; ++i) { msg.certificates.push(forge.pki.certificateFromAsn1(certs[i])) } } }, toAsn1: function () { if (!msg.contentInfo) { msg.sign() } var certs = []; for (var i = 0; i < msg.certificates.length; ++i) { certs.push(forge.pki.certificateToAsn1(msg.certificates[i])) } var crls = []; var signedData = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(msg.version).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, msg.digestAlgorithmIdentifiers), msg.contentInfo])]); if (certs.length > 0) { signedData.value[0].value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, certs)) } if (crls.length > 0) { signedData.value[0].value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, crls)) } signedData.value[0].value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, msg.signerInfos)); return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(msg.type).getBytes()), signedData]) }, addSigner: function (signer) { var issuer = signer.issuer; var serialNumber = signer.serialNumber; if (signer.certificate) { var cert = signer.certificate; if (typeof cert === "string") { cert = forge.pki.certificateFromPem(cert) } issuer = cert.issuer.attributes; serialNumber = cert.serialNumber } var key = signer.key; if (!key) { throw new Error("Could not add PKCS#7 signer; no private key specified.") } if (typeof key === "string") { key = forge.pki.privateKeyFromPem(key) } var digestAlgorithm = signer.digestAlgorithm || forge.pki.oids.sha1; switch (digestAlgorithm) { case forge.pki.oids.sha1: case forge.pki.oids.sha256: case forge.pki.oids.sha384: case forge.pki.oids.sha512: case forge.pki.oids.md5: break; default: throw new Error("Could not add PKCS#7 signer; unknown message digest algorithm: " + digestAlgorithm) }var authenticatedAttributes = signer.authenticatedAttributes || []; if (authenticatedAttributes.length > 0) { var contentType = false; var messageDigest = false; for (var i = 0; i < authenticatedAttributes.length; ++i) { var attr = authenticatedAttributes[i]; if (!contentType && attr.type === forge.pki.oids.contentType) { contentType = true; if (messageDigest) { break } continue } if (!messageDigest && attr.type === forge.pki.oids.messageDigest) { messageDigest = true; if (contentType) { break } continue } } if (!contentType || !messageDigest) { throw new Error("Invalid signer.authenticatedAttributes. If " + "signer.authenticatedAttributes is specified, then it must " + "contain at least two attributes, PKCS #9 content-type and " + "PKCS #9 message-digest.") } } msg.signers.push({ key: key, version: 1, issuer: issuer, serialNumber: serialNumber, digestAlgorithm: digestAlgorithm, signatureAlgorithm: forge.pki.oids.rsaEncryption, signature: null, authenticatedAttributes: authenticatedAttributes, unauthenticatedAttributes: [] }) }, sign: function (options) { options = options || {}; if (typeof msg.content !== "object" || msg.contentInfo === null) { msg.contentInfo = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(forge.pki.oids.data).getBytes())]); if ("content" in msg) { var content; if (msg.content instanceof forge.util.ByteBuffer) { content = msg.content.bytes() } else if (typeof msg.content === "string") { content = forge.util.encodeUtf8(msg.content) } if (options.detached) { msg.detachedContent = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, content) } else { msg.contentInfo.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, content)])) } } } if (msg.signers.length === 0) { return } var mds = addDigestAlgorithmIds(); addSignerInfos(mds) }, verify: function () { throw new Error("PKCS#7 signature verification not yet implemented.") }, addCertificate: function (cert) { if (typeof cert === "string") { cert = forge.pki.certificateFromPem(cert) } msg.certificates.push(cert) }, addCertificateRevokationList: function (crl) { throw new Error("PKCS#7 CRL support not yet implemented.") } }; return msg; function addDigestAlgorithmIds() { var mds = {}; for (var i = 0; i < msg.signers.length; ++i) { var signer = msg.signers[i]; var oid = signer.digestAlgorithm; if (!(oid in mds)) { mds[oid] = forge.md[forge.pki.oids[oid]].create() } if (signer.authenticatedAttributes.length === 0) { signer.md = mds[oid] } else { signer.md = forge.md[forge.pki.oids[oid]].create() } } msg.digestAlgorithmIdentifiers = []; for (var oid in mds) { msg.digestAlgorithmIdentifiers.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(oid).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")])) } return mds } function addSignerInfos(mds) { var content; if (msg.detachedContent) { content = msg.detachedContent } else { content = msg.contentInfo.value[1]; content = content.value[0] } if (!content) { throw new Error("Could not sign PKCS#7 message; there is no content to sign.") } var contentType = asn1.derToOid(msg.contentInfo.value[0].value); var bytes = asn1.toDer(content); bytes.getByte(); asn1.getBerValueLength(bytes); bytes = bytes.getBytes(); for (var oid in mds) { mds[oid].start().update(bytes) } var signingTime = new Date; for (var i = 0; i < msg.signers.length; ++i) { var signer = msg.signers[i]; if (signer.authenticatedAttributes.length === 0) { if (contentType !== forge.pki.oids.data) { throw new Error("Invalid signer; authenticatedAttributes must be present " + "when the ContentInfo content type is not PKCS#7 Data.") } } else { signer.authenticatedAttributesAsn1 = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, []); var attrsAsn1 = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, []); for (var ai = 0; ai < signer.authenticatedAttributes.length; ++ai) { var attr = signer.authenticatedAttributes[ai]; if (attr.type === forge.pki.oids.messageDigest) { attr.value = mds[signer.digestAlgorithm].digest() } else if (attr.type === forge.pki.oids.signingTime) { if (!attr.value) { attr.value = signingTime } } attrsAsn1.value.push(_attributeToAsn1(attr)); signer.authenticatedAttributesAsn1.value.push(_attributeToAsn1(attr)) } bytes = asn1.toDer(attrsAsn1).getBytes(); signer.md.start().update(bytes) } signer.signature = signer.key.sign(signer.md, "RSASSA-PKCS1-V1_5") } msg.signerInfos = _signersToAsn1(msg.signers) } }; p7.createEncryptedData = function () { var msg = null; msg = { type: forge.pki.oids.encryptedData, version: 0, encryptedContent: { algorithm: forge.pki.oids["aes256-CBC"] }, fromAsn1: function (obj) { _fromAsn1(msg, obj, p7.asn1.encryptedDataValidator) }, decrypt: function (key) { if (key !== undefined) { msg.encryptedContent.key = key } _decryptContent(msg) } }; return msg }; p7.createEnvelopedData = function () { var msg = null; msg = { type: forge.pki.oids.envelopedData, version: 0, recipients: [], encryptedContent: { algorithm: forge.pki.oids["aes256-CBC"] }, fromAsn1: function (obj) { var capture = _fromAsn1(msg, obj, p7.asn1.envelopedDataValidator); msg.recipients = _recipientsFromAsn1(capture.recipientInfos.value) }, toAsn1: function () { return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(msg.type).getBytes()), asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(msg.version).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, _recipientsToAsn1(msg.recipients)), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, _encryptedContentToAsn1(msg.encryptedContent))])])]) }, findRecipient: function (cert) { var sAttr = cert.issuer.attributes; for (var i = 0; i < msg.recipients.length; ++i) { var r = msg.recipients[i]; var rAttr = r.issuer; if (r.serialNumber !== cert.serialNumber) { continue } if (rAttr.length !== sAttr.length) { continue } var match = true; for (var j = 0; j < sAttr.length; ++j) { if (rAttr[j].type !== sAttr[j].type || rAttr[j].value !== sAttr[j].value) { match = false; break } } if (match) { return r } } return null }, decrypt: function (recipient, privKey) { if (msg.encryptedContent.key === undefined && recipient !== undefined && privKey !== undefined) { switch (recipient.encryptedContent.algorithm) { case forge.pki.oids.rsaEncryption: case forge.pki.oids.desCBC: var key = privKey.decrypt(recipient.encryptedContent.content); msg.encryptedContent.key = forge.util.createBuffer(key); break; default: throw new Error("Unsupported asymmetric cipher, " + "OID " + recipient.encryptedContent.algorithm) } } _decryptContent(msg) }, addRecipient: function (cert) { msg.recipients.push({ version: 0, issuer: cert.issuer.attributes, serialNumber: cert.serialNumber, encryptedContent: { algorithm: forge.pki.oids.rsaEncryption, key: cert.publicKey } }) }, encrypt: function (key, cipher) { if (msg.encryptedContent.content === undefined) { cipher = cipher || msg.encryptedContent.algorithm; key = key || msg.encryptedContent.key; var keyLen, ivLen, ciphFn; switch (cipher) { case forge.pki.oids["aes128-CBC"]: keyLen = 16; ivLen = 16; ciphFn = forge.aes.createEncryptionCipher; break; case forge.pki.oids["aes192-CBC"]: keyLen = 24; ivLen = 16; ciphFn = forge.aes.createEncryptionCipher; break; case forge.pki.oids["aes256-CBC"]: keyLen = 32; ivLen = 16; ciphFn = forge.aes.createEncryptionCipher; break; case forge.pki.oids["des-EDE3-CBC"]: keyLen = 24; ivLen = 8; ciphFn = forge.des.createEncryptionCipher; break; default: throw new Error("Unsupported symmetric cipher, OID " + cipher) }if (key === undefined) { key = forge.util.createBuffer(forge.random.getBytes(keyLen)) } else if (key.length() != keyLen) { throw new Error("Symmetric key has wrong length; " + "got " + key.length() + " bytes, expected " + keyLen + ".") } msg.encryptedContent.algorithm = cipher; msg.encryptedContent.key = key; msg.encryptedContent.parameter = forge.util.createBuffer(forge.random.getBytes(ivLen)); var ciph = ciphFn(key); ciph.start(msg.encryptedContent.parameter.copy()); ciph.update(msg.content); if (!ciph.finish()) { throw new Error("Symmetric encryption failed.") } msg.encryptedContent.content = ciph.output } for (var i = 0; i < msg.recipients.length; ++i) { var recipient = msg.recipients[i]; if (recipient.encryptedContent.content !== undefined) { continue } switch (recipient.encryptedContent.algorithm) { case forge.pki.oids.rsaEncryption: recipient.encryptedContent.content = recipient.encryptedContent.key.encrypt(msg.encryptedContent.key.data); break; default: throw new Error("Unsupported asymmetric cipher, OID " + recipient.encryptedContent.algorithm) } } } }; return msg }; function _recipientFromAsn1(obj) { var capture = {}; var errors = []; if (!asn1.validate(obj, p7.asn1.recipientInfoValidator, capture, errors)) { var error = new Error("Cannot read PKCS#7 RecipientInfo. " + "ASN.1 object is not an PKCS#7 RecipientInfo."); error.errors = errors; throw error } return { version: capture.version.charCodeAt(0), issuer: forge.pki.RDNAttributesAsArray(capture.issuer), serialNumber: forge.util.createBuffer(capture.serial).toHex(), encryptedContent: { algorithm: asn1.derToOid(capture.encAlgorithm), parameter: capture.encParameter.value, content: capture.encKey } } } function _recipientToAsn1(obj) { return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(obj.version).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [forge.pki.distinguishedNameToAsn1({ attributes: obj.issuer }), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, forge.util.hexToBytes(obj.serialNumber))]), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(obj.encryptedContent.algorithm).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")]), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, obj.encryptedContent.content)]) } function _recipientsFromAsn1(infos) { var ret = []; for (var i = 0; i < infos.length; ++i) { ret.push(_recipientFromAsn1(infos[i])) } return ret } function _recipientsToAsn1(recipients) { var ret = []; for (var i = 0; i < recipients.length; ++i) { ret.push(_recipientToAsn1(recipients[i])) } return ret } function _signerFromAsn1(obj) { var capture = {}; var errors = []; if (!asn1.validate(obj, p7.asn1.signerInfoValidator, capture, errors)) { var error = new Error("Cannot read PKCS#7 SignerInfo. " + "ASN.1 object is not an PKCS#7 SignerInfo."); error.errors = errors; throw error } var rval = { version: capture.version.charCodeAt(0), issuer: forge.pki.RDNAttributesAsArray(capture.issuer), serialNumber: forge.util.createBuffer(capture.serial).toHex(), digestAlgorithm: asn1.derToOid(capture.digestAlgorithm), signatureAlgorithm: asn1.derToOid(capture.signatureAlgorithm), signature: capture.signature, authenticatedAttributes: [], unauthenticatedAttributes: [] }; var authenticatedAttributes = capture.authenticatedAttributes || []; var unauthenticatedAttributes = capture.unauthenticatedAttributes || []; return rval } function _signerToAsn1(obj) { var rval = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(obj.version).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [forge.pki.distinguishedNameToAsn1({ attributes: obj.issuer }), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, forge.util.hexToBytes(obj.serialNumber))]), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(obj.digestAlgorithm).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")])]); if (obj.authenticatedAttributesAsn1) { rval.value.push(obj.authenticatedAttributesAsn1) } rval.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(obj.signatureAlgorithm).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")])); rval.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, obj.signature)); if (obj.unauthenticatedAttributes.length > 0) { var attrsAsn1 = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, []); for (var i = 0; i < obj.unauthenticatedAttributes.length; ++i) { var attr = obj.unauthenticatedAttributes[i]; attrsAsn1.values.push(_attributeToAsn1(attr)) } rval.value.push(attrsAsn1) } return rval } function _signersFromAsn1(signerInfoAsn1s) { var ret = []; for (var i = 0; i < signerInfoAsn1s.length; ++i) { ret.push(_signerFromAsn1(signerInfoAsn1s[i])) } return ret } function _signersToAsn1(signers) { var ret = []; for (var i = 0; i < signers.length; ++i) { ret.push(_signerToAsn1(signers[i])) } return ret } function _attributeToAsn1(attr) { var value; if (attr.type === forge.pki.oids.contentType) { value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(attr.value).getBytes()) } else if (attr.type === forge.pki.oids.messageDigest) { value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, attr.value.bytes()) } else if (attr.type === forge.pki.oids.signingTime) { var jan_1_1950 = new Date("1950-01-01T00:00:00Z"); var jan_1_2050 = new Date("2050-01-01T00:00:00Z"); var date = attr.value; if (typeof date === "string") { var timestamp = Date.parse(date); if (!isNaN(timestamp)) { date = new Date(timestamp) } else if (date.length === 13) { date = asn1.utcTimeToDate(date) } else { date = asn1.generalizedTimeToDate(date) } } if (date >= jan_1_1950 && date < jan_1_2050) { value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.UTCTIME, false, asn1.dateToUtcTime(date)) } else { value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.GENERALIZEDTIME, false, asn1.dateToGeneralizedTime(date)) } } return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(attr.type).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [value])]) } function _encryptedContentToAsn1(ec) { return [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(forge.pki.oids.data).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(ec.algorithm).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, ec.parameter.getBytes())]), asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, ec.content.getBytes())])] } function _fromAsn1(msg, obj, validator) { var capture = {}; var errors = []; if (!asn1.validate(obj, validator, capture, errors)) { var error = new Error("Cannot read PKCS#7 message. " + "ASN.1 object is not a supported PKCS#7 message."); error.errors = error; throw error } var contentType = asn1.derToOid(capture.contentType); if (contentType !== forge.pki.oids.data) { throw new Error("Unsupported PKCS#7 message. " + "Only wrapped ContentType Data supported.") } if (capture.encryptedContent) { var content = ""; if (forge.util.isArray(capture.encryptedContent)) { for (var i = 0; i < capture.encryptedContent.length; ++i) { if (capture.encryptedContent[i].type !== asn1.Type.OCTETSTRING) { throw new Error("Malformed PKCS#7 message, expecting encrypted " + "content constructed of only OCTET STRING objects.") } content += capture.encryptedContent[i].value } } else { content = capture.encryptedContent } msg.encryptedContent = { algorithm: asn1.derToOid(capture.encAlgorithm), parameter: forge.util.createBuffer(capture.encParameter.value), content: forge.util.createBuffer(content) } } if (capture.content) { var content = ""; if (forge.util.isArray(capture.content)) { for (var i = 0; i < capture.content.length; ++i) { if (capture.content[i].type !== asn1.Type.OCTETSTRING) { throw new Error("Malformed PKCS#7 message, expecting " + "content constructed of only OCTET STRING objects.") } content += capture.content[i].value } } else { content = capture.content } msg.content = forge.util.createBuffer(content) } msg.version = capture.version.charCodeAt(0); msg.rawCapture = capture; return capture } function _decryptContent(msg) { if (msg.encryptedContent.key === undefined) { throw new Error("Symmetric key not available.") } if (msg.content === undefined) { var ciph; switch (msg.encryptedContent.algorithm) { case forge.pki.oids["aes128-CBC"]: case forge.pki.oids["aes192-CBC"]: case forge.pki.oids["aes256-CBC"]: ciph = forge.aes.createDecryptionCipher(msg.encryptedContent.key); break; case forge.pki.oids["desCBC"]: case forge.pki.oids["des-EDE3-CBC"]: ciph = forge.des.createDecryptionCipher(msg.encryptedContent.key); break; default: throw new Error("Unsupported symmetric cipher, OID " + msg.encryptedContent.algorithm) }ciph.start(msg.encryptedContent.parameter); ciph.update(msg.encryptedContent.content); if (!ciph.finish()) { throw new Error("Symmetric decryption failed.") } msg.content = ciph.output } } }, { "./aes": 7, "./asn1": 9, "./des": 14, "./forge": 16, "./oids": 27, "./pem": 30, "./pkcs7asn1": 34, "./random": 39, "./util": 48, "./x509": 49 }], 34: [function (require, module, exports) { var forge = require("./forge"); require("./asn1"); require("./util"); var asn1 = forge.asn1; var p7v = module.exports = forge.pkcs7asn1 = forge.pkcs7asn1 || {}; forge.pkcs7 = forge.pkcs7 || {}; forge.pkcs7.asn1 = p7v; var contentInfoValidator = { name: "ContentInfo", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.SEQUENCE, constructed: true, value: [{ name: "ContentInfo.ContentType", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.OID, constructed: false, capture: "contentType" }, { name: "ContentInfo.content", tagClass: asn1.Class.CONTEXT_SPECIFIC, type: 0, constructed: true, optional: true, captureAsn1: "content" }] }; p7v.contentInfoValidator = contentInfoValidator; var encryptedContentInfoValidator = { name: "EncryptedContentInfo", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.SEQUENCE, constructed: true, value: [{ name: "EncryptedContentInfo.contentType", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.OID, constructed: false, capture: "contentType" }, { name: "EncryptedContentInfo.contentEncryptionAlgorithm", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.SEQUENCE, constructed: true, value: [{ name: "EncryptedContentInfo.contentEncryptionAlgorithm.algorithm", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.OID, constructed: false, capture: "encAlgorithm" }, { name: "EncryptedContentInfo.contentEncryptionAlgorithm.parameter", tagClass: asn1.Class.UNIVERSAL, captureAsn1: "encParameter" }] }, { name: "EncryptedContentInfo.encryptedContent", tagClass: asn1.Class.CONTEXT_SPECIFIC, type: 0, capture: "encryptedContent", captureAsn1: "encryptedContentAsn1" }] }; p7v.envelopedDataValidator = { name: "EnvelopedData", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.SEQUENCE, constructed: true, value: [{ name: "EnvelopedData.Version", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.INTEGER, constructed: false, capture: "version" }, { name: "EnvelopedData.RecipientInfos", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.SET, constructed: true, captureAsn1: "recipientInfos" }].concat(encryptedContentInfoValidator) }; p7v.encryptedDataValidator = { name: "EncryptedData", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.SEQUENCE, constructed: true, value: [{ name: "EncryptedData.Version", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.INTEGER, constructed: false, capture: "version" }].concat(encryptedContentInfoValidator) }; var signerValidator = { name: "SignerInfo", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.SEQUENCE, constructed: true, value: [{ name: "SignerInfo.version", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.INTEGER, constructed: false }, { name: "SignerInfo.issuerAndSerialNumber", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.SEQUENCE, constructed: true, value: [{ name: "SignerInfo.issuerAndSerialNumber.issuer", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.SEQUENCE, constructed: true, captureAsn1: "issuer" }, { name: "SignerInfo.issuerAndSerialNumber.serialNumber", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.INTEGER, constructed: false, capture: "serial" }] }, { name: "SignerInfo.digestAlgorithm", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.SEQUENCE, constructed: true, value: [{ name: "SignerInfo.digestAlgorithm.algorithm", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.OID, constructed: false, capture: "digestAlgorithm" }, { name: "SignerInfo.digestAlgorithm.parameter", tagClass: asn1.Class.UNIVERSAL, constructed: false, captureAsn1: "digestParameter", optional: true }] }, { name: "SignerInfo.authenticatedAttributes", tagClass: asn1.Class.CONTEXT_SPECIFIC, type: 0, constructed: true, optional: true, capture: "authenticatedAttributes" }, { name: "SignerInfo.digestEncryptionAlgorithm", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.SEQUENCE, constructed: true, capture: "signatureAlgorithm" }, { name: "SignerInfo.encryptedDigest", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.OCTETSTRING, constructed: false, capture: "signature" }, { name: "SignerInfo.unauthenticatedAttributes", tagClass: asn1.Class.CONTEXT_SPECIFIC, type: 1, constructed: true, optional: true, capture: "unauthenticatedAttributes" }] }; p7v.signedDataValidator = { name: "SignedData", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.SEQUENCE, constructed: true, value: [{ name: "SignedData.Version", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.INTEGER, constructed: false, capture: "version" }, { name: "SignedData.DigestAlgorithms", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.SET, constructed: true, captureAsn1: "digestAlgorithms" }, contentInfoValidator, { name: "SignedData.Certificates", tagClass: asn1.Class.CONTEXT_SPECIFIC, type: 0, optional: true, captureAsn1: "certificates" }, { name: "SignedData.CertificateRevocationLists", tagClass: asn1.Class.CONTEXT_SPECIFIC, type: 1, optional: true, captureAsn1: "crls" }, { name: "SignedData.SignerInfos", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.SET, capture: "signerInfos", optional: true, value: [signerValidator] }] }; p7v.recipientInfoValidator = { name: "RecipientInfo", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.SEQUENCE, constructed: true, value: [{ name: "RecipientInfo.version", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.INTEGER, constructed: false, capture: "version" }, { name: "RecipientInfo.issuerAndSerial", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.SEQUENCE, constructed: true, value: [{ name: "RecipientInfo.issuerAndSerial.issuer", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.SEQUENCE, constructed: true, captureAsn1: "issuer" }, { name: "RecipientInfo.issuerAndSerial.serialNumber", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.INTEGER, constructed: false, capture: "serial" }] }, { name: "RecipientInfo.keyEncryptionAlgorithm", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.SEQUENCE, constructed: true, value: [{ name: "RecipientInfo.keyEncryptionAlgorithm.algorithm", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.OID, constructed: false, capture: "encAlgorithm" }, { name: "RecipientInfo.keyEncryptionAlgorithm.parameter", tagClass: asn1.Class.UNIVERSAL, constructed: false, captureAsn1: "encParameter" }] }, { name: "RecipientInfo.encryptedKey", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.OCTETSTRING, constructed: false, capture: "encKey" }] } }, { "./asn1": 9, "./forge": 16, "./util": 48 }], 35: [function (require, module, exports) { var forge = require("./forge"); require("./asn1"); require("./oids"); require("./pbe"); require("./pem"); require("./pbkdf2"); require("./pkcs12"); require("./pss"); require("./rsa"); require("./util"); require("./x509"); var asn1 = forge.asn1; var pki = module.exports = forge.pki = forge.pki || {}; pki.pemToDer = function (pem) { var msg = forge.pem.decode(pem)[0]; if (msg.procType && msg.procType.type === "ENCRYPTED") { throw new Error("Could not convert PEM to DER; PEM is encrypted.") } return forge.util.createBuffer(msg.body) }; pki.privateKeyFromPem = function (pem) { var msg = forge.pem.decode(pem)[0]; if (msg.type !== "PRIVATE KEY" && msg.type !== "RSA PRIVATE KEY") { var error = new Error("Could not convert private key from PEM; PEM " + 'header type is not "PRIVATE KEY" or "RSA PRIVATE KEY".'); error.headerType = msg.type; throw error } if (msg.procType && msg.procType.type === "ENCRYPTED") { throw new Error("Could not convert private key from PEM; PEM is encrypted.") } var obj = asn1.fromDer(msg.body); return pki.privateKeyFromAsn1(obj) }; pki.privateKeyToPem = function (key, maxline) { var msg = { type: "RSA PRIVATE KEY", body: asn1.toDer(pki.privateKeyToAsn1(key)).getBytes() }; return forge.pem.encode(msg, { maxline: maxline }) }; pki.privateKeyInfoToPem = function (pki, maxline) { var msg = { type: "PRIVATE KEY", body: asn1.toDer(pki).getBytes() }; return forge.pem.encode(msg, { maxline: maxline }) } }, { "./asn1": 9, "./forge": 16, "./oids": 27, "./pbe": 28, "./pbkdf2": 29, "./pem": 30, "./pkcs12": 32, "./pss": 38, "./rsa": 41, "./util": 48, "./x509": 49 }], 36: [function (require, module, exports) { var forge = require("./forge"); require("./util"); require("./jsbn"); require("./random"); (function () { if (forge.prime) { module.exports = forge.prime; return } var prime = module.exports = forge.prime = forge.prime || {}; var BigInteger = forge.jsbn.BigInteger; var GCD_30_DELTA = [6, 4, 2, 4, 2, 4, 6, 2]; var THIRTY = new BigInteger(null); THIRTY.fromInt(30); var op_or = function (x, y) { return x | y }; prime.generateProbablePrime = function (bits, options, callback) { if (typeof options === "function") { callback = options; options = {} } options = options || {}; var algorithm = options.algorithm || "PRIMEINC"; if (typeof algorithm === "string") { algorithm = { name: algorithm } } algorithm.options = algorithm.options || {}; var prng = options.prng || forge.random; var rng = { nextBytes: function (x) { var b = prng.getBytesSync(x.length); for (var i = 0; i < x.length; ++i) { x[i] = b.charCodeAt(i) } } }; if (algorithm.name === "PRIMEINC") { return primeincFindPrime(bits, rng, algorithm.options, callback) } throw new Error("Invalid prime generation algorithm: " + algorithm.name) }; function primeincFindPrime(bits, rng, options, callback) { if ("workers" in options) { return primeincFindPrimeWithWorkers(bits, rng, options, callback) } return primeincFindPrimeWithoutWorkers(bits, rng, options, callback) } function primeincFindPrimeWithoutWorkers(bits, rng, options, callback) { var num = generateRandom(bits, rng); var deltaIdx = 0; var mrTests = getMillerRabinTests(num.bitLength()); if ("millerRabinTests" in options) { mrTests = options.millerRabinTests } var maxBlockTime = 10; if ("maxBlockTime" in options) { maxBlockTime = options.maxBlockTime } _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback) } function _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback) { var start = +new Date; do { if (num.bitLength() > bits) { num = generateRandom(bits, rng) } if (num.isProbablePrime(mrTests)) { return callback(null, num) } num.dAddOffset(GCD_30_DELTA[deltaIdx++ % 8], 0) } while (maxBlockTime < 0 || +new Date - start < maxBlockTime); forge.util.setImmediate(function () { _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback) }) } function primeincFindPrimeWithWorkers(bits, rng, options, callback) { if (typeof Worker === "undefined") { return primeincFindPrimeWithoutWorkers(bits, rng, options, callback) } var num = generateRandom(bits, rng); var numWorkers = options.workers; var workLoad = options.workLoad || 100; var range = workLoad * 30 / 8; var workerScript = options.workerScript || "forge/prime.worker.js"; if (numWorkers === -1) { return forge.util.estimateCores(function (err, cores) { if (err) { cores = 2 } numWorkers = cores - 1; generate() }) } generate(); function generate() { numWorkers = Math.max(1, numWorkers); var workers = []; for (var i = 0; i < numWorkers; ++i) { workers[i] = new Worker(workerScript) } var running = numWorkers; for (var i = 0; i < numWorkers; ++i) { workers[i].addEventListener("message", workerMessage) } var found = false; function workerMessage(e) { if (found) { return } --running; var data = e.data; if (data.found) { for (var i = 0; i < workers.length; ++i) { workers[i].terminate() } found = true; return callback(null, new BigInteger(data.prime, 16)) } if (num.bitLength() > bits) { num = generateRandom(bits, rng) } var hex = num.toString(16); e.target.postMessage({ hex: hex, workLoad: workLoad }); num.dAddOffset(range, 0) } } } function generateRandom(bits, rng) { var num = new BigInteger(bits, rng); var bits1 = bits - 1; if (!num.testBit(bits1)) { num.bitwiseTo(BigInteger.ONE.shiftLeft(bits1), op_or, num) } num.dAddOffset(31 - num.mod(THIRTY).byteValue(), 0); return num } function getMillerRabinTests(bits) { if (bits <= 100) return 27; if (bits <= 150) return 18; if (bits <= 200) return 15; if (bits <= 250) return 12; if (bits <= 300) return 9; if (bits <= 350) return 8; if (bits <= 400) return 7; if (bits <= 500) return 6; if (bits <= 600) return 5; if (bits <= 800) return 4; if (bits <= 1250) return 3; return 2 } })() }, { "./forge": 16, "./jsbn": 19, "./random": 39, "./util": 48 }], 37: [function (require, module, exports) { (function (process) { var forge = require("./forge"); require("./util"); var _crypto = null; if (forge.util.isNodejs && !forge.options.usePureJavaScript && !process.versions["node-webkit"]) { _crypto = require("crypto") } var prng = module.exports = forge.prng = forge.prng || {}; prng.create = function (plugin) { var ctx = { plugin: plugin, key: null, seed: null, time: null, reseeds: 0, generated: 0, keyBytes: "" }; var md = plugin.md; var pools = new Array(32); for (var i = 0; i < 32; ++i) { pools[i] = md.create() } ctx.pools = pools; ctx.pool = 0; ctx.generate = function (count, callback) { if (!callback) { return ctx.generateSync(count) } var cipher = ctx.plugin.cipher; var increment = ctx.plugin.increment; var formatKey = ctx.plugin.formatKey; var formatSeed = ctx.plugin.formatSeed; var b = forge.util.createBuffer(); ctx.key = null; generate(); function generate(err) { if (err) { return callback(err) } if (b.length() >= count) { return callback(null, b.getBytes(count)) } if (ctx.generated > 1048575) { ctx.key = null } if (ctx.key === null) { return forge.util.nextTick(function () { _reseed(generate) }) } var bytes = cipher(ctx.key, ctx.seed); ctx.generated += bytes.length; b.putBytes(bytes); ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed))); ctx.seed = formatSeed(cipher(ctx.key, ctx.seed)); forge.util.setImmediate(generate) } }; ctx.generateSync = function (count) { var cipher = ctx.plugin.cipher; var increment = ctx.plugin.increment; var formatKey = ctx.plugin.formatKey; var formatSeed = ctx.plugin.formatSeed; ctx.key = null; var b = forge.util.createBuffer(); while (b.length() < count) { if (ctx.generated > 1048575) { ctx.key = null } if (ctx.key === null) { _reseedSync() } var bytes = cipher(ctx.key, ctx.seed); ctx.generated += bytes.length; b.putBytes(bytes); ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed))); ctx.seed = formatSeed(cipher(ctx.key, ctx.seed)) } return b.getBytes(count) }; function _reseed(callback) { if (ctx.pools[0].messageLength >= 32) { _seed(); return callback() } var needed = 32 - ctx.pools[0].messageLength << 5; ctx.seedFile(needed, function (err, bytes) { if (err) { return callback(err) } ctx.collect(bytes); _seed(); callback() }) } function _reseedSync() { if (ctx.pools[0].messageLength >= 32) { return _seed() } var needed = 32 - ctx.pools[0].messageLength << 5; ctx.collect(ctx.seedFileSync(needed)); _seed() } function _seed() { ctx.reseeds = ctx.reseeds === 4294967295 ? 0 : ctx.reseeds + 1; var md = ctx.plugin.md.create(); md.update(ctx.keyBytes); var _2powK = 1; for (var k = 0; k < 32; ++k) { if (ctx.reseeds % _2powK === 0) { md.update(ctx.pools[k].digest().getBytes()); ctx.pools[k].start() } _2powK = _2powK << 1 } ctx.keyBytes = md.digest().getBytes(); md.start(); md.update(ctx.keyBytes); var seedBytes = md.digest().getBytes(); ctx.key = ctx.plugin.formatKey(ctx.keyBytes); ctx.seed = ctx.plugin.formatSeed(seedBytes); ctx.generated = 0 } function defaultSeedFile(needed) { var getRandomValues = null; var globalScope = forge.util.globalScope; var _crypto = globalScope.crypto || globalScope.msCrypto; if (_crypto && _crypto.getRandomValues) { getRandomValues = function (arr) { return _crypto.getRandomValues(arr) } } var b = forge.util.createBuffer(); if (getRandomValues) { while (b.length() < needed) { var count = Math.max(1, Math.min(needed - b.length(), 65536) / 4); var entropy = new Uint32Array(Math.floor(count)); try { getRandomValues(entropy); for (var i = 0; i < entropy.length; ++i) { b.putInt32(entropy[i]) } } catch (e) { if (!(typeof QuotaExceededError !== "undefined" && e instanceof QuotaExceededError)) { throw e } } } } if (b.length() < needed) { var hi, lo, next; var seed = Math.floor(Math.random() * 65536); while (b.length() < needed) { lo = 16807 * (seed & 65535); hi = 16807 * (seed >> 16); lo += (hi & 32767) << 16; lo += hi >> 15; lo = (lo & 2147483647) + (lo >> 31); seed = lo & 4294967295; for (var i = 0; i < 3; ++i) { next = seed >>> (i << 3); next ^= Math.floor(Math.random() * 256); b.putByte(String.fromCharCode(next & 255)) } } } return b.getBytes(needed) } if (_crypto) { ctx.seedFile = function (needed, callback) { _crypto.randomBytes(needed, function (err, bytes) { if (err) { return callback(err) } callback(null, bytes.toString()) }) }; ctx.seedFileSync = function (needed) { return _crypto.randomBytes(needed).toString() } } else { ctx.seedFile = function (needed, callback) { try { callback(null, defaultSeedFile(needed)) } catch (e) { callback(e) } }; ctx.seedFileSync = defaultSeedFile } ctx.collect = function (bytes) { var count = bytes.length; for (var i = 0; i < count; ++i) { ctx.pools[ctx.pool].update(bytes.substr(i, 1)); ctx.pool = ctx.pool === 31 ? 0 : ctx.pool + 1 } }; ctx.collectInt = function (i, n) { var bytes = ""; for (var x = 0; x < n; x += 8) { bytes += String.fromCharCode(i >> x & 255) } ctx.collect(bytes) }; ctx.registerWorker = function (worker) { if (worker === self) { ctx.seedFile = function (needed, callback) { function listener(e) { var data = e.data; if (data.forge && data.forge.prng) { self.removeEventListener("message", listener); callback(data.forge.prng.err, data.forge.prng.bytes) } } self.addEventListener("message", listener); self.postMessage({ forge: { prng: { needed: needed } } }) } } else { var listener = function (e) { var data = e.data; if (data.forge && data.forge.prng) { ctx.seedFile(data.forge.prng.needed, function (err, bytes) { worker.postMessage({ forge: { prng: { err: err, bytes: bytes } } }) }) } }; worker.addEventListener("message", listener) } }; return ctx } }).call(this, require("_process")) }, { "./forge": 16, "./util": 48, _process: 50, crypto: 6 }], 38: [function (require, module, exports) { var forge = require("./forge"); require("./random"); require("./util"); var pss = module.exports = forge.pss = forge.pss || {}; pss.create = function (options) { if (arguments.length === 3) { options = { md: arguments[0], mgf: arguments[1], saltLength: arguments[2] } } var hash = options.md; var mgf = options.mgf; var hLen = hash.digestLength; var salt_ = options.salt || null; if (typeof salt_ === "string") { salt_ = forge.util.createBuffer(salt_) } var sLen; if ("saltLength" in options) { sLen = options.saltLength } else if (salt_ !== null) { sLen = salt_.length() } else { throw new Error("Salt length not specified or specific salt not given.") } if (salt_ !== null && salt_.length() !== sLen) { throw new Error("Given salt length does not match length of given salt.") } var prng = options.prng || forge.random; var pssobj = {}; pssobj.encode = function (md, modBits) { var i; var emBits = modBits - 1; var emLen = Math.ceil(emBits / 8); var mHash = md.digest().getBytes(); if (emLen < hLen + sLen + 2) { throw new Error("Message is too long to encrypt.") } var salt; if (salt_ === null) { salt = prng.getBytesSync(sLen) } else { salt = salt_.bytes() } var m_ = new forge.util.ByteBuffer; m_.fillWithByte(0, 8); m_.putBytes(mHash); m_.putBytes(salt); hash.start(); hash.update(m_.getBytes()); var h = hash.digest().getBytes(); var ps = new forge.util.ByteBuffer; ps.fillWithByte(0, emLen - sLen - hLen - 2); ps.putByte(1); ps.putBytes(salt); var db = ps.getBytes(); var maskLen = emLen - hLen - 1; var dbMask = mgf.generate(h, maskLen); var maskedDB = ""; for (i = 0; i < maskLen; i++) { maskedDB += String.fromCharCode(db.charCodeAt(i) ^ dbMask.charCodeAt(i)) } var mask = 65280 >> 8 * emLen - emBits & 255; maskedDB = String.fromCharCode(maskedDB.charCodeAt(0) & ~mask) + maskedDB.substr(1); return maskedDB + h + String.fromCharCode(188) }; pssobj.verify = function (mHash, em, modBits) { var i; var emBits = modBits - 1; var emLen = Math.ceil(emBits / 8); em = em.substr(-emLen); if (emLen < hLen + sLen + 2) { throw new Error("Inconsistent parameters to PSS signature verification.") } if (em.charCodeAt(emLen - 1) !== 188) { throw new Error("Encoded message does not end in 0xBC.") } var maskLen = emLen - hLen - 1; var maskedDB = em.substr(0, maskLen); var h = em.substr(maskLen, hLen); var mask = 65280 >> 8 * emLen - emBits & 255; if ((maskedDB.charCodeAt(0) & mask) !== 0) { throw new Error("Bits beyond keysize not zero as expected.") } var dbMask = mgf.generate(h, maskLen); var db = ""; for (i = 0; i < maskLen; i++) { db += String.fromCharCode(maskedDB.charCodeAt(i) ^ dbMask.charCodeAt(i)) } db = String.fromCharCode(db.charCodeAt(0) & ~mask) + db.substr(1); var checkLen = emLen - hLen - sLen - 2; for (i = 0; i < checkLen; i++) { if (db.charCodeAt(i) !== 0) { throw new Error("Leftmost octets not zero as expected") } } if (db.charCodeAt(checkLen) !== 1) { throw new Error("Inconsistent PSS signature, 0x01 marker not found") } var salt = db.substr(-sLen); var m_ = new forge.util.ByteBuffer; m_.fillWithByte(0, 8); m_.putBytes(mHash); m_.putBytes(salt); hash.start(); hash.update(m_.getBytes()); var h_ = hash.digest().getBytes(); return h === h_ }; return pssobj } }, { "./forge": 16, "./random": 39, "./util": 48 }], 39: [function (require, module, exports) { var forge = require("./forge"); require("./aes"); require("./sha256"); require("./prng"); require("./util"); (function () { if (forge.random && forge.random.getBytes) { module.exports = forge.random; return } (function (jQuery) { var prng_aes = {}; var _prng_aes_output = new Array(4); var _prng_aes_buffer = forge.util.createBuffer(); prng_aes.formatKey = function (key) { var tmp = forge.util.createBuffer(key); key = new Array(4); key[0] = tmp.getInt32(); key[1] = tmp.getInt32(); key[2] = tmp.getInt32(); key[3] = tmp.getInt32(); return forge.aes._expandKey(key, false) }; prng_aes.formatSeed = function (seed) { var tmp = forge.util.createBuffer(seed); seed = new Array(4); seed[0] = tmp.getInt32(); seed[1] = tmp.getInt32(); seed[2] = tmp.getInt32(); seed[3] = tmp.getInt32(); return seed }; prng_aes.cipher = function (key, seed) { forge.aes._updateBlock(key, seed, _prng_aes_output, false); _prng_aes_buffer.putInt32(_prng_aes_output[0]); _prng_aes_buffer.putInt32(_prng_aes_output[1]); _prng_aes_buffer.putInt32(_prng_aes_output[2]); _prng_aes_buffer.putInt32(_prng_aes_output[3]); return _prng_aes_buffer.getBytes() }; prng_aes.increment = function (seed) { ++seed[3]; return seed }; prng_aes.md = forge.md.sha256; function spawnPrng() { var ctx = forge.prng.create(prng_aes); ctx.getBytes = function (count, callback) { return ctx.generate(count, callback) }; ctx.getBytesSync = function (count) { return ctx.generate(count) }; return ctx } var _ctx = spawnPrng(); var getRandomValues = null; var globalScope = forge.util.globalScope; var _crypto = globalScope.crypto || globalScope.msCrypto; if (_crypto && _crypto.getRandomValues) { getRandomValues = function (arr) { return _crypto.getRandomValues(arr) } } if (forge.options.usePureJavaScript || !forge.util.isNodejs && !getRandomValues) { if (typeof window === "undefined" || window.document === undefined) { } _ctx.collectInt(+new Date, 32); if (typeof navigator !== "undefined") { var _navBytes = ""; for (var key in navigator) { try { if (typeof navigator[key] == "string") { _navBytes += navigator[key] } } catch (e) { } } _ctx.collect(_navBytes); _navBytes = null } if (jQuery) { jQuery().mousemove(function (e) { _ctx.collectInt(e.clientX, 16); _ctx.collectInt(e.clientY, 16) }); jQuery().keypress(function (e) { _ctx.collectInt(e.charCode, 8) }) } } if (!forge.random) { forge.random = _ctx } else { for (var key in _ctx) { forge.random[key] = _ctx[key] } } forge.random.createInstance = spawnPrng; module.exports = forge.random })(typeof jQuery !== "undefined" ? jQuery : null) })() }, { "./aes": 7, "./forge": 16, "./prng": 37, "./sha256": 43, "./util": 48 }], 40: [function (require, module, exports) { var forge = require("./forge"); require("./util"); var piTable = [217, 120, 249, 196, 25, 221, 181, 237, 40, 233, 253, 121, 74, 160, 216, 157, 198, 126, 55, 131, 43, 118, 83, 142, 98, 76, 100, 136, 68, 139, 251, 162, 23, 154, 89, 245, 135, 179, 79, 19, 97, 69, 109, 141, 9, 129, 125, 50, 189, 143, 64, 235, 134, 183, 123, 11, 240, 149, 33, 34, 92, 107, 78, 130, 84, 214, 101, 147, 206, 96, 178, 28, 115, 86, 192, 20, 167, 140, 241, 220, 18, 117, 202, 31, 59, 190, 228, 209, 66, 61, 212, 48, 163, 60, 182, 38, 111, 191, 14, 218, 70, 105, 7, 87, 39, 242, 29, 155, 188, 148, 67, 3, 248, 17, 199, 246, 144, 239, 62, 231, 6, 195, 213, 47, 200, 102, 30, 215, 8, 232, 234, 222, 128, 82, 238, 247, 132, 170, 114, 172, 53, 77, 106, 42, 150, 26, 210, 113, 90, 21, 73, 116, 75, 159, 208, 94, 4, 24, 164, 236, 194, 224, 65, 110, 15, 81, 203, 204, 36, 145, 175, 80, 161, 244, 112, 57, 153, 124, 58, 133, 35, 184, 180, 122, 252, 2, 54, 91, 37, 85, 151, 49, 45, 93, 250, 152, 227, 138, 146, 174, 5, 223, 41, 16, 103, 108, 186, 201, 211, 0, 230, 207, 225, 158, 168, 44, 99, 22, 1, 63, 88, 226, 137, 169, 13, 56, 52, 27, 171, 51, 255, 176, 187, 72, 12, 95, 185, 177, 205, 46, 197, 243, 219, 71, 229, 165, 156, 119, 10, 166, 32, 104, 254, 127, 193, 173]; var s = [1, 2, 3, 5]; var rol = function (word, bits) { return word << bits & 65535 | (word & 65535) >> 16 - bits }; var ror = function (word, bits) { return (word & 65535) >> bits | word << 16 - bits & 65535 }; module.exports = forge.rc2 = forge.rc2 || {}; forge.rc2.expandKey = function (key, effKeyBits) { if (typeof key === "string") { key = forge.util.createBuffer(key) } effKeyBits = effKeyBits || 128; var L = key; var T = key.length(); var T1 = effKeyBits; var T8 = Math.ceil(T1 / 8); var TM = 255 >> (T1 & 7); var i; for (i = T; i < 128; i++) { L.putByte(piTable[L.at(i - 1) + L.at(i - T) & 255]) } L.setAt(128 - T8, piTable[L.at(128 - T8) & TM]); for (i = 127 - T8; i >= 0; i--) { L.setAt(i, piTable[L.at(i + 1) ^ L.at(i + T8)]) } return L }; var createCipher = function (key, bits, encrypt) { var _finish = false, _input = null, _output = null, _iv = null; var mixRound, mashRound; var i, j, K = []; key = forge.rc2.expandKey(key, bits); for (i = 0; i < 64; i++) { K.push(key.getInt16Le()) } if (encrypt) { mixRound = function (R) { for (i = 0; i < 4; i++) { R[i] += K[j] + (R[(i + 3) % 4] & R[(i + 2) % 4]) + (~R[(i + 3) % 4] & R[(i + 1) % 4]); R[i] = rol(R[i], s[i]); j++ } }; mashRound = function (R) { for (i = 0; i < 4; i++) { R[i] += K[R[(i + 3) % 4] & 63] } } } else { mixRound = function (R) { for (i = 3; i >= 0; i--) { R[i] = ror(R[i], s[i]); R[i] -= K[j] + (R[(i + 3) % 4] & R[(i + 2) % 4]) + (~R[(i + 3) % 4] & R[(i + 1) % 4]); j-- } }; mashRound = function (R) { for (i = 3; i >= 0; i--) { R[i] -= K[R[(i + 3) % 4] & 63] } } } var runPlan = function (plan) { var R = []; for (i = 0; i < 4; i++) { var val = _input.getInt16Le(); if (_iv !== null) { if (encrypt) { val ^= _iv.getInt16Le() } else { _iv.putInt16Le(val) } } R.push(val & 65535) } j = encrypt ? 0 : 63; for (var ptr = 0; ptr < plan.length; ptr++) { for (var ctr = 0; ctr < plan[ptr][0]; ctr++) { plan[ptr][1](R) } } for (i = 0; i < 4; i++) { if (_iv !== null) { if (encrypt) { _iv.putInt16Le(R[i]) } else { R[i] ^= _iv.getInt16Le() } } _output.putInt16Le(R[i]) } }; var cipher = null; cipher = { start: function (iv, output) { if (iv) { if (typeof iv === "string") { iv = forge.util.createBuffer(iv) } } _finish = false; _input = forge.util.createBuffer(); _output = output || new forge.util.createBuffer; _iv = iv; cipher.output = _output }, update: function (input) { if (!_finish) { _input.putBuffer(input) } while (_input.length() >= 8) { runPlan([[5, mixRound], [1, mashRound], [6, mixRound], [1, mashRound], [5, mixRound]]) } }, finish: function (pad) { var rval = true; if (encrypt) { if (pad) { rval = pad(8, _input, !encrypt) } else { var padding = _input.length() === 8 ? 8 : 8 - _input.length(); _input.fillWithByte(padding, padding) } } if (rval) { _finish = true; cipher.update() } if (!encrypt) { rval = _input.length() === 0; if (rval) { if (pad) { rval = pad(8, _output, !encrypt) } else { var len = _output.length(); var count = _output.at(len - 1); if (count > len) { rval = false } else { _output.truncate(count) } } } } return rval } }; return cipher }; forge.rc2.startEncrypting = function (key, iv, output) { var cipher = forge.rc2.createEncryptionCipher(key, 128); cipher.start(iv, output); return cipher }; forge.rc2.createEncryptionCipher = function (key, bits) { return createCipher(key, bits, true) }; forge.rc2.startDecrypting = function (key, iv, output) { var cipher = forge.rc2.createDecryptionCipher(key, 128); cipher.start(iv, output); return cipher }; forge.rc2.createDecryptionCipher = function (key, bits) { return createCipher(key, bits, false) } }, { "./forge": 16, "./util": 48 }], 41: [function (require, module, exports) { var forge = require("./forge"); require("./asn1"); require("./jsbn"); require("./oids"); require("./pkcs1"); require("./prime"); require("./random"); require("./util"); if (typeof BigInteger === "undefined") { var BigInteger = forge.jsbn.BigInteger } var _crypto = forge.util.isNodejs ? require("crypto") : null; var asn1 = forge.asn1; var util = forge.util; forge.pki = forge.pki || {}; module.exports = forge.pki.rsa = forge.rsa = forge.rsa || {}; var pki = forge.pki; var GCD_30_DELTA = [6, 4, 2, 4, 2, 4, 6, 2]; var privateKeyValidator = { name: "PrivateKeyInfo", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.SEQUENCE, constructed: true, value: [{ name: "PrivateKeyInfo.version", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.INTEGER, constructed: false, capture: "privateKeyVersion" }, { name: "PrivateKeyInfo.privateKeyAlgorithm", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.SEQUENCE, constructed: true, value: [{ name: "AlgorithmIdentifier.algorithm", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.OID, constructed: false, capture: "privateKeyOid" }] }, { name: "PrivateKeyInfo", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.OCTETSTRING, constructed: false, capture: "privateKey" }] }; var rsaPrivateKeyValidator = { name: "RSAPrivateKey", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.SEQUENCE, constructed: true, value: [{ name: "RSAPrivateKey.version", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.INTEGER, constructed: false, capture: "privateKeyVersion" }, { name: "RSAPrivateKey.modulus", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.INTEGER, constructed: false, capture: "privateKeyModulus" }, { name: "RSAPrivateKey.publicExponent", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.INTEGER, constructed: false, capture: "privateKeyPublicExponent" }, { name: "RSAPrivateKey.privateExponent", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.INTEGER, constructed: false, capture: "privateKeyPrivateExponent" }, { name: "RSAPrivateKey.prime1", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.INTEGER, constructed: false, capture: "privateKeyPrime1" }, { name: "RSAPrivateKey.prime2", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.INTEGER, constructed: false, capture: "privateKeyPrime2" }, { name: "RSAPrivateKey.exponent1", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.INTEGER, constructed: false, capture: "privateKeyExponent1" }, { name: "RSAPrivateKey.exponent2", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.INTEGER, constructed: false, capture: "privateKeyExponent2" }, { name: "RSAPrivateKey.coefficient", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.INTEGER, constructed: false, capture: "privateKeyCoefficient" }] }; var rsaPublicKeyValidator = { name: "RSAPublicKey", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.SEQUENCE, constructed: true, value: [{ name: "RSAPublicKey.modulus", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.INTEGER, constructed: false, capture: "publicKeyModulus" }, { name: "RSAPublicKey.exponent", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.INTEGER, constructed: false, capture: "publicKeyExponent" }] }; var publicKeyValidator = forge.pki.rsa.publicKeyValidator = { name: "SubjectPublicKeyInfo", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.SEQUENCE, constructed: true, captureAsn1: "subjectPublicKeyInfo", value: [{ name: "SubjectPublicKeyInfo.AlgorithmIdentifier", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.SEQUENCE, constructed: true, value: [{ name: "AlgorithmIdentifier.algorithm", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.OID, constructed: false, capture: "publicKeyOid" }] }, { name: "SubjectPublicKeyInfo.subjectPublicKey", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.BITSTRING, constructed: false, value: [{ name: "SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.SEQUENCE, constructed: true, optional: true, captureAsn1: "rsaPublicKey" }] }] }; var emsaPkcs1v15encode = function (md) { var oid; if (md.algorithm in pki.oids) { oid = pki.oids[md.algorithm] } else { var error = new Error("Unknown message digest algorithm."); error.algorithm = md.algorithm; throw error } var oidBytes = asn1.oidToDer(oid).getBytes(); var digestInfo = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []); var digestAlgorithm = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []); digestAlgorithm.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, oidBytes)); digestAlgorithm.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")); var digest = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, md.digest().getBytes()); digestInfo.value.push(digestAlgorithm); digestInfo.value.push(digest); return asn1.toDer(digestInfo).getBytes() }; var _modPow = function (x, key, pub) { if (pub) { return x.modPow(key.e, key.n) } if (!key.p || !key.q) { return x.modPow(key.d, key.n) } if (!key.dP) { key.dP = key.d.mod(key.p.subtract(BigInteger.ONE)) } if (!key.dQ) { key.dQ = key.d.mod(key.q.subtract(BigInteger.ONE)) } if (!key.qInv) { key.qInv = key.q.modInverse(key.p) } var r; do { r = new BigInteger(forge.util.bytesToHex(forge.random.getBytes(key.n.bitLength() / 8)), 16) } while (r.compareTo(key.n) >= 0 || !r.gcd(key.n).equals(BigInteger.ONE)); x = x.multiply(r.modPow(key.e, key.n)).mod(key.n); var xp = x.mod(key.p).modPow(key.dP, key.p); var xq = x.mod(key.q).modPow(key.dQ, key.q); while (xp.compareTo(xq) < 0) { xp = xp.add(key.p) } var y = xp.subtract(xq).multiply(key.qInv).mod(key.p).multiply(key.q).add(xq); y = y.multiply(r.modInverse(key.n)).mod(key.n); return y }; pki.rsa.encrypt = function (m, key, bt) { var pub = bt; var eb; var k = Math.ceil(key.n.bitLength() / 8); if (bt !== false && bt !== true) { pub = bt === 2; eb = _encodePkcs1_v1_5(m, key, bt) } else { eb = forge.util.createBuffer(); eb.putBytes(m) } var x = new BigInteger(eb.toHex(), 16); var y = _modPow(x, key, pub); var yhex = y.toString(16); var ed = forge.util.createBuffer(); var zeros = k - Math.ceil(yhex.length / 2); while (zeros > 0) { ed.putByte(0); --zeros } ed.putBytes(forge.util.hexToBytes(yhex)); return ed.getBytes() }; pki.rsa.decrypt = function (ed, key, pub, ml) { var k = Math.ceil(key.n.bitLength() / 8); if (ed.length !== k) { var error = new Error("Encrypted message length is invalid."); error.length = ed.length; error.expected = k; throw error } var y = new BigInteger(forge.util.createBuffer(ed).toHex(), 16); if (y.compareTo(key.n) >= 0) { throw new Error("Encrypted message is invalid.") } var x = _modPow(y, key, pub); var xhex = x.toString(16); var eb = forge.util.createBuffer(); var zeros = k - Math.ceil(xhex.length / 2); while (zeros > 0) { eb.putByte(0); --zeros } eb.putBytes(forge.util.hexToBytes(xhex)); if (ml !== false) { return _decodePkcs1_v1_5(eb.getBytes(), key, pub) } return eb.getBytes() }; pki.rsa.createKeyPairGenerationState = function (bits, e, options) { if (typeof bits === "string") { bits = parseInt(bits, 10) } bits = bits || 2048; options = options || {}; var prng = options.prng || forge.random; var rng = { nextBytes: function (x) { var b = prng.getBytesSync(x.length); for (var i = 0; i < x.length; ++i) { x[i] = b.charCodeAt(i) } } }; var algorithm = options.algorithm || "PRIMEINC"; var rval; if (algorithm === "PRIMEINC") { rval = { algorithm: algorithm, state: 0, bits: bits, rng: rng, eInt: e || 65537, e: new BigInteger(null), p: null, q: null, qBits: bits >> 1, pBits: bits - (bits >> 1), pqState: 0, num: null, keys: null }; rval.e.fromInt(rval.eInt) } else { throw new Error("Invalid key generation algorithm: " + algorithm) } return rval }; pki.rsa.stepKeyPairGenerationState = function (state, n) { if (!("algorithm" in state)) { state.algorithm = "PRIMEINC" } var THIRTY = new BigInteger(null); THIRTY.fromInt(30); var deltaIdx = 0; var op_or = function (x, y) { return x | y }; var t1 = +new Date; var t2; var total = 0; while (state.keys === null && (n <= 0 || total < n)) { if (state.state === 0) { var bits = state.p === null ? state.pBits : state.qBits; var bits1 = bits - 1; if (state.pqState === 0) { state.num = new BigInteger(bits, state.rng); if (!state.num.testBit(bits1)) { state.num.bitwiseTo(BigInteger.ONE.shiftLeft(bits1), op_or, state.num) } state.num.dAddOffset(31 - state.num.mod(THIRTY).byteValue(), 0); deltaIdx = 0; ++state.pqState } else if (state.pqState === 1) { if (state.num.bitLength() > bits) { state.pqState = 0 } else if (state.num.isProbablePrime(_getMillerRabinTests(state.num.bitLength()))) { ++state.pqState } else { state.num.dAddOffset(GCD_30_DELTA[deltaIdx++ % 8], 0) } } else if (state.pqState === 2) { state.pqState = state.num.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) === 0 ? 3 : 0 } else if (state.pqState === 3) { state.pqState = 0; if (state.p === null) { state.p = state.num } else { state.q = state.num } if (state.p !== null && state.q !== null) { ++state.state } state.num = null } } else if (state.state === 1) { if (state.p.compareTo(state.q) < 0) { state.num = state.p; state.p = state.q; state.q = state.num } ++state.state } else if (state.state === 2) { state.p1 = state.p.subtract(BigInteger.ONE); state.q1 = state.q.subtract(BigInteger.ONE); state.phi = state.p1.multiply(state.q1); ++state.state } else if (state.state === 3) { if (state.phi.gcd(state.e).compareTo(BigInteger.ONE) === 0) { ++state.state } else { state.p = null; state.q = null; state.state = 0 } } else if (state.state === 4) { state.n = state.p.multiply(state.q); if (state.n.bitLength() === state.bits) { ++state.state } else { state.q = null; state.state = 0 } } else if (state.state === 5) { var d = state.e.modInverse(state.phi); state.keys = { privateKey: pki.rsa.setPrivateKey(state.n, state.e, d, state.p, state.q, d.mod(state.p1), d.mod(state.q1), state.q.modInverse(state.p)), publicKey: pki.rsa.setPublicKey(state.n, state.e) } } t2 = +new Date; total += t2 - t1; t1 = t2 } return state.keys !== null }; pki.rsa.generateKeyPair = function (bits, e, options, callback) { if (arguments.length === 1) { if (typeof bits === "object") { options = bits; bits = undefined } else if (typeof bits === "function") { callback = bits; bits = undefined } } else if (arguments.length === 2) { if (typeof bits === "number") { if (typeof e === "function") { callback = e; e = undefined } else if (typeof e !== "number") { options = e; e = undefined } } else { options = bits; callback = e; bits = undefined; e = undefined } } else if (arguments.length === 3) { if (typeof e === "number") { if (typeof options === "function") { callback = options; options = undefined } } else { callback = options; options = e; e = undefined } } options = options || {}; if (bits === undefined) { bits = options.bits || 2048 } if (e === undefined) { e = options.e || 65537 } if (!forge.options.usePureJavaScript && !options.prng && bits >= 256 && bits <= 16384 && (e === 65537 || e === 3)) { if (callback) { if (_detectNodeCrypto("generateKeyPair")) { return _crypto.generateKeyPair("rsa", { modulusLength: bits, publicExponent: e, publicKeyEncoding: { type: "spki", format: "pem" }, privateKeyEncoding: { type: "pkcs8", format: "pem" } }, function (err, pub, priv) { if (err) { return callback(err) } callback(null, { privateKey: pki.privateKeyFromPem(priv), publicKey: pki.publicKeyFromPem(pub) }) }) } if (_detectSubtleCrypto("generateKey") && _detectSubtleCrypto("exportKey")) { return util.globalScope.crypto.subtle.generateKey({ name: "RSASSA-PKCS1-v1_5", modulusLength: bits, publicExponent: _intToUint8Array(e), hash: { name: "SHA-256" } }, true, ["sign", "verify"]).then(function (pair) { return util.globalScope.crypto.subtle.exportKey("pkcs8", pair.privateKey) }).then(undefined, function (err) { callback(err) }).then(function (pkcs8) { if (pkcs8) { var privateKey = pki.privateKeyFromAsn1(asn1.fromDer(forge.util.createBuffer(pkcs8))); callback(null, { privateKey: privateKey, publicKey: pki.setRsaPublicKey(privateKey.n, privateKey.e) }) } }) } if (_detectSubtleMsCrypto("generateKey") && _detectSubtleMsCrypto("exportKey")) { var genOp = util.globalScope.msCrypto.subtle.generateKey({ name: "RSASSA-PKCS1-v1_5", modulusLength: bits, publicExponent: _intToUint8Array(e), hash: { name: "SHA-256" } }, true, ["sign", "verify"]); genOp.oncomplete = function (e) { var pair = e.target.result; var exportOp = util.globalScope.msCrypto.subtle.exportKey("pkcs8", pair.privateKey); exportOp.oncomplete = function (e) { var pkcs8 = e.target.result; var privateKey = pki.privateKeyFromAsn1(asn1.fromDer(forge.util.createBuffer(pkcs8))); callback(null, { privateKey: privateKey, publicKey: pki.setRsaPublicKey(privateKey.n, privateKey.e) }) }; exportOp.onerror = function (err) { callback(err) } }; genOp.onerror = function (err) { callback(err) }; return } } else { if (_detectNodeCrypto("generateKeyPairSync")) { var keypair = _crypto.generateKeyPairSync("rsa", { modulusLength: bits, publicExponent: e, publicKeyEncoding: { type: "spki", format: "pem" }, privateKeyEncoding: { type: "pkcs8", format: "pem" } }); return { privateKey: pki.privateKeyFromPem(keypair.privateKey), publicKey: pki.publicKeyFromPem(keypair.publicKey) } } } } var state = pki.rsa.createKeyPairGenerationState(bits, e, options); if (!callback) { pki.rsa.stepKeyPairGenerationState(state, 0); return state.keys } _generateKeyPair(state, options, callback) }; pki.setRsaPublicKey = pki.rsa.setPublicKey = function (n, e) { var key = { n: n, e: e }; key.encrypt = function (data, scheme, schemeOptions) { if (typeof scheme === "string") { scheme = scheme.toUpperCase() } else if (scheme === undefined) { scheme = "RSAES-PKCS1-V1_5" } if (scheme === "RSAES-PKCS1-V1_5") { scheme = { encode: function (m, key, pub) { return _encodePkcs1_v1_5(m, key, 2).getBytes() } } } else if (scheme === "RSA-OAEP" || scheme === "RSAES-OAEP") { scheme = { encode: function (m, key) { return forge.pkcs1.encode_rsa_oaep(key, m, schemeOptions) } } } else if (["RAW", "NONE", "NULL", null].indexOf(scheme) !== -1) { scheme = { encode: function (e) { return e } } } else if (typeof scheme === "string") { throw new Error('Unsupported encryption scheme: "' + scheme + '".') } var e = scheme.encode(data, key, true); return pki.rsa.encrypt(e, key, true) }; key.verify = function (digest, signature, scheme) { if (typeof scheme === "string") { scheme = scheme.toUpperCase() } else if (scheme === undefined) { scheme = "RSASSA-PKCS1-V1_5" } if (scheme === "RSASSA-PKCS1-V1_5") { scheme = { verify: function (digest, d) { d = _decodePkcs1_v1_5(d, key, true); var obj = asn1.fromDer(d); return digest === obj.value[1].value } } } else if (scheme === "NONE" || scheme === "NULL" || scheme === null) { scheme = { verify: function (digest, d) { d = _decodePkcs1_v1_5(d, key, true); return digest === d } } } var d = pki.rsa.decrypt(signature, key, true, false); return scheme.verify(digest, d, key.n.bitLength()) }; return key }; pki.setRsaPrivateKey = pki.rsa.setPrivateKey = function (n, e, d, p, q, dP, dQ, qInv) { var key = { n: n, e: e, d: d, p: p, q: q, dP: dP, dQ: dQ, qInv: qInv }; key.decrypt = function (data, scheme, schemeOptions) { if (typeof scheme === "string") { scheme = scheme.toUpperCase() } else if (scheme === undefined) { scheme = "RSAES-PKCS1-V1_5" } var d = pki.rsa.decrypt(data, key, false, false); if (scheme === "RSAES-PKCS1-V1_5") { scheme = { decode: _decodePkcs1_v1_5 } } else if (scheme === "RSA-OAEP" || scheme === "RSAES-OAEP") { scheme = { decode: function (d, key) { return forge.pkcs1.decode_rsa_oaep(key, d, schemeOptions) } } } else if (["RAW", "NONE", "NULL", null].indexOf(scheme) !== -1) { scheme = { decode: function (d) { return d } } } else { throw new Error('Unsupported encryption scheme: "' + scheme + '".') } return scheme.decode(d, key, false) }; key.sign = function (md, scheme) { var bt = false; if (typeof scheme === "string") { scheme = scheme.toUpperCase() } if (scheme === undefined || scheme === "RSASSA-PKCS1-V1_5") { scheme = { encode: emsaPkcs1v15encode }; bt = 1 } else if (scheme === "NONE" || scheme === "NULL" || scheme === null) { scheme = { encode: function () { return md } }; bt = 1 } var d = scheme.encode(md, key.n.bitLength()); return pki.rsa.encrypt(d, key, bt) }; return key }; pki.wrapRsaPrivateKey = function (rsaKey) { return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(0).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.rsaEncryption).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")]), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, asn1.toDer(rsaKey).getBytes())]) }; pki.privateKeyFromAsn1 = function (obj) { var capture = {}; var errors = []; if (asn1.validate(obj, privateKeyValidator, capture, errors)) { obj = asn1.fromDer(forge.util.createBuffer(capture.privateKey)) } capture = {}; errors = []; if (!asn1.validate(obj, rsaPrivateKeyValidator, capture, errors)) { var error = new Error("Cannot read private key. " + "ASN.1 object does not contain an RSAPrivateKey."); error.errors = errors; throw error } var n, e, d, p, q, dP, dQ, qInv; n = forge.util.createBuffer(capture.privateKeyModulus).toHex(); e = forge.util.createBuffer(capture.privateKeyPublicExponent).toHex(); d = forge.util.createBuffer(capture.privateKeyPrivateExponent).toHex(); p = forge.util.createBuffer(capture.privateKeyPrime1).toHex(); q = forge.util.createBuffer(capture.privateKeyPrime2).toHex(); dP = forge.util.createBuffer(capture.privateKeyExponent1).toHex(); dQ = forge.util.createBuffer(capture.privateKeyExponent2).toHex(); qInv = forge.util.createBuffer(capture.privateKeyCoefficient).toHex(); return pki.setRsaPrivateKey(new BigInteger(n, 16), new BigInteger(e, 16), new BigInteger(d, 16), new BigInteger(p, 16), new BigInteger(q, 16), new BigInteger(dP, 16), new BigInteger(dQ, 16), new BigInteger(qInv, 16)) }; pki.privateKeyToAsn1 = pki.privateKeyToRSAPrivateKey = function (key) { return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(0).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.n)), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.e)), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.d)), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.p)), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.q)), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.dP)), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.dQ)), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.qInv))]) }; pki.publicKeyFromAsn1 = function (obj) { var capture = {}; var errors = []; if (asn1.validate(obj, publicKeyValidator, capture, errors)) { var oid = asn1.derToOid(capture.publicKeyOid); if (oid !== pki.oids.rsaEncryption) { var error = new Error("Cannot read public key. Unknown OID."); error.oid = oid; throw error } obj = capture.rsaPublicKey } errors = []; if (!asn1.validate(obj, rsaPublicKeyValidator, capture, errors)) { var error = new Error("Cannot read public key. " + "ASN.1 object does not contain an RSAPublicKey."); error.errors = errors; throw error } var n = forge.util.createBuffer(capture.publicKeyModulus).toHex(); var e = forge.util.createBuffer(capture.publicKeyExponent).toHex(); return pki.setRsaPublicKey(new BigInteger(n, 16), new BigInteger(e, 16)) }; pki.publicKeyToAsn1 = pki.publicKeyToSubjectPublicKeyInfo = function (key) { return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.rsaEncryption).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")]), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, [pki.publicKeyToRSAPublicKey(key)])]) }; pki.publicKeyToRSAPublicKey = function (key) { return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.n)), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.e))]) }; function _encodePkcs1_v1_5(m, key, bt) { var eb = forge.util.createBuffer(); var k = Math.ceil(key.n.bitLength() / 8); if (m.length > k - 11) { var error = new Error("Message is too long for PKCS#1 v1.5 padding."); error.length = m.length; error.max = k - 11; throw error } eb.putByte(0); eb.putByte(bt); var padNum = k - 3 - m.length; var padByte; if (bt === 0 || bt === 1) { padByte = bt === 0 ? 0 : 255; for (var i = 0; i < padNum; ++i) { eb.putByte(padByte) } } else { while (padNum > 0) { var numZeros = 0; var padBytes = forge.random.getBytes(padNum); for (var i = 0; i < padNum; ++i) { padByte = padBytes.charCodeAt(i); if (padByte === 0) { ++numZeros } else { eb.putByte(padByte) } } padNum = numZeros } } eb.putByte(0); eb.putBytes(m); return eb } function _decodePkcs1_v1_5(em, key, pub, ml) { var k = Math.ceil(key.n.bitLength() / 8); var eb = forge.util.createBuffer(em); var first = eb.getByte(); var bt = eb.getByte(); if (first !== 0 || pub && bt !== 0 && bt !== 1 || !pub && bt != 2 || pub && bt === 0 && typeof ml === "undefined") { throw new Error("Encryption block is invalid.") } var padNum = 0; if (bt === 0) { padNum = k - 3 - ml; for (var i = 0; i < padNum; ++i) { if (eb.getByte() !== 0) { throw new Error("Encryption block is invalid.") } } } else if (bt === 1) { padNum = 0; while (eb.length() > 1) { if (eb.getByte() !== 255) { --eb.read; break } ++padNum } } else if (bt === 2) { padNum = 0; while (eb.length() > 1) { if (eb.getByte() === 0) { --eb.read; break } ++padNum } } var zero = eb.getByte(); if (zero !== 0 || padNum !== k - 3 - eb.length()) { throw new Error("Encryption block is invalid.") } return eb.getBytes() } function _generateKeyPair(state, options, callback) { if (typeof options === "function") { callback = options; options = {} } options = options || {}; var opts = { algorithm: { name: options.algorithm || "PRIMEINC", options: { workers: options.workers || 2, workLoad: options.workLoad || 100, workerScript: options.workerScript } } }; if ("prng" in options) { opts.prng = options.prng } generate(); function generate() { getPrime(state.pBits, function (err, num) { if (err) { return callback(err) } state.p = num; if (state.q !== null) { return finish(err, state.q) } getPrime(state.qBits, finish) }) } function getPrime(bits, callback) { forge.prime.generateProbablePrime(bits, opts, callback) } function finish(err, num) { if (err) { return callback(err) } state.q = num; if (state.p.compareTo(state.q) < 0) { var tmp = state.p; state.p = state.q; state.q = tmp } if (state.p.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) !== 0) { state.p = null; generate(); return } if (state.q.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) !== 0) { state.q = null; getPrime(state.qBits, finish); return } state.p1 = state.p.subtract(BigInteger.ONE); state.q1 = state.q.subtract(BigInteger.ONE); state.phi = state.p1.multiply(state.q1); if (state.phi.gcd(state.e).compareTo(BigInteger.ONE) !== 0) { state.p = state.q = null; generate(); return } state.n = state.p.multiply(state.q); if (state.n.bitLength() !== state.bits) { state.q = null; getPrime(state.qBits, finish); return } var d = state.e.modInverse(state.phi); state.keys = { privateKey: pki.rsa.setPrivateKey(state.n, state.e, d, state.p, state.q, d.mod(state.p1), d.mod(state.q1), state.q.modInverse(state.p)), publicKey: pki.rsa.setPublicKey(state.n, state.e) }; callback(null, state.keys) } } function _bnToBytes(b) { var hex = b.toString(16); if (hex[0] >= "8") { hex = "00" + hex } var bytes = forge.util.hexToBytes(hex); if (bytes.length > 1 && (bytes.charCodeAt(0) === 0 && (bytes.charCodeAt(1) & 128) === 0 || bytes.charCodeAt(0) === 255 && (bytes.charCodeAt(1) & 128) === 128)) { return bytes.substr(1) } return bytes } function _getMillerRabinTests(bits) { if (bits <= 100) return 27; if (bits <= 150) return 18; if (bits <= 200) return 15; if (bits <= 250) return 12; if (bits <= 300) return 9; if (bits <= 350) return 8; if (bits <= 400) return 7; if (bits <= 500) return 6; if (bits <= 600) return 5; if (bits <= 800) return 4; if (bits <= 1250) return 3; return 2 } function _detectNodeCrypto(fn) { return forge.util.isNodejs && typeof _crypto[fn] === "function" } function _detectSubtleCrypto(fn) { return typeof util.globalScope !== "undefined" && typeof util.globalScope.crypto === "object" && typeof util.globalScope.crypto.subtle === "object" && typeof util.globalScope.crypto.subtle[fn] === "function" } function _detectSubtleMsCrypto(fn) { return typeof util.globalScope !== "undefined" && typeof util.globalScope.msCrypto === "object" && typeof util.globalScope.msCrypto.subtle === "object" && typeof util.globalScope.msCrypto.subtle[fn] === "function" } function _intToUint8Array(x) { var bytes = forge.util.hexToBytes(x.toString(16)); var buffer = new Uint8Array(bytes.length); for (var i = 0; i < bytes.length; ++i) { buffer[i] = bytes.charCodeAt(i) } return buffer } function _privateKeyFromJwk(jwk) { if (jwk.kty !== "RSA") { throw new Error('Unsupported key algorithm "' + jwk.kty + '"; algorithm must be "RSA".') } return pki.setRsaPrivateKey(_base64ToBigInt(jwk.n), _base64ToBigInt(jwk.e), _base64ToBigInt(jwk.d), _base64ToBigInt(jwk.p), _base64ToBigInt(jwk.q), _base64ToBigInt(jwk.dp), _base64ToBigInt(jwk.dq), _base64ToBigInt(jwk.qi)) } function _publicKeyFromJwk(jwk) { if (jwk.kty !== "RSA") { throw new Error('Key algorithm must be "RSA".') } return pki.setRsaPublicKey(_base64ToBigInt(jwk.n), _base64ToBigInt(jwk.e)) } function _base64ToBigInt(b64) { return new BigInteger(forge.util.bytesToHex(forge.util.decode64(b64)), 16) } }, { "./asn1": 9, "./forge": 16, "./jsbn": 19, "./oids": 27, "./pkcs1": 31, "./prime": 36, "./random": 39, "./util": 48, crypto: 6 }], 42: [function (require, module, exports) { var forge = require("./forge"); require("./md"); require("./util"); var sha1 = module.exports = forge.sha1 = forge.sha1 || {}; forge.md.sha1 = forge.md.algorithms.sha1 = sha1; sha1.create = function () { if (!_initialized) { _init() } var _state = null; var _input = forge.util.createBuffer(); var _w = new Array(80); var md = { algorithm: "sha1", blockLength: 64, digestLength: 20, messageLength: 0, fullMessageLength: null, messageLengthSize: 8 }; md.start = function () { md.messageLength = 0; md.fullMessageLength = md.messageLength64 = []; var int32s = md.messageLengthSize / 4; for (var i = 0; i < int32s; ++i) { md.fullMessageLength.push(0) } _input = forge.util.createBuffer(); _state = { h0: 1732584193, h1: 4023233417, h2: 2562383102, h3: 271733878, h4: 3285377520 }; return md }; md.start(); md.update = function (msg, encoding) { if (encoding === "utf8") { msg = forge.util.encodeUtf8(msg) } var len = msg.length; md.messageLength += len; len = [len / 4294967296 >>> 0, len >>> 0]; for (var i = md.fullMessageLength.length - 1; i >= 0; --i) { md.fullMessageLength[i] += len[1]; len[1] = len[0] + (md.fullMessageLength[i] / 4294967296 >>> 0); md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0; len[0] = len[1] / 4294967296 >>> 0 } _input.putBytes(msg); _update(_state, _w, _input); if (_input.read > 2048 || _input.length() === 0) { _input.compact() } return md }; md.digest = function () { var finalBlock = forge.util.createBuffer(); finalBlock.putBytes(_input.bytes()); var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize; var overflow = remaining & md.blockLength - 1; finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow)); var next, carry; var bits = md.fullMessageLength[0] * 8; for (var i = 0; i < md.fullMessageLength.length - 1; ++i) { next = md.fullMessageLength[i + 1] * 8; carry = next / 4294967296 >>> 0; bits += carry; finalBlock.putInt32(bits >>> 0); bits = next >>> 0 } finalBlock.putInt32(bits); var s2 = { h0: _state.h0, h1: _state.h1, h2: _state.h2, h3: _state.h3, h4: _state.h4 }; _update(s2, _w, finalBlock); var rval = forge.util.createBuffer(); rval.putInt32(s2.h0); rval.putInt32(s2.h1); rval.putInt32(s2.h2); rval.putInt32(s2.h3); rval.putInt32(s2.h4); return rval }; return md }; var _padding = null; var _initialized = false; function _init() { _padding = String.fromCharCode(128); _padding += forge.util.fillString(String.fromCharCode(0), 64); _initialized = true } function _update(s, w, bytes) { var t, a, b, c, d, e, f, i; var len = bytes.length(); while (len >= 64) { a = s.h0; b = s.h1; c = s.h2; d = s.h3; e = s.h4; for (i = 0; i < 16; ++i) { t = bytes.getInt32(); w[i] = t; f = d ^ b & (c ^ d); t = (a << 5 | a >>> 27) + f + e + 1518500249 + t; e = d; d = c; c = (b << 30 | b >>> 2) >>> 0; b = a; a = t } for (; i < 20; ++i) { t = w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16]; t = t << 1 | t >>> 31; w[i] = t; f = d ^ b & (c ^ d); t = (a << 5 | a >>> 27) + f + e + 1518500249 + t; e = d; d = c; c = (b << 30 | b >>> 2) >>> 0; b = a; a = t } for (; i < 32; ++i) { t = w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16]; t = t << 1 | t >>> 31; w[i] = t; f = b ^ c ^ d; t = (a << 5 | a >>> 27) + f + e + 1859775393 + t; e = d; d = c; c = (b << 30 | b >>> 2) >>> 0; b = a; a = t } for (; i < 40; ++i) { t = w[i - 6] ^ w[i - 16] ^ w[i - 28] ^ w[i - 32]; t = t << 2 | t >>> 30; w[i] = t; f = b ^ c ^ d; t = (a << 5 | a >>> 27) + f + e + 1859775393 + t; e = d; d = c; c = (b << 30 | b >>> 2) >>> 0; b = a; a = t } for (; i < 60; ++i) { t = w[i - 6] ^ w[i - 16] ^ w[i - 28] ^ w[i - 32]; t = t << 2 | t >>> 30; w[i] = t; f = b & c | d & (b ^ c); t = (a << 5 | a >>> 27) + f + e + 2400959708 + t; e = d; d = c; c = (b << 30 | b >>> 2) >>> 0; b = a; a = t } for (; i < 80; ++i) { t = w[i - 6] ^ w[i - 16] ^ w[i - 28] ^ w[i - 32]; t = t << 2 | t >>> 30; w[i] = t; f = b ^ c ^ d; t = (a << 5 | a >>> 27) + f + e + 3395469782 + t; e = d; d = c; c = (b << 30 | b >>> 2) >>> 0; b = a; a = t } s.h0 = s.h0 + a | 0; s.h1 = s.h1 + b | 0; s.h2 = s.h2 + c | 0; s.h3 = s.h3 + d | 0; s.h4 = s.h4 + e | 0; len -= 64 } } }, { "./forge": 16, "./md": 23, "./util": 48 }], 43: [function (require, module, exports) { var forge = require("./forge"); require("./md"); require("./util"); var sha256 = module.exports = forge.sha256 = forge.sha256 || {}; forge.md.sha256 = forge.md.algorithms.sha256 = sha256; sha256.create = function () { if (!_initialized) { _init() } var _state = null; var _input = forge.util.createBuffer(); var _w = new Array(64); var md = { algorithm: "sha256", blockLength: 64, digestLength: 32, messageLength: 0, fullMessageLength: null, messageLengthSize: 8 }; md.start = function () { md.messageLength = 0; md.fullMessageLength = md.messageLength64 = []; var int32s = md.messageLengthSize / 4; for (var i = 0; i < int32s; ++i) { md.fullMessageLength.push(0) } _input = forge.util.createBuffer(); _state = { h0: 1779033703, h1: 3144134277, h2: 1013904242, h3: 2773480762, h4: 1359893119, h5: 2600822924, h6: 528734635, h7: 1541459225 }; return md }; md.start(); md.update = function (msg, encoding) { if (encoding === "utf8") { msg = forge.util.encodeUtf8(msg) } var len = msg.length; md.messageLength += len; len = [len / 4294967296 >>> 0, len >>> 0]; for (var i = md.fullMessageLength.length - 1; i >= 0; --i) { md.fullMessageLength[i] += len[1]; len[1] = len[0] + (md.fullMessageLength[i] / 4294967296 >>> 0); md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0; len[0] = len[1] / 4294967296 >>> 0 } _input.putBytes(msg); _update(_state, _w, _input); if (_input.read > 2048 || _input.length() === 0) { _input.compact() } return md }; md.digest = function () { var finalBlock = forge.util.createBuffer(); finalBlock.putBytes(_input.bytes()); var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize; var overflow = remaining & md.blockLength - 1; finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow)); var next, carry; var bits = md.fullMessageLength[0] * 8; for (var i = 0; i < md.fullMessageLength.length - 1; ++i) { next = md.fullMessageLength[i + 1] * 8; carry = next / 4294967296 >>> 0; bits += carry; finalBlock.putInt32(bits >>> 0); bits = next >>> 0 } finalBlock.putInt32(bits); var s2 = { h0: _state.h0, h1: _state.h1, h2: _state.h2, h3: _state.h3, h4: _state.h4, h5: _state.h5, h6: _state.h6, h7: _state.h7 }; _update(s2, _w, finalBlock); var rval = forge.util.createBuffer(); rval.putInt32(s2.h0); rval.putInt32(s2.h1); rval.putInt32(s2.h2); rval.putInt32(s2.h3); rval.putInt32(s2.h4); rval.putInt32(s2.h5); rval.putInt32(s2.h6); rval.putInt32(s2.h7); return rval }; return md }; var _padding = null; var _initialized = false; var _k = null; function _init() { _padding = String.fromCharCode(128); _padding += forge.util.fillString(String.fromCharCode(0), 64); _k = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]; _initialized = true } function _update(s, w, bytes) { var t1, t2, s0, s1, ch, maj, i, a, b, c, d, e, f, g, h; var len = bytes.length(); while (len >= 64) { for (i = 0; i < 16; ++i) { w[i] = bytes.getInt32() } for (; i < 64; ++i) { t1 = w[i - 2]; t1 = (t1 >>> 17 | t1 << 15) ^ (t1 >>> 19 | t1 << 13) ^ t1 >>> 10; t2 = w[i - 15]; t2 = (t2 >>> 7 | t2 << 25) ^ (t2 >>> 18 | t2 << 14) ^ t2 >>> 3; w[i] = t1 + w[i - 7] + t2 + w[i - 16] | 0 } a = s.h0; b = s.h1; c = s.h2; d = s.h3; e = s.h4; f = s.h5; g = s.h6; h = s.h7; for (i = 0; i < 64; ++i) { s1 = (e >>> 6 | e << 26) ^ (e >>> 11 | e << 21) ^ (e >>> 25 | e << 7); ch = g ^ e & (f ^ g); s0 = (a >>> 2 | a << 30) ^ (a >>> 13 | a << 19) ^ (a >>> 22 | a << 10); maj = a & b | c & (a ^ b); t1 = h + s1 + ch + _k[i] + w[i]; t2 = s0 + maj; h = g; g = f; f = e; e = d + t1 >>> 0; d = c; c = b; b = a; a = t1 + t2 >>> 0 } s.h0 = s.h0 + a | 0; s.h1 = s.h1 + b | 0; s.h2 = s.h2 + c | 0; s.h3 = s.h3 + d | 0; s.h4 = s.h4 + e | 0; s.h5 = s.h5 + f | 0; s.h6 = s.h6 + g | 0; s.h7 = s.h7 + h | 0; len -= 64 } } }, { "./forge": 16, "./md": 23, "./util": 48 }], 44: [function (require, module, exports) { var forge = require("./forge"); require("./md"); require("./util"); var sha512 = module.exports = forge.sha512 = forge.sha512 || {}; forge.md.sha512 = forge.md.algorithms.sha512 = sha512; var sha384 = forge.sha384 = forge.sha512.sha384 = forge.sha512.sha384 || {}; sha384.create = function () { return sha512.create("SHA-384") }; forge.md.sha384 = forge.md.algorithms.sha384 = sha384; forge.sha512.sha256 = forge.sha512.sha256 || { create: function () { return sha512.create("SHA-512/256") } }; forge.md["sha512/256"] = forge.md.algorithms["sha512/256"] = forge.sha512.sha256; forge.sha512.sha224 = forge.sha512.sha224 || { create: function () { return sha512.create("SHA-512/224") } }; forge.md["sha512/224"] = forge.md.algorithms["sha512/224"] = forge.sha512.sha224; sha512.create = function (algorithm) { if (!_initialized) { _init() } if (typeof algorithm === "undefined") { algorithm = "SHA-512" } if (!(algorithm in _states)) { throw new Error("Invalid SHA-512 algorithm: " + algorithm) } var _state = _states[algorithm]; var _h = null; var _input = forge.util.createBuffer(); var _w = new Array(80); for (var wi = 0; wi < 80; ++wi) { _w[wi] = new Array(2) } var digestLength = 64; switch (algorithm) { case "SHA-384": digestLength = 48; break; case "SHA-512/256": digestLength = 32; break; case "SHA-512/224": digestLength = 28; break }var md = { algorithm: algorithm.replace("-", "").toLowerCase(), blockLength: 128, digestLength: digestLength, messageLength: 0, fullMessageLength: null, messageLengthSize: 16 }; md.start = function () { md.messageLength = 0; md.fullMessageLength = md.messageLength128 = []; var int32s = md.messageLengthSize / 4; for (var i = 0; i < int32s; ++i) { md.fullMessageLength.push(0) } _input = forge.util.createBuffer(); _h = new Array(_state.length); for (var i = 0; i < _state.length; ++i) { _h[i] = _state[i].slice(0) } return md }; md.start(); md.update = function (msg, encoding) { if (encoding === "utf8") { msg = forge.util.encodeUtf8(msg) } var len = msg.length; md.messageLength += len; len = [len / 4294967296 >>> 0, len >>> 0]; for (var i = md.fullMessageLength.length - 1; i >= 0; --i) { md.fullMessageLength[i] += len[1]; len[1] = len[0] + (md.fullMessageLength[i] / 4294967296 >>> 0); md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0; len[0] = len[1] / 4294967296 >>> 0 } _input.putBytes(msg); _update(_h, _w, _input); if (_input.read > 2048 || _input.length() === 0) { _input.compact() } return md }; md.digest = function () { var finalBlock = forge.util.createBuffer(); finalBlock.putBytes(_input.bytes()); var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize; var overflow = remaining & md.blockLength - 1; finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow)); var next, carry; var bits = md.fullMessageLength[0] * 8; for (var i = 0; i < md.fullMessageLength.length - 1; ++i) { next = md.fullMessageLength[i + 1] * 8; carry = next / 4294967296 >>> 0; bits += carry; finalBlock.putInt32(bits >>> 0); bits = next >>> 0 } finalBlock.putInt32(bits); var h = new Array(_h.length); for (var i = 0; i < _h.length; ++i) { h[i] = _h[i].slice(0) } _update(h, _w, finalBlock); var rval = forge.util.createBuffer(); var hlen; if (algorithm === "SHA-512") { hlen = h.length } else if (algorithm === "SHA-384") { hlen = h.length - 2 } else { hlen = h.length - 4 } for (var i = 0; i < hlen; ++i) { rval.putInt32(h[i][0]); if (i !== hlen - 1 || algorithm !== "SHA-512/224") { rval.putInt32(h[i][1]) } } return rval }; return md }; var _padding = null; var _initialized = false; var _k = null; var _states = null; function _init() { _padding = String.fromCharCode(128); _padding += forge.util.fillString(String.fromCharCode(0), 128); _k = [[1116352408, 3609767458], [1899447441, 602891725], [3049323471, 3964484399], [3921009573, 2173295548], [961987163, 4081628472], [1508970993, 3053834265], [2453635748, 2937671579], [2870763221, 3664609560], [3624381080, 2734883394], [310598401, 1164996542], [607225278, 1323610764], [1426881987, 3590304994], [1925078388, 4068182383], [2162078206, 991336113], [2614888103, 633803317], [3248222580, 3479774868], [3835390401, 2666613458], [4022224774, 944711139], [264347078, 2341262773], [604807628, 2007800933], [770255983, 1495990901], [1249150122, 1856431235], [1555081692, 3175218132], [1996064986, 2198950837], [2554220882, 3999719339], [2821834349, 766784016], [2952996808, 2566594879], [3210313671, 3203337956], [3336571891, 1034457026], [3584528711, 2466948901], [113926993, 3758326383], [338241895, 168717936], [666307205, 1188179964], [773529912, 1546045734], [1294757372, 1522805485], [1396182291, 2643833823], [1695183700, 2343527390], [1986661051, 1014477480], [2177026350, 1206759142], [2456956037, 344077627], [2730485921, 1290863460], [2820302411, 3158454273], [3259730800, 3505952657], [3345764771, 106217008], [3516065817, 3606008344], [3600352804, 1432725776], [4094571909, 1467031594], [275423344, 851169720], [430227734, 3100823752], [506948616, 1363258195], [659060556, 3750685593], [883997877, 3785050280], [958139571, 3318307427], [1322822218, 3812723403], [1537002063, 2003034995], [1747873779, 3602036899], [1955562222, 1575990012], [2024104815, 1125592928], [2227730452, 2716904306], [2361852424, 442776044], [2428436474, 593698344], [2756734187, 3733110249], [3204031479, 2999351573], [3329325298, 3815920427], [3391569614, 3928383900], [3515267271, 566280711], [3940187606, 3454069534], [4118630271, 4000239992], [116418474, 1914138554], [174292421, 2731055270], [289380356, 3203993006], [460393269, 320620315], [685471733, 587496836], [852142971, 1086792851], [1017036298, 365543100], [1126000580, 2618297676], [1288033470, 3409855158], [1501505948, 4234509866], [1607167915, 987167468], [1816402316, 1246189591]]; _states = {}; _states["SHA-512"] = [[1779033703, 4089235720], [3144134277, 2227873595], [1013904242, 4271175723], [2773480762, 1595750129], [1359893119, 2917565137], [2600822924, 725511199], [528734635, 4215389547], [1541459225, 327033209]]; _states["SHA-384"] = [[3418070365, 3238371032], [1654270250, 914150663], [2438529370, 812702999], [355462360, 4144912697], [1731405415, 4290775857], [2394180231, 1750603025], [3675008525, 1694076839], [1203062813, 3204075428]]; _states["SHA-512/256"] = [[573645204, 4230739756], [2673172387, 3360449730], [596883563, 1867755857], [2520282905, 1497426621], [2519219938, 2827943907], [3193839141, 1401305490], [721525244, 746961066], [246885852, 2177182882]]; _states["SHA-512/224"] = [[2352822216, 424955298], [1944164710, 2312950998], [502970286, 855612546], [1738396948, 1479516111], [258812777, 2077511080], [2011393907, 79989058], [1067287976, 1780299464], [286451373, 2446758561]]; _initialized = true } function _update(s, w, bytes) { var t1_hi, t1_lo; var t2_hi, t2_lo; var s0_hi, s0_lo; var s1_hi, s1_lo; var ch_hi, ch_lo; var maj_hi, maj_lo; var a_hi, a_lo; var b_hi, b_lo; var c_hi, c_lo; var d_hi, d_lo; var e_hi, e_lo; var f_hi, f_lo; var g_hi, g_lo; var h_hi, h_lo; var i, hi, lo, w2, w7, w15, w16; var len = bytes.length(); while (len >= 128) { for (i = 0; i < 16; ++i) { w[i][0] = bytes.getInt32() >>> 0; w[i][1] = bytes.getInt32() >>> 0 } for (; i < 80; ++i) { w2 = w[i - 2]; hi = w2[0]; lo = w2[1]; t1_hi = ((hi >>> 19 | lo << 13) ^ (lo >>> 29 | hi << 3) ^ hi >>> 6) >>> 0; t1_lo = ((hi << 13 | lo >>> 19) ^ (lo << 3 | hi >>> 29) ^ (hi << 26 | lo >>> 6)) >>> 0; w15 = w[i - 15]; hi = w15[0]; lo = w15[1]; t2_hi = ((hi >>> 1 | lo << 31) ^ (hi >>> 8 | lo << 24) ^ hi >>> 7) >>> 0; t2_lo = ((hi << 31 | lo >>> 1) ^ (hi << 24 | lo >>> 8) ^ (hi << 25 | lo >>> 7)) >>> 0; w7 = w[i - 7]; w16 = w[i - 16]; lo = t1_lo + w7[1] + t2_lo + w16[1]; w[i][0] = t1_hi + w7[0] + t2_hi + w16[0] + (lo / 4294967296 >>> 0) >>> 0; w[i][1] = lo >>> 0 } a_hi = s[0][0]; a_lo = s[0][1]; b_hi = s[1][0]; b_lo = s[1][1]; c_hi = s[2][0]; c_lo = s[2][1]; d_hi = s[3][0]; d_lo = s[3][1]; e_hi = s[4][0]; e_lo = s[4][1]; f_hi = s[5][0]; f_lo = s[5][1]; g_hi = s[6][0]; g_lo = s[6][1]; h_hi = s[7][0]; h_lo = s[7][1]; for (i = 0; i < 80; ++i) { s1_hi = ((e_hi >>> 14 | e_lo << 18) ^ (e_hi >>> 18 | e_lo << 14) ^ (e_lo >>> 9 | e_hi << 23)) >>> 0; s1_lo = ((e_hi << 18 | e_lo >>> 14) ^ (e_hi << 14 | e_lo >>> 18) ^ (e_lo << 23 | e_hi >>> 9)) >>> 0; ch_hi = (g_hi ^ e_hi & (f_hi ^ g_hi)) >>> 0; ch_lo = (g_lo ^ e_lo & (f_lo ^ g_lo)) >>> 0; s0_hi = ((a_hi >>> 28 | a_lo << 4) ^ (a_lo >>> 2 | a_hi << 30) ^ (a_lo >>> 7 | a_hi << 25)) >>> 0; s0_lo = ((a_hi << 4 | a_lo >>> 28) ^ (a_lo << 30 | a_hi >>> 2) ^ (a_lo << 25 | a_hi >>> 7)) >>> 0; maj_hi = (a_hi & b_hi | c_hi & (a_hi ^ b_hi)) >>> 0; maj_lo = (a_lo & b_lo | c_lo & (a_lo ^ b_lo)) >>> 0; lo = h_lo + s1_lo + ch_lo + _k[i][1] + w[i][1]; t1_hi = h_hi + s1_hi + ch_hi + _k[i][0] + w[i][0] + (lo / 4294967296 >>> 0) >>> 0; t1_lo = lo >>> 0; lo = s0_lo + maj_lo; t2_hi = s0_hi + maj_hi + (lo / 4294967296 >>> 0) >>> 0; t2_lo = lo >>> 0; h_hi = g_hi; h_lo = g_lo; g_hi = f_hi; g_lo = f_lo; f_hi = e_hi; f_lo = e_lo; lo = d_lo + t1_lo; e_hi = d_hi + t1_hi + (lo / 4294967296 >>> 0) >>> 0; e_lo = lo >>> 0; d_hi = c_hi; d_lo = c_lo; c_hi = b_hi; c_lo = b_lo; b_hi = a_hi; b_lo = a_lo; lo = t1_lo + t2_lo; a_hi = t1_hi + t2_hi + (lo / 4294967296 >>> 0) >>> 0; a_lo = lo >>> 0 } lo = s[0][1] + a_lo; s[0][0] = s[0][0] + a_hi + (lo / 4294967296 >>> 0) >>> 0; s[0][1] = lo >>> 0; lo = s[1][1] + b_lo; s[1][0] = s[1][0] + b_hi + (lo / 4294967296 >>> 0) >>> 0; s[1][1] = lo >>> 0; lo = s[2][1] + c_lo; s[2][0] = s[2][0] + c_hi + (lo / 4294967296 >>> 0) >>> 0; s[2][1] = lo >>> 0; lo = s[3][1] + d_lo; s[3][0] = s[3][0] + d_hi + (lo / 4294967296 >>> 0) >>> 0; s[3][1] = lo >>> 0; lo = s[4][1] + e_lo; s[4][0] = s[4][0] + e_hi + (lo / 4294967296 >>> 0) >>> 0; s[4][1] = lo >>> 0; lo = s[5][1] + f_lo; s[5][0] = s[5][0] + f_hi + (lo / 4294967296 >>> 0) >>> 0; s[5][1] = lo >>> 0; lo = s[6][1] + g_lo; s[6][0] = s[6][0] + g_hi + (lo / 4294967296 >>> 0) >>> 0; s[6][1] = lo >>> 0; lo = s[7][1] + h_lo; s[7][0] = s[7][0] + h_hi + (lo / 4294967296 >>> 0) >>> 0; s[7][1] = lo >>> 0; len -= 128 } } }, { "./forge": 16, "./md": 23, "./util": 48 }], 45: [function (require, module, exports) { var forge = require("./forge"); require("./aes"); require("./hmac"); require("./md5"); require("./sha1"); require("./util"); var ssh = module.exports = forge.ssh = forge.ssh || {}; ssh.privateKeyToPutty = function (privateKey, passphrase, comment) { comment = comment || ""; passphrase = passphrase || ""; var algorithm = "ssh-rsa"; var encryptionAlgorithm = passphrase === "" ? "none" : "aes256-cbc"; var ppk = "PuTTY-User-Key-File-2: " + algorithm + "\r\n"; ppk += "Encryption: " + encryptionAlgorithm + "\r\n"; ppk += "Comment: " + comment + "\r\n"; var pubbuffer = forge.util.createBuffer(); _addStringToBuffer(pubbuffer, algorithm); _addBigIntegerToBuffer(pubbuffer, privateKey.e); _addBigIntegerToBuffer(pubbuffer, privateKey.n); var pub = forge.util.encode64(pubbuffer.bytes(), 64); var length = Math.floor(pub.length / 66) + 1; ppk += "Public-Lines: " + length + "\r\n"; ppk += pub; var privbuffer = forge.util.createBuffer(); _addBigIntegerToBuffer(privbuffer, privateKey.d); _addBigIntegerToBuffer(privbuffer, privateKey.p); _addBigIntegerToBuffer(privbuffer, privateKey.q); _addBigIntegerToBuffer(privbuffer, privateKey.qInv); var priv; if (!passphrase) { priv = forge.util.encode64(privbuffer.bytes(), 64) } else { var encLen = privbuffer.length() + 16 - 1; encLen -= encLen % 16; var padding = _sha1(privbuffer.bytes()); padding.truncate(padding.length() - encLen + privbuffer.length()); privbuffer.putBuffer(padding); var aeskey = forge.util.createBuffer(); aeskey.putBuffer(_sha1("\0\0\0\0", passphrase)); aeskey.putBuffer(_sha1("\0\0\0", passphrase)); var cipher = forge.aes.createEncryptionCipher(aeskey.truncate(8), "CBC"); cipher.start(forge.util.createBuffer().fillWithByte(0, 16)); cipher.update(privbuffer.copy()); cipher.finish(); var encrypted = cipher.output; encrypted.truncate(16); priv = forge.util.encode64(encrypted.bytes(), 64) } length = Math.floor(priv.length / 66) + 1; ppk += "\r\nPrivate-Lines: " + length + "\r\n"; ppk += priv; var mackey = _sha1("putty-private-key-file-mac-key", passphrase); var macbuffer = forge.util.createBuffer(); _addStringToBuffer(macbuffer, algorithm); _addStringToBuffer(macbuffer, encryptionAlgorithm); _addStringToBuffer(macbuffer, comment); macbuffer.putInt32(pubbuffer.length()); macbuffer.putBuffer(pubbuffer); macbuffer.putInt32(privbuffer.length()); macbuffer.putBuffer(privbuffer); var hmac = forge.hmac.create(); hmac.start("sha1", mackey); hmac.update(macbuffer.bytes()); ppk += "\r\nPrivate-MAC: " + hmac.digest().toHex() + "\r\n"; return ppk }; ssh.publicKeyToOpenSSH = function (key, comment) { var type = "ssh-rsa"; comment = comment || ""; var buffer = forge.util.createBuffer(); _addStringToBuffer(buffer, type); _addBigIntegerToBuffer(buffer, key.e); _addBigIntegerToBuffer(buffer, key.n); return type + " " + forge.util.encode64(buffer.bytes()) + " " + comment }; ssh.privateKeyToOpenSSH = function (privateKey, passphrase) { if (!passphrase) { return forge.pki.privateKeyToPem(privateKey) } return forge.pki.encryptRsaPrivateKey(privateKey, passphrase, { legacy: true, algorithm: "aes128" }) }; ssh.getPublicKeyFingerprint = function (key, options) { options = options || {}; var md = options.md || forge.md.md5.create(); var type = "ssh-rsa"; var buffer = forge.util.createBuffer(); _addStringToBuffer(buffer, type); _addBigIntegerToBuffer(buffer, key.e); _addBigIntegerToBuffer(buffer, key.n); md.start(); md.update(buffer.getBytes()); var digest = md.digest(); if (options.encoding === "hex") { var hex = digest.toHex(); if (options.delimiter) { return hex.match(/.{2}/g).join(options.delimiter) } return hex } else if (options.encoding === "binary") { return digest.getBytes() } else if (options.encoding) { throw new Error('Unknown encoding "' + options.encoding + '".') } return digest }; function _addBigIntegerToBuffer(buffer, val) { var hexVal = val.toString(16); if (hexVal[0] >= "8") { hexVal = "00" + hexVal } var bytes = forge.util.hexToBytes(hexVal); buffer.putInt32(bytes.length); buffer.putBytes(bytes) } function _addStringToBuffer(buffer, val) { buffer.putInt32(val.length); buffer.putString(val) } function _sha1() { var sha = forge.md.sha1.create(); var num = arguments.length; for (var i = 0; i < num; ++i) { sha.update(arguments[i]) } return sha.digest() } }, { "./aes": 7, "./forge": 16, "./hmac": 17, "./md5": 24, "./sha1": 42, "./util": 48 }], 46: [function (require, module, exports) { var forge = require("./forge"); require("./debug"); require("./log"); require("./util"); var cat = "forge.task"; var sVL = 0; var sTasks = {}; var sNextTaskId = 0; forge.debug.set(cat, "tasks", sTasks); var sTaskQueues = {}; forge.debug.set(cat, "queues", sTaskQueues); var sNoTaskName = "?"; var sMaxRecursions = 30; var sTimeSlice = 20; var READY = "ready"; var RUNNING = "running"; var BLOCKED = "blocked"; var SLEEPING = "sleeping"; var DONE = "done"; var ERROR = "error"; var STOP = "stop"; var START = "start"; var BLOCK = "block"; var UNBLOCK = "unblock"; var SLEEP = "sleep"; var WAKEUP = "wakeup"; var CANCEL = "cancel"; var FAIL = "fail"; var sStateTable = {}; sStateTable[READY] = {}; sStateTable[READY][STOP] = READY; sStateTable[READY][START] = RUNNING; sStateTable[READY][CANCEL] = DONE; sStateTable[READY][FAIL] = ERROR; sStateTable[RUNNING] = {}; sStateTable[RUNNING][STOP] = READY; sStateTable[RUNNING][START] = RUNNING; sStateTable[RUNNING][BLOCK] = BLOCKED; sStateTable[RUNNING][UNBLOCK] = RUNNING; sStateTable[RUNNING][SLEEP] = SLEEPING; sStateTable[RUNNING][WAKEUP] = RUNNING; sStateTable[RUNNING][CANCEL] = DONE; sStateTable[RUNNING][FAIL] = ERROR; sStateTable[BLOCKED] = {}; sStateTable[BLOCKED][STOP] = BLOCKED; sStateTable[BLOCKED][START] = BLOCKED; sStateTable[BLOCKED][BLOCK] = BLOCKED; sStateTable[BLOCKED][UNBLOCK] = BLOCKED; sStateTable[BLOCKED][SLEEP] = BLOCKED; sStateTable[BLOCKED][WAKEUP] = BLOCKED; sStateTable[BLOCKED][CANCEL] = DONE; sStateTable[BLOCKED][FAIL] = ERROR; sStateTable[SLEEPING] = {}; sStateTable[SLEEPING][STOP] = SLEEPING; sStateTable[SLEEPING][START] = SLEEPING; sStateTable[SLEEPING][BLOCK] = SLEEPING; sStateTable[SLEEPING][UNBLOCK] = SLEEPING; sStateTable[SLEEPING][SLEEP] = SLEEPING; sStateTable[SLEEPING][WAKEUP] = SLEEPING; sStateTable[SLEEPING][CANCEL] = DONE; sStateTable[SLEEPING][FAIL] = ERROR; sStateTable[DONE] = {}; sStateTable[DONE][STOP] = DONE; sStateTable[DONE][START] = DONE; sStateTable[DONE][BLOCK] = DONE; sStateTable[DONE][UNBLOCK] = DONE; sStateTable[DONE][SLEEP] = DONE; sStateTable[DONE][WAKEUP] = DONE; sStateTable[DONE][CANCEL] = DONE; sStateTable[DONE][FAIL] = ERROR; sStateTable[ERROR] = {}; sStateTable[ERROR][STOP] = ERROR; sStateTable[ERROR][START] = ERROR; sStateTable[ERROR][BLOCK] = ERROR; sStateTable[ERROR][UNBLOCK] = ERROR; sStateTable[ERROR][SLEEP] = ERROR; sStateTable[ERROR][WAKEUP] = ERROR; sStateTable[ERROR][CANCEL] = ERROR; sStateTable[ERROR][FAIL] = ERROR; var Task = function (options) { this.id = -1; this.name = options.name || sNoTaskName; this.parent = options.parent || null; this.run = options.run; this.subtasks = []; this.error = false; this.state = READY; this.blocks = 0; this.timeoutId = null; this.swapTime = null; this.userData = null; this.id = sNextTaskId++; sTasks[this.id] = this; if (sVL >= 1) { forge.log.verbose(cat, "[%s][%s] init", this.id, this.name, this) } }; Task.prototype.debug = function (msg) { msg = msg || ""; forge.log.debug(cat, msg, "[%s][%s] task:", this.id, this.name, this, "subtasks:", this.subtasks.length, "queue:", sTaskQueues) }; Task.prototype.next = function (name, subrun) { if (typeof name === "function") { subrun = name; name = this.name } var subtask = new Task({ run: subrun, name: name, parent: this }); subtask.state = RUNNING; subtask.type = this.type; subtask.successCallback = this.successCallback || null; subtask.failureCallback = this.failureCallback || null; this.subtasks.push(subtask); return this }; Task.prototype.parallel = function (name, subrun) { if (forge.util.isArray(name)) { subrun = name; name = this.name } return this.next(name, function (task) { var ptask = task; ptask.block(subrun.length); var startParallelTask = function (pname, pi) { forge.task.start({ type: pname, run: function (task) { subrun[pi](task) }, success: function (task) { ptask.unblock() }, failure: function (task) { ptask.unblock() } }) }; for (var i = 0; i < subrun.length; i++) { var pname = name + "__parallel-" + task.id + "-" + i; var pi = i; startParallelTask(pname, pi) } }) }; Task.prototype.stop = function () { this.state = sStateTable[this.state][STOP] }; Task.prototype.start = function () { this.error = false; this.state = sStateTable[this.state][START]; if (this.state === RUNNING) { this.start = new Date; this.run(this); runNext(this, 0) } }; Task.prototype.block = function (n) { n = typeof n === "undefined" ? 1 : n; this.blocks += n; if (this.blocks > 0) { this.state = sStateTable[this.state][BLOCK] } }; Task.prototype.unblock = function (n) { n = typeof n === "undefined" ? 1 : n; this.blocks -= n; if (this.blocks === 0 && this.state !== DONE) { this.state = RUNNING; runNext(this, 0) } return this.blocks }; Task.prototype.sleep = function (n) { n = typeof n === "undefined" ? 0 : n; this.state = sStateTable[this.state][SLEEP]; var self = this; this.timeoutId = setTimeout(function () { self.timeoutId = null; self.state = RUNNING; runNext(self, 0) }, n) }; Task.prototype.wait = function (cond) { cond.wait(this) }; Task.prototype.wakeup = function () { if (this.state === SLEEPING) { cancelTimeout(this.timeoutId); this.timeoutId = null; this.state = RUNNING; runNext(this, 0) } }; Task.prototype.cancel = function () { this.state = sStateTable[this.state][CANCEL]; this.permitsNeeded = 0; if (this.timeoutId !== null) { cancelTimeout(this.timeoutId); this.timeoutId = null } this.subtasks = [] }; Task.prototype.fail = function (next) { this.error = true; finish(this, true); if (next) { next.error = this.error; next.swapTime = this.swapTime; next.userData = this.userData; runNext(next, 0) } else { if (this.parent !== null) { var parent = this.parent; while (parent.parent !== null) { parent.error = this.error; parent.swapTime = this.swapTime; parent.userData = this.userData; parent = parent.parent } finish(parent, true) } if (this.failureCallback) { this.failureCallback(this) } } }; var start = function (task) { task.error = false; task.state = sStateTable[task.state][START]; setTimeout(function () { if (task.state === RUNNING) { task.swapTime = +new Date; task.run(task); runNext(task, 0) } }, 0) }; var runNext = function (task, recurse) { var swap = recurse > sMaxRecursions || +new Date - task.swapTime > sTimeSlice; var doNext = function (recurse) { recurse++; if (task.state === RUNNING) { if (swap) { task.swapTime = +new Date } if (task.subtasks.length > 0) { var subtask = task.subtasks.shift(); subtask.error = task.error; subtask.swapTime = task.swapTime; subtask.userData = task.userData; subtask.run(subtask); if (!subtask.error) { runNext(subtask, recurse) } } else { finish(task); if (!task.error) { if (task.parent !== null) { task.parent.error = task.error; task.parent.swapTime = task.swapTime; task.parent.userData = task.userData; runNext(task.parent, recurse) } } } } }; if (swap) { setTimeout(doNext, 0) } else { doNext(recurse) } }; var finish = function (task, suppressCallbacks) { task.state = DONE; delete sTasks[task.id]; if (sVL >= 1) { forge.log.verbose(cat, "[%s][%s] finish", task.id, task.name, task) } if (task.parent === null) { if (!(task.type in sTaskQueues)) { forge.log.error(cat, "[%s][%s] task queue missing [%s]", task.id, task.name, task.type) } else if (sTaskQueues[task.type].length === 0) { forge.log.error(cat, "[%s][%s] task queue empty [%s]", task.id, task.name, task.type) } else if (sTaskQueues[task.type][0] !== task) { forge.log.error(cat, "[%s][%s] task not first in queue [%s]", task.id, task.name, task.type) } else { sTaskQueues[task.type].shift(); if (sTaskQueues[task.type].length === 0) { if (sVL >= 1) { forge.log.verbose(cat, "[%s][%s] delete queue [%s]", task.id, task.name, task.type) } delete sTaskQueues[task.type] } else { if (sVL >= 1) { forge.log.verbose(cat, "[%s][%s] queue start next [%s] remain:%s", task.id, task.name, task.type, sTaskQueues[task.type].length) } sTaskQueues[task.type][0].start() } } if (!suppressCallbacks) { if (task.error && task.failureCallback) { task.failureCallback(task) } else if (!task.error && task.successCallback) { task.successCallback(task) } } } }; module.exports = forge.task = forge.task || {}; forge.task.start = function (options) { var task = new Task({ run: options.run, name: options.name || sNoTaskName }); task.type = options.type; task.successCallback = options.success || null; task.failureCallback = options.failure || null; if (!(task.type in sTaskQueues)) { if (sVL >= 1) { forge.log.verbose(cat, "[%s][%s] create queue [%s]", task.id, task.name, task.type) } sTaskQueues[task.type] = [task]; start(task) } else { sTaskQueues[options.type].push(task) } }; forge.task.cancel = function (type) { if (type in sTaskQueues) { sTaskQueues[type] = [sTaskQueues[type][0]] } }; forge.task.createCondition = function () { var cond = { tasks: {} }; cond.wait = function (task) { if (!(task.id in cond.tasks)) { task.block(); cond.tasks[task.id] = task } }; cond.notify = function () { var tmp = cond.tasks; cond.tasks = {}; for (var id in tmp) { tmp[id].unblock() } }; return cond } }, { "./debug": 13, "./forge": 16, "./log": 21, "./util": 48 }], 47: [function (require, module, exports) { var forge = require("./forge"); require("./asn1"); require("./hmac"); require("./md5"); require("./pem"); require("./pki"); require("./random"); require("./sha1"); require("./util"); var prf_TLS1 = function (secret, label, seed, length) { var rval = forge.util.createBuffer(); var idx = secret.length >> 1; var slen = idx + (secret.length & 1); var s1 = secret.substr(0, slen); var s2 = secret.substr(idx, slen); var ai = forge.util.createBuffer(); var hmac = forge.hmac.create(); seed = label + seed; var md5itr = Math.ceil(length / 16); var sha1itr = Math.ceil(length / 20); hmac.start("MD5", s1); var md5bytes = forge.util.createBuffer(); ai.putBytes(seed); for (var i = 0; i < md5itr; ++i) { hmac.start(null, null); hmac.update(ai.getBytes()); ai.putBuffer(hmac.digest()); hmac.start(null, null); hmac.update(ai.bytes() + seed); md5bytes.putBuffer(hmac.digest()) } hmac.start("SHA1", s2); var sha1bytes = forge.util.createBuffer(); ai.clear(); ai.putBytes(seed); for (var i = 0; i < sha1itr; ++i) { hmac.start(null, null); hmac.update(ai.getBytes()); ai.putBuffer(hmac.digest()); hmac.start(null, null); hmac.update(ai.bytes() + seed); sha1bytes.putBuffer(hmac.digest()) } rval.putBytes(forge.util.xorBytes(md5bytes.getBytes(), sha1bytes.getBytes(), length)); return rval }; var prf_sha256 = function (secret, label, seed, length) { }; var hmac_sha1 = function (key, seqNum, record) { var hmac = forge.hmac.create(); hmac.start("SHA1", key); var b = forge.util.createBuffer(); b.putInt32(seqNum[0]); b.putInt32(seqNum[1]); b.putByte(record.type); b.putByte(record.version.major); b.putByte(record.version.minor); b.putInt16(record.length); b.putBytes(record.fragment.bytes()); hmac.update(b.getBytes()); return hmac.digest().getBytes() }; var deflate = function (c, record, s) { var rval = false; try { var bytes = c.deflate(record.fragment.getBytes()); record.fragment = forge.util.createBuffer(bytes); record.length = bytes.length; rval = true } catch (ex) { } return rval }; var inflate = function (c, record, s) { var rval = false; try { var bytes = c.inflate(record.fragment.getBytes()); record.fragment = forge.util.createBuffer(bytes); record.length = bytes.length; rval = true } catch (ex) { } return rval }; var readVector = function (b, lenBytes) { var len = 0; switch (lenBytes) { case 1: len = b.getByte(); break; case 2: len = b.getInt16(); break; case 3: len = b.getInt24(); break; case 4: len = b.getInt32(); break }return forge.util.createBuffer(b.getBytes(len)) }; var writeVector = function (b, lenBytes, v) { b.putInt(v.length(), lenBytes << 3); b.putBuffer(v) }; var tls = {}; tls.Versions = { TLS_1_0: { major: 3, minor: 1 }, TLS_1_1: { major: 3, minor: 2 }, TLS_1_2: { major: 3, minor: 3 } }; tls.SupportedVersions = [tls.Versions.TLS_1_1, tls.Versions.TLS_1_0]; tls.Version = tls.SupportedVersions[0]; tls.MaxFragment = 16384 - 1024; tls.ConnectionEnd = { server: 0, client: 1 }; tls.PRFAlgorithm = { tls_prf_sha256: 0 }; tls.BulkCipherAlgorithm = { none: null, rc4: 0, des3: 1, aes: 2 }; tls.CipherType = { stream: 0, block: 1, aead: 2 }; tls.MACAlgorithm = { none: null, hmac_md5: 0, hmac_sha1: 1, hmac_sha256: 2, hmac_sha384: 3, hmac_sha512: 4 }; tls.CompressionMethod = { none: 0, deflate: 1 }; tls.ContentType = { change_cipher_spec: 20, alert: 21, handshake: 22, application_data: 23, heartbeat: 24 }; tls.HandshakeType = { hello_request: 0, client_hello: 1, server_hello: 2, certificate: 11, server_key_exchange: 12, certificate_request: 13, server_hello_done: 14, certificate_verify: 15, client_key_exchange: 16, finished: 20 }; tls.Alert = {}; tls.Alert.Level = { warning: 1, fatal: 2 }; tls.Alert.Description = { close_notify: 0, unexpected_message: 10, bad_record_mac: 20, decryption_failed: 21, record_overflow: 22, decompression_failure: 30, handshake_failure: 40, bad_certificate: 42, unsupported_certificate: 43, certificate_revoked: 44, certificate_expired: 45, certificate_unknown: 46, illegal_parameter: 47, unknown_ca: 48, access_denied: 49, decode_error: 50, decrypt_error: 51, export_restriction: 60, protocol_version: 70, insufficient_security: 71, internal_error: 80, user_canceled: 90, no_renegotiation: 100 }; tls.HeartbeatMessageType = { heartbeat_request: 1, heartbeat_response: 2 }; tls.CipherSuites = {}; tls.getCipherSuite = function (twoBytes) { var rval = null; for (var key in tls.CipherSuites) { var cs = tls.CipherSuites[key]; if (cs.id[0] === twoBytes.charCodeAt(0) && cs.id[1] === twoBytes.charCodeAt(1)) { rval = cs; break } } return rval }; tls.handleUnexpected = function (c, record) { var ignore = !c.open && c.entity === tls.ConnectionEnd.client; if (!ignore) { c.error(c, { message: "Unexpected message. Received TLS record out of order.", send: true, alert: { level: tls.Alert.Level.fatal, description: tls.Alert.Description.unexpected_message } }) } }; tls.handleHelloRequest = function (c, record, length) { if (!c.handshaking && c.handshakes > 0) { tls.queue(c, tls.createAlert(c, { level: tls.Alert.Level.warning, description: tls.Alert.Description.no_renegotiation })); tls.flush(c) } c.process() }; tls.parseHelloMessage = function (c, record, length) { var msg = null; var client = c.entity === tls.ConnectionEnd.client; if (length < 38) { c.error(c, { message: client ? "Invalid ServerHello message. Message too short." : "Invalid ClientHello message. Message too short.", send: true, alert: { level: tls.Alert.Level.fatal, description: tls.Alert.Description.illegal_parameter } }) } else { var b = record.fragment; var remaining = b.length(); msg = { version: { major: b.getByte(), minor: b.getByte() }, random: forge.util.createBuffer(b.getBytes(32)), session_id: readVector(b, 1), extensions: [] }; if (client) { msg.cipher_suite = b.getBytes(2); msg.compression_method = b.getByte() } else { msg.cipher_suites = readVector(b, 2); msg.compression_methods = readVector(b, 1) } remaining = length - (remaining - b.length()); if (remaining > 0) { var exts = readVector(b, 2); while (exts.length() > 0) { msg.extensions.push({ type: [exts.getByte(), exts.getByte()], data: readVector(exts, 2) }) } if (!client) { for (var i = 0; i < msg.extensions.length; ++i) { var ext = msg.extensions[i]; if (ext.type[0] === 0 && ext.type[1] === 0) { var snl = readVector(ext.data, 2); while (snl.length() > 0) { var snType = snl.getByte(); if (snType !== 0) { break } c.session.extensions.server_name.serverNameList.push(readVector(snl, 2).getBytes()) } } } } } if (c.session.version) { if (msg.version.major !== c.session.version.major || msg.version.minor !== c.session.version.minor) { return c.error(c, { message: "TLS version change is disallowed during renegotiation.", send: true, alert: { level: tls.Alert.Level.fatal, description: tls.Alert.Description.protocol_version } }) } } if (client) { c.session.cipherSuite = tls.getCipherSuite(msg.cipher_suite) } else { var tmp = forge.util.createBuffer(msg.cipher_suites.bytes()); while (tmp.length() > 0) { c.session.cipherSuite = tls.getCipherSuite(tmp.getBytes(2)); if (c.session.cipherSuite !== null) { break } } } if (c.session.cipherSuite === null) { return c.error(c, { message: "No cipher suites in common.", send: true, alert: { level: tls.Alert.Level.fatal, description: tls.Alert.Description.handshake_failure }, cipherSuite: forge.util.bytesToHex(msg.cipher_suite) }) } if (client) { c.session.compressionMethod = msg.compression_method } else { c.session.compressionMethod = tls.CompressionMethod.none } } return msg }; tls.createSecurityParameters = function (c, msg) { var client = c.entity === tls.ConnectionEnd.client; var msgRandom = msg.random.bytes(); var cRandom = client ? c.session.sp.client_random : msgRandom; var sRandom = client ? msgRandom : tls.createRandom().getBytes(); c.session.sp = { entity: c.entity, prf_algorithm: tls.PRFAlgorithm.tls_prf_sha256, bulk_cipher_algorithm: null, cipher_type: null, enc_key_length: null, block_length: null, fixed_iv_length: null, record_iv_length: null, mac_algorithm: null, mac_length: null, mac_key_length: null, compression_algorithm: c.session.compressionMethod, pre_master_secret: null, master_secret: null, client_random: cRandom, server_random: sRandom } }; tls.handleServerHello = function (c, record, length) { var msg = tls.parseHelloMessage(c, record, length); if (c.fail) { return } if (msg.version.minor <= c.version.minor) { c.version.minor = msg.version.minor } else { return c.error(c, { message: "Incompatible TLS version.", send: true, alert: { level: tls.Alert.Level.fatal, description: tls.Alert.Description.protocol_version } }) } c.session.version = c.version; var sessionId = msg.session_id.bytes(); if (sessionId.length > 0 && sessionId === c.session.id) { c.expect = SCC; c.session.resuming = true; c.session.sp.server_random = msg.random.bytes() } else { c.expect = SCE; c.session.resuming = false; tls.createSecurityParameters(c, msg) } c.session.id = sessionId; c.process() }; tls.handleClientHello = function (c, record, length) { var msg = tls.parseHelloMessage(c, record, length); if (c.fail) { return } var sessionId = msg.session_id.bytes(); var session = null; if (c.sessionCache) { session = c.sessionCache.getSession(sessionId); if (session === null) { sessionId = "" } else if (session.version.major !== msg.version.major || session.version.minor > msg.version.minor) { session = null; sessionId = "" } } if (sessionId.length === 0) { sessionId = forge.random.getBytes(32) } c.session.id = sessionId; c.session.clientHelloVersion = msg.version; c.session.sp = {}; if (session) { c.version = c.session.version = session.version; c.session.sp = session.sp } else { var version; for (var i = 1; i < tls.SupportedVersions.length; ++i) { version = tls.SupportedVersions[i]; if (version.minor <= msg.version.minor) { break } } c.version = { major: version.major, minor: version.minor }; c.session.version = c.version } if (session !== null) { c.expect = CCC; c.session.resuming = true; c.session.sp.client_random = msg.random.bytes() } else { c.expect = c.verifyClient !== false ? CCE : CKE; c.session.resuming = false; tls.createSecurityParameters(c, msg) } c.open = true; tls.queue(c, tls.createRecord(c, { type: tls.ContentType.handshake, data: tls.createServerHello(c) })); if (c.session.resuming) { tls.queue(c, tls.createRecord(c, { type: tls.ContentType.change_cipher_spec, data: tls.createChangeCipherSpec() })); c.state.pending = tls.createConnectionState(c); c.state.current.write = c.state.pending.write; tls.queue(c, tls.createRecord(c, { type: tls.ContentType.handshake, data: tls.createFinished(c) })) } else { tls.queue(c, tls.createRecord(c, { type: tls.ContentType.handshake, data: tls.createCertificate(c) })); if (!c.fail) { tls.queue(c, tls.createRecord(c, { type: tls.ContentType.handshake, data: tls.createServerKeyExchange(c) })); if (c.verifyClient !== false) { tls.queue(c, tls.createRecord(c, { type: tls.ContentType.handshake, data: tls.createCertificateRequest(c) })) } tls.queue(c, tls.createRecord(c, { type: tls.ContentType.handshake, data: tls.createServerHelloDone(c) })) } } tls.flush(c); c.process() }; tls.handleCertificate = function (c, record, length) { if (length < 3) { return c.error(c, { message: "Invalid Certificate message. Message too short.", send: true, alert: { level: tls.Alert.Level.fatal, description: tls.Alert.Description.illegal_parameter } }) } var b = record.fragment; var msg = { certificate_list: readVector(b, 3) }; var cert, asn1; var certs = []; try { while (msg.certificate_list.length() > 0) { cert = readVector(msg.certificate_list, 3); asn1 = forge.asn1.fromDer(cert); cert = forge.pki.certificateFromAsn1(asn1, true); certs.push(cert) } } catch (ex) { return c.error(c, { message: "Could not parse certificate list.", cause: ex, send: true, alert: { level: tls.Alert.Level.fatal, description: tls.Alert.Description.bad_certificate } }) } var client = c.entity === tls.ConnectionEnd.client; if ((client || c.verifyClient === true) && certs.length === 0) { c.error(c, { message: client ? "No server certificate provided." : "No client certificate provided.", send: true, alert: { level: tls.Alert.Level.fatal, description: tls.Alert.Description.illegal_parameter } }) } else if (certs.length === 0) { c.expect = client ? SKE : CKE } else { if (client) { c.session.serverCertificate = certs[0] } else { c.session.clientCertificate = certs[0] } if (tls.verifyCertificateChain(c, certs)) { c.expect = client ? SKE : CKE } } c.process() }; tls.handleServerKeyExchange = function (c, record, length) { if (length > 0) { return c.error(c, { message: "Invalid key parameters. Only RSA is supported.", send: true, alert: { level: tls.Alert.Level.fatal, description: tls.Alert.Description.unsupported_certificate } }) } c.expect = SCR; c.process() }; tls.handleClientKeyExchange = function (c, record, length) { if (length < 48) { return c.error(c, { message: "Invalid key parameters. Only RSA is supported.", send: true, alert: { level: tls.Alert.Level.fatal, description: tls.Alert.Description.unsupported_certificate } }) } var b = record.fragment; var msg = { enc_pre_master_secret: readVector(b, 2).getBytes() }; var privateKey = null; if (c.getPrivateKey) { try { privateKey = c.getPrivateKey(c, c.session.serverCertificate); privateKey = forge.pki.privateKeyFromPem(privateKey) } catch (ex) { c.error(c, { message: "Could not get private key.", cause: ex, send: true, alert: { level: tls.Alert.Level.fatal, description: tls.Alert.Description.internal_error } }) } } if (privateKey === null) { return c.error(c, { message: "No private key set.", send: true, alert: { level: tls.Alert.Level.fatal, description: tls.Alert.Description.internal_error } }) } try { var sp = c.session.sp; sp.pre_master_secret = privateKey.decrypt(msg.enc_pre_master_secret); var version = c.session.clientHelloVersion; if (version.major !== sp.pre_master_secret.charCodeAt(0) || version.minor !== sp.pre_master_secret.charCodeAt(1)) { throw new Error("TLS version rollback attack detected.") } } catch (ex) { sp.pre_master_secret = forge.random.getBytes(48) } c.expect = CCC; if (c.session.clientCertificate !== null) { c.expect = CCV } c.process() }; tls.handleCertificateRequest = function (c, record, length) { if (length < 3) { return c.error(c, { message: "Invalid CertificateRequest. Message too short.", send: true, alert: { level: tls.Alert.Level.fatal, description: tls.Alert.Description.illegal_parameter } }) } var b = record.fragment; var msg = { certificate_types: readVector(b, 1), certificate_authorities: readVector(b, 2) }; c.session.certificateRequest = msg; c.expect = SHD; c.process() }; tls.handleCertificateVerify = function (c, record, length) { if (length < 2) { return c.error(c, { message: "Invalid CertificateVerify. Message too short.", send: true, alert: { level: tls.Alert.Level.fatal, description: tls.Alert.Description.illegal_parameter } }) } var b = record.fragment; b.read -= 4; var msgBytes = b.bytes(); b.read += 4; var msg = { signature: readVector(b, 2).getBytes() }; var verify = forge.util.createBuffer(); verify.putBuffer(c.session.md5.digest()); verify.putBuffer(c.session.sha1.digest()); verify = verify.getBytes(); try { var cert = c.session.clientCertificate; if (!cert.publicKey.verify(verify, msg.signature, "NONE")) { throw new Error("CertificateVerify signature does not match.") } c.session.md5.update(msgBytes); c.session.sha1.update(msgBytes) } catch (ex) { return c.error(c, { message: "Bad signature in CertificateVerify.", send: true, alert: { level: tls.Alert.Level.fatal, description: tls.Alert.Description.handshake_failure } }) } c.expect = CCC; c.process() }; tls.handleServerHelloDone = function (c, record, length) { if (length > 0) { return c.error(c, { message: "Invalid ServerHelloDone message. Invalid length.", send: true, alert: { level: tls.Alert.Level.fatal, description: tls.Alert.Description.record_overflow } }) } if (c.serverCertificate === null) { var error = { message: "No server certificate provided. Not enough security.", send: true, alert: { level: tls.Alert.Level.fatal, description: tls.Alert.Description.insufficient_security } }; var depth = 0; var ret = c.verify(c, error.alert.description, depth, []); if (ret !== true) { if (ret || ret === 0) { if (typeof ret === "object" && !forge.util.isArray(ret)) { if (ret.message) { error.message = ret.message } if (ret.alert) { error.alert.description = ret.alert } } else if (typeof ret === "number") { error.alert.description = ret } } return c.error(c, error) } } if (c.session.certificateRequest !== null) { record = tls.createRecord(c, { type: tls.ContentType.handshake, data: tls.createCertificate(c) }); tls.queue(c, record) } record = tls.createRecord(c, { type: tls.ContentType.handshake, data: tls.createClientKeyExchange(c) }); tls.queue(c, record); c.expect = SER; var callback = function (c, signature) { if (c.session.certificateRequest !== null && c.session.clientCertificate !== null) { tls.queue(c, tls.createRecord(c, { type: tls.ContentType.handshake, data: tls.createCertificateVerify(c, signature) })) } tls.queue(c, tls.createRecord(c, { type: tls.ContentType.change_cipher_spec, data: tls.createChangeCipherSpec() })); c.state.pending = tls.createConnectionState(c); c.state.current.write = c.state.pending.write; tls.queue(c, tls.createRecord(c, { type: tls.ContentType.handshake, data: tls.createFinished(c) })); c.expect = SCC; tls.flush(c); c.process() }; if (c.session.certificateRequest === null || c.session.clientCertificate === null) { return callback(c, null) } tls.getClientSignature(c, callback) }; tls.handleChangeCipherSpec = function (c, record) { if (record.fragment.getByte() !== 1) { return c.error(c, { message: "Invalid ChangeCipherSpec message received.", send: true, alert: { level: tls.Alert.Level.fatal, description: tls.Alert.Description.illegal_parameter } }) } var client = c.entity === tls.ConnectionEnd.client; if (c.session.resuming && client || !c.session.resuming && !client) { c.state.pending = tls.createConnectionState(c) } c.state.current.read = c.state.pending.read; if (!c.session.resuming && client || c.session.resuming && !client) { c.state.pending = null } c.expect = client ? SFI : CFI; c.process() }; tls.handleFinished = function (c, record, length) { var b = record.fragment; b.read -= 4; var msgBytes = b.bytes(); b.read += 4; var vd = record.fragment.getBytes(); b = forge.util.createBuffer(); b.putBuffer(c.session.md5.digest()); b.putBuffer(c.session.sha1.digest()); var client = c.entity === tls.ConnectionEnd.client; var label = client ? "server finished" : "client finished"; var sp = c.session.sp; var vdl = 12; var prf = prf_TLS1; b = prf(sp.master_secret, label, b.getBytes(), vdl); if (b.getBytes() !== vd) { return c.error(c, { message: "Invalid verify_data in Finished message.", send: true, alert: { level: tls.Alert.Level.fatal, description: tls.Alert.Description.decrypt_error } }) } c.session.md5.update(msgBytes); c.session.sha1.update(msgBytes); if (c.session.resuming && client || !c.session.resuming && !client) { tls.queue(c, tls.createRecord(c, { type: tls.ContentType.change_cipher_spec, data: tls.createChangeCipherSpec() })); c.state.current.write = c.state.pending.write; c.state.pending = null; tls.queue(c, tls.createRecord(c, { type: tls.ContentType.handshake, data: tls.createFinished(c) })) } c.expect = client ? SAD : CAD; c.handshaking = false; ++c.handshakes; c.peerCertificate = client ? c.session.serverCertificate : c.session.clientCertificate; tls.flush(c); c.isConnected = true; c.connected(c); c.process() }; tls.handleAlert = function (c, record) { var b = record.fragment; var alert = { level: b.getByte(), description: b.getByte() }; var msg; switch (alert.description) { case tls.Alert.Description.close_notify: msg = "Connection closed."; break; case tls.Alert.Description.unexpected_message: msg = "Unexpected message."; break; case tls.Alert.Description.bad_record_mac: msg = "Bad record MAC."; break; case tls.Alert.Description.decryption_failed: msg = "Decryption failed."; break; case tls.Alert.Description.record_overflow: msg = "Record overflow."; break; case tls.Alert.Description.decompression_failure: msg = "Decompression failed."; break; case tls.Alert.Description.handshake_failure: msg = "Handshake failure."; break; case tls.Alert.Description.bad_certificate: msg = "Bad certificate."; break; case tls.Alert.Description.unsupported_certificate: msg = "Unsupported certificate."; break; case tls.Alert.Description.certificate_revoked: msg = "Certificate revoked."; break; case tls.Alert.Description.certificate_expired: msg = "Certificate expired."; break; case tls.Alert.Description.certificate_unknown: msg = "Certificate unknown."; break; case tls.Alert.Description.illegal_parameter: msg = "Illegal parameter."; break; case tls.Alert.Description.unknown_ca: msg = "Unknown certificate authority."; break; case tls.Alert.Description.access_denied: msg = "Access denied."; break; case tls.Alert.Description.decode_error: msg = "Decode error."; break; case tls.Alert.Description.decrypt_error: msg = "Decrypt error."; break; case tls.Alert.Description.export_restriction: msg = "Export restriction."; break; case tls.Alert.Description.protocol_version: msg = "Unsupported protocol version."; break; case tls.Alert.Description.insufficient_security: msg = "Insufficient security."; break; case tls.Alert.Description.internal_error: msg = "Internal error."; break; case tls.Alert.Description.user_canceled: msg = "User canceled."; break; case tls.Alert.Description.no_renegotiation: msg = "Renegotiation not supported."; break; default: msg = "Unknown error."; break }if (alert.description === tls.Alert.Description.close_notify) { return c.close() } c.error(c, { message: msg, send: false, origin: c.entity === tls.ConnectionEnd.client ? "server" : "client", alert: alert }); c.process() }; tls.handleHandshake = function (c, record) { var b = record.fragment; var type = b.getByte(); var length = b.getInt24(); if (length > b.length()) { c.fragmented = record; record.fragment = forge.util.createBuffer(); b.read -= 4; return c.process() } c.fragmented = null; b.read -= 4; var bytes = b.bytes(length + 4); b.read += 4; if (type in hsTable[c.entity][c.expect]) { if (c.entity === tls.ConnectionEnd.server && !c.open && !c.fail) { c.handshaking = true; c.session = { version: null, extensions: { server_name: { serverNameList: [] } }, cipherSuite: null, compressionMethod: null, serverCertificate: null, clientCertificate: null, md5: forge.md.md5.create(), sha1: forge.md.sha1.create() } } if (type !== tls.HandshakeType.hello_request && type !== tls.HandshakeType.certificate_verify && type !== tls.HandshakeType.finished) { c.session.md5.update(bytes); c.session.sha1.update(bytes) } hsTable[c.entity][c.expect][type](c, record, length) } else { tls.handleUnexpected(c, record) } }; tls.handleApplicationData = function (c, record) { c.data.putBuffer(record.fragment); c.dataReady(c); c.process() }; tls.handleHeartbeat = function (c, record) { var b = record.fragment; var type = b.getByte(); var length = b.getInt16(); var payload = b.getBytes(length); if (type === tls.HeartbeatMessageType.heartbeat_request) { if (c.handshaking || length > payload.length) { return c.process() } tls.queue(c, tls.createRecord(c, { type: tls.ContentType.heartbeat, data: tls.createHeartbeat(tls.HeartbeatMessageType.heartbeat_response, payload) })); tls.flush(c) } else if (type === tls.HeartbeatMessageType.heartbeat_response) { if (payload !== c.expectedHeartbeatPayload) { return c.process() } if (c.heartbeatReceived) { c.heartbeatReceived(c, forge.util.createBuffer(payload)) } } c.process() }; var SHE = 0; var SCE = 1; var SKE = 2; var SCR = 3; var SHD = 4; var SCC = 5; var SFI = 6; var SAD = 7; var SER = 8; var CHE = 0; var CCE = 1; var CKE = 2; var CCV = 3; var CCC = 4; var CFI = 5; var CAD = 6; var CER = 7; var __ = tls.handleUnexpected; var R0 = tls.handleChangeCipherSpec; var R1 = tls.handleAlert; var R2 = tls.handleHandshake; var R3 = tls.handleApplicationData; var R4 = tls.handleHeartbeat; var ctTable = []; ctTable[tls.ConnectionEnd.client] = [[__, R1, R2, __, R4], [__, R1, R2, __, R4], [__, R1, R2, __, R4], [__, R1, R2, __, R4], [__, R1, R2, __, R4], [R0, R1, __, __, R4], [__, R1, R2, __, R4], [__, R1, R2, R3, R4], [__, R1, R2, __, R4]]; ctTable[tls.ConnectionEnd.server] = [[__, R1, R2, __, R4], [__, R1, R2, __, R4], [__, R1, R2, __, R4], [__, R1, R2, __, R4], [R0, R1, __, __, R4], [__, R1, R2, __, R4], [__, R1, R2, R3, R4], [__, R1, R2, __, R4]]; var H0 = tls.handleHelloRequest; var H1 = tls.handleServerHello; var H2 = tls.handleCertificate; var H3 = tls.handleServerKeyExchange; var H4 = tls.handleCertificateRequest; var H5 = tls.handleServerHelloDone; var H6 = tls.handleFinished; var hsTable = []; hsTable[tls.ConnectionEnd.client] = [[__, __, H1, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __], [H0, __, __, __, __, __, __, __, __, __, __, H2, H3, H4, H5, __, __, __, __, __, __], [H0, __, __, __, __, __, __, __, __, __, __, __, H3, H4, H5, __, __, __, __, __, __], [H0, __, __, __, __, __, __, __, __, __, __, __, __, H4, H5, __, __, __, __, __, __], [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, H5, __, __, __, __, __, __], [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __], [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, H6], [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __], [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __]]; var H7 = tls.handleClientHello; var H8 = tls.handleClientKeyExchange; var H9 = tls.handleCertificateVerify; hsTable[tls.ConnectionEnd.server] = [[__, H7, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __], [__, __, __, __, __, __, __, __, __, __, __, H2, __, __, __, __, __, __, __, __, __], [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, H8, __, __, __, __], [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, H9, __, __, __, __, __], [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __], [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, H6], [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __], [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __]]; tls.generateKeys = function (c, sp) { var prf = prf_TLS1; var random = sp.client_random + sp.server_random; if (!c.session.resuming) { sp.master_secret = prf(sp.pre_master_secret, "master secret", random, 48).bytes(); sp.pre_master_secret = null } random = sp.server_random + sp.client_random; var length = 2 * sp.mac_key_length + 2 * sp.enc_key_length; var tls10 = c.version.major === tls.Versions.TLS_1_0.major && c.version.minor === tls.Versions.TLS_1_0.minor; if (tls10) { length += 2 * sp.fixed_iv_length } var km = prf(sp.master_secret, "key expansion", random, length); var rval = { client_write_MAC_key: km.getBytes(sp.mac_key_length), server_write_MAC_key: km.getBytes(sp.mac_key_length), client_write_key: km.getBytes(sp.enc_key_length), server_write_key: km.getBytes(sp.enc_key_length) }; if (tls10) { rval.client_write_IV = km.getBytes(sp.fixed_iv_length); rval.server_write_IV = km.getBytes(sp.fixed_iv_length) } return rval }; tls.createConnectionState = function (c) { var client = c.entity === tls.ConnectionEnd.client; var createMode = function () { var mode = { sequenceNumber: [0, 0], macKey: null, macLength: 0, macFunction: null, cipherState: null, cipherFunction: function (record) { return true }, compressionState: null, compressFunction: function (record) { return true }, updateSequenceNumber: function () { if (mode.sequenceNumber[1] === 4294967295) { mode.sequenceNumber[1] = 0; ++mode.sequenceNumber[0] } else { ++mode.sequenceNumber[1] } } }; return mode }; var state = { read: createMode(), write: createMode() }; state.read.update = function (c, record) { if (!state.read.cipherFunction(record, state.read)) { c.error(c, { message: "Could not decrypt record or bad MAC.", send: true, alert: { level: tls.Alert.Level.fatal, description: tls.Alert.Description.bad_record_mac } }) } else if (!state.read.compressFunction(c, record, state.read)) { c.error(c, { message: "Could not decompress record.", send: true, alert: { level: tls.Alert.Level.fatal, description: tls.Alert.Description.decompression_failure } }) } return !c.fail }; state.write.update = function (c, record) { if (!state.write.compressFunction(c, record, state.write)) { c.error(c, { message: "Could not compress record.", send: false, alert: { level: tls.Alert.Level.fatal, description: tls.Alert.Description.internal_error } }) } else if (!state.write.cipherFunction(record, state.write)) { c.error(c, { message: "Could not encrypt record.", send: false, alert: { level: tls.Alert.Level.fatal, description: tls.Alert.Description.internal_error } }) } return !c.fail }; if (c.session) { var sp = c.session.sp; c.session.cipherSuite.initSecurityParameters(sp); sp.keys = tls.generateKeys(c, sp); state.read.macKey = client ? sp.keys.server_write_MAC_key : sp.keys.client_write_MAC_key; state.write.macKey = client ? sp.keys.client_write_MAC_key : sp.keys.server_write_MAC_key; c.session.cipherSuite.initConnectionState(state, c, sp); switch (sp.compression_algorithm) { case tls.CompressionMethod.none: break; case tls.CompressionMethod.deflate: state.read.compressFunction = inflate; state.write.compressFunction = deflate; break; default: throw new Error("Unsupported compression algorithm.") } } return state }; tls.createRandom = function () { var d = new Date; var utc = +d + d.getTimezoneOffset() * 6e4; var rval = forge.util.createBuffer(); rval.putInt32(utc); rval.putBytes(forge.random.getBytes(28)); return rval }; tls.createRecord = function (c, options) { if (!options.data) { return null } var record = { type: options.type, version: { major: c.version.major, minor: c.version.minor }, length: options.data.length(), fragment: options.data }; return record }; tls.createAlert = function (c, alert) { var b = forge.util.createBuffer(); b.putByte(alert.level); b.putByte(alert.description); return tls.createRecord(c, { type: tls.ContentType.alert, data: b }) }; tls.createClientHello = function (c) { c.session.clientHelloVersion = { major: c.version.major, minor: c.version.minor }; var cipherSuites = forge.util.createBuffer(); for (var i = 0; i < c.cipherSuites.length; ++i) { var cs = c.cipherSuites[i]; cipherSuites.putByte(cs.id[0]); cipherSuites.putByte(cs.id[1]) } var cSuites = cipherSuites.length(); var compressionMethods = forge.util.createBuffer(); compressionMethods.putByte(tls.CompressionMethod.none); var cMethods = compressionMethods.length(); var extensions = forge.util.createBuffer(); if (c.virtualHost) { var ext = forge.util.createBuffer(); ext.putByte(0); ext.putByte(0); var serverName = forge.util.createBuffer(); serverName.putByte(0); writeVector(serverName, 2, forge.util.createBuffer(c.virtualHost)); var snList = forge.util.createBuffer(); writeVector(snList, 2, serverName); writeVector(ext, 2, snList); extensions.putBuffer(ext) } var extLength = extensions.length(); if (extLength > 0) { extLength += 2 } var sessionId = c.session.id; var length = sessionId.length + 1 + 2 + 4 + 28 + 2 + cSuites + 1 + cMethods + extLength; var rval = forge.util.createBuffer(); rval.putByte(tls.HandshakeType.client_hello); rval.putInt24(length); rval.putByte(c.version.major); rval.putByte(c.version.minor); rval.putBytes(c.session.sp.client_random); writeVector(rval, 1, forge.util.createBuffer(sessionId)); writeVector(rval, 2, cipherSuites); writeVector(rval, 1, compressionMethods); if (extLength > 0) { writeVector(rval, 2, extensions) } return rval }; tls.createServerHello = function (c) { var sessionId = c.session.id; var length = sessionId.length + 1 + 2 + 4 + 28 + 2 + 1; var rval = forge.util.createBuffer(); rval.putByte(tls.HandshakeType.server_hello); rval.putInt24(length); rval.putByte(c.version.major); rval.putByte(c.version.minor); rval.putBytes(c.session.sp.server_random); writeVector(rval, 1, forge.util.createBuffer(sessionId)); rval.putByte(c.session.cipherSuite.id[0]); rval.putByte(c.session.cipherSuite.id[1]); rval.putByte(c.session.compressionMethod); return rval }; tls.createCertificate = function (c) { var client = c.entity === tls.ConnectionEnd.client; var cert = null; if (c.getCertificate) { var hint; if (client) { hint = c.session.certificateRequest } else { hint = c.session.extensions.server_name.serverNameList } cert = c.getCertificate(c, hint) } var certList = forge.util.createBuffer(); if (cert !== null) { try { if (!forge.util.isArray(cert)) { cert = [cert] } var asn1 = null; for (var i = 0; i < cert.length; ++i) { var msg = forge.pem.decode(cert[i])[0]; if (msg.type !== "CERTIFICATE" && msg.type !== "X509 CERTIFICATE" && msg.type !== "TRUSTED CERTIFICATE") { var error = new Error("Could not convert certificate from PEM; PEM " + 'header type is not "CERTIFICATE", "X509 CERTIFICATE", or ' + '"TRUSTED CERTIFICATE".'); error.headerType = msg.type; throw error } if (msg.procType && msg.procType.type === "ENCRYPTED") { throw new Error("Could not convert certificate from PEM; PEM is encrypted.") } var der = forge.util.createBuffer(msg.body); if (asn1 === null) { asn1 = forge.asn1.fromDer(der.bytes(), false) } var certBuffer = forge.util.createBuffer(); writeVector(certBuffer, 3, der); certList.putBuffer(certBuffer) } cert = forge.pki.certificateFromAsn1(asn1); if (client) { c.session.clientCertificate = cert } else { c.session.serverCertificate = cert } } catch (ex) { return c.error(c, { message: "Could not send certificate list.", cause: ex, send: true, alert: { level: tls.Alert.Level.fatal, description: tls.Alert.Description.bad_certificate } }) } } var length = 3 + certList.length(); var rval = forge.util.createBuffer(); rval.putByte(tls.HandshakeType.certificate); rval.putInt24(length); writeVector(rval, 3, certList); return rval }; tls.createClientKeyExchange = function (c) { var b = forge.util.createBuffer(); b.putByte(c.session.clientHelloVersion.major); b.putByte(c.session.clientHelloVersion.minor); b.putBytes(forge.random.getBytes(46)); var sp = c.session.sp; sp.pre_master_secret = b.getBytes(); var key = c.session.serverCertificate.publicKey; b = key.encrypt(sp.pre_master_secret); var length = b.length + 2; var rval = forge.util.createBuffer(); rval.putByte(tls.HandshakeType.client_key_exchange); rval.putInt24(length); rval.putInt16(b.length); rval.putBytes(b); return rval }; tls.createServerKeyExchange = function (c) { var length = 0; var rval = forge.util.createBuffer(); if (length > 0) { rval.putByte(tls.HandshakeType.server_key_exchange); rval.putInt24(length) } return rval }; tls.getClientSignature = function (c, callback) { var b = forge.util.createBuffer(); b.putBuffer(c.session.md5.digest()); b.putBuffer(c.session.sha1.digest()); b = b.getBytes(); c.getSignature = c.getSignature || function (c, b, callback) { var privateKey = null; if (c.getPrivateKey) { try { privateKey = c.getPrivateKey(c, c.session.clientCertificate); privateKey = forge.pki.privateKeyFromPem(privateKey) } catch (ex) { c.error(c, { message: "Could not get private key.", cause: ex, send: true, alert: { level: tls.Alert.Level.fatal, description: tls.Alert.Description.internal_error } }) } } if (privateKey === null) { c.error(c, { message: "No private key set.", send: true, alert: { level: tls.Alert.Level.fatal, description: tls.Alert.Description.internal_error } }) } else { b = privateKey.sign(b, null) } callback(c, b) }; c.getSignature(c, b, callback) }; tls.createCertificateVerify = function (c, signature) { var length = signature.length + 2; var rval = forge.util.createBuffer(); rval.putByte(tls.HandshakeType.certificate_verify); rval.putInt24(length); rval.putInt16(signature.length); rval.putBytes(signature); return rval }; tls.createCertificateRequest = function (c) { var certTypes = forge.util.createBuffer(); certTypes.putByte(1); var cAs = forge.util.createBuffer(); for (var key in c.caStore.certs) { var cert = c.caStore.certs[key]; var dn = forge.pki.distinguishedNameToAsn1(cert.subject); var byteBuffer = forge.asn1.toDer(dn); cAs.putInt16(byteBuffer.length()); cAs.putBuffer(byteBuffer) } var length = 1 + certTypes.length() + 2 + cAs.length(); var rval = forge.util.createBuffer(); rval.putByte(tls.HandshakeType.certificate_request); rval.putInt24(length); writeVector(rval, 1, certTypes); writeVector(rval, 2, cAs); return rval }; tls.createServerHelloDone = function (c) { var rval = forge.util.createBuffer(); rval.putByte(tls.HandshakeType.server_hello_done); rval.putInt24(0); return rval }; tls.createChangeCipherSpec = function () { var rval = forge.util.createBuffer(); rval.putByte(1); return rval }; tls.createFinished = function (c) { var b = forge.util.createBuffer(); b.putBuffer(c.session.md5.digest()); b.putBuffer(c.session.sha1.digest()); var client = c.entity === tls.ConnectionEnd.client; var sp = c.session.sp; var vdl = 12; var prf = prf_TLS1; var label = client ? "client finished" : "server finished"; b = prf(sp.master_secret, label, b.getBytes(), vdl); var rval = forge.util.createBuffer(); rval.putByte(tls.HandshakeType.finished); rval.putInt24(b.length()); rval.putBuffer(b); return rval }; tls.createHeartbeat = function (type, payload, payloadLength) { if (typeof payloadLength === "undefined") { payloadLength = payload.length } var rval = forge.util.createBuffer(); rval.putByte(type); rval.putInt16(payloadLength); rval.putBytes(payload); var plaintextLength = rval.length(); var paddingLength = Math.max(16, plaintextLength - payloadLength - 3); rval.putBytes(forge.random.getBytes(paddingLength)); return rval }; tls.queue = function (c, record) { if (!record) { return } if (record.fragment.length() === 0) { if (record.type === tls.ContentType.handshake || record.type === tls.ContentType.alert || record.type === tls.ContentType.change_cipher_spec) { return } } if (record.type === tls.ContentType.handshake) { var bytes = record.fragment.bytes(); c.session.md5.update(bytes); c.session.sha1.update(bytes); bytes = null } var records; if (record.fragment.length() <= tls.MaxFragment) { records = [record] } else { records = []; var data = record.fragment.bytes(); while (data.length > tls.MaxFragment) { records.push(tls.createRecord(c, { type: record.type, data: forge.util.createBuffer(data.slice(0, tls.MaxFragment)) })); data = data.slice(tls.MaxFragment) } if (data.length > 0) { records.push(tls.createRecord(c, { type: record.type, data: forge.util.createBuffer(data) })) } } for (var i = 0; i < records.length && !c.fail; ++i) { var rec = records[i]; var s = c.state.current.write; if (s.update(c, rec)) { c.records.push(rec) } } }; tls.flush = function (c) { for (var i = 0; i < c.records.length; ++i) { var record = c.records[i]; c.tlsData.putByte(record.type); c.tlsData.putByte(record.version.major); c.tlsData.putByte(record.version.minor); c.tlsData.putInt16(record.fragment.length()); c.tlsData.putBuffer(c.records[i].fragment) } c.records = []; return c.tlsDataReady(c) }; var _certErrorToAlertDesc = function (error) { switch (error) { case true: return true; case forge.pki.certificateError.bad_certificate: return tls.Alert.Description.bad_certificate; case forge.pki.certificateError.unsupported_certificate: return tls.Alert.Description.unsupported_certificate; case forge.pki.certificateError.certificate_revoked: return tls.Alert.Description.certificate_revoked; case forge.pki.certificateError.certificate_expired: return tls.Alert.Description.certificate_expired; case forge.pki.certificateError.certificate_unknown: return tls.Alert.Description.certificate_unknown; case forge.pki.certificateError.unknown_ca: return tls.Alert.Description.unknown_ca; default: return tls.Alert.Description.bad_certificate } }; var _alertDescToCertError = function (desc) { switch (desc) { case true: return true; case tls.Alert.Description.bad_certificate: return forge.pki.certificateError.bad_certificate; case tls.Alert.Description.unsupported_certificate: return forge.pki.certificateError.unsupported_certificate; case tls.Alert.Description.certificate_revoked: return forge.pki.certificateError.certificate_revoked; case tls.Alert.Description.certificate_expired: return forge.pki.certificateError.certificate_expired; case tls.Alert.Description.certificate_unknown: return forge.pki.certificateError.certificate_unknown; case tls.Alert.Description.unknown_ca: return forge.pki.certificateError.unknown_ca; default: return forge.pki.certificateError.bad_certificate } }; tls.verifyCertificateChain = function (c, chain) { try { var options = {}; for (var key in c.verifyOptions) { options[key] = c.verifyOptions[key] } options.verify = function (vfd, depth, chain) { var desc = _certErrorToAlertDesc(vfd); var ret = c.verify(c, vfd, depth, chain); if (ret !== true) { if (typeof ret === "object" && !forge.util.isArray(ret)) { var error = new Error("The application rejected the certificate."); error.send = true; error.alert = { level: tls.Alert.Level.fatal, description: tls.Alert.Description.bad_certificate }; if (ret.message) { error.message = ret.message } if (ret.alert) { error.alert.description = ret.alert } throw error } if (ret !== vfd) { ret = _alertDescToCertError(ret) } } return ret }; forge.pki.verifyCertificateChain(c.caStore, chain, options) } catch (ex) { var err = ex; if (typeof err !== "object" || forge.util.isArray(err)) { err = { send: true, alert: { level: tls.Alert.Level.fatal, description: _certErrorToAlertDesc(ex) } } } if (!("send" in err)) { err.send = true } if (!("alert" in err)) { err.alert = { level: tls.Alert.Level.fatal, description: _certErrorToAlertDesc(err.error) } } c.error(c, err) } return !c.fail }; tls.createSessionCache = function (cache, capacity) { var rval = null; if (cache && cache.getSession && cache.setSession && cache.order) { rval = cache } else { rval = {}; rval.cache = cache || {}; rval.capacity = Math.max(capacity || 100, 1); rval.order = []; for (var key in cache) { if (rval.order.length <= capacity) { rval.order.push(key) } else { delete cache[key] } } rval.getSession = function (sessionId) { var session = null; var key = null; if (sessionId) { key = forge.util.bytesToHex(sessionId) } else if (rval.order.length > 0) { key = rval.order[0] } if (key !== null && key in rval.cache) { session = rval.cache[key]; delete rval.cache[key]; for (var i in rval.order) { if (rval.order[i] === key) { rval.order.splice(i, 1); break } } } return session }; rval.setSession = function (sessionId, session) { if (rval.order.length === rval.capacity) { var key = rval.order.shift(); delete rval.cache[key] } var key = forge.util.bytesToHex(sessionId); rval.order.push(key); rval.cache[key] = session } } return rval }; tls.createConnection = function (options) { var caStore = null; if (options.caStore) { if (forge.util.isArray(options.caStore)) { caStore = forge.pki.createCaStore(options.caStore) } else { caStore = options.caStore } } else { caStore = forge.pki.createCaStore() } var cipherSuites = options.cipherSuites || null; if (cipherSuites === null) { cipherSuites = []; for (var key in tls.CipherSuites) { cipherSuites.push(tls.CipherSuites[key]) } } var entity = options.server || false ? tls.ConnectionEnd.server : tls.ConnectionEnd.client; var sessionCache = options.sessionCache ? tls.createSessionCache(options.sessionCache) : null; var c = { version: { major: tls.Version.major, minor: tls.Version.minor }, entity: entity, sessionId: options.sessionId, caStore: caStore, sessionCache: sessionCache, cipherSuites: cipherSuites, connected: options.connected, virtualHost: options.virtualHost || null, verifyClient: options.verifyClient || false, verify: options.verify || function (cn, vfd, dpth, cts) { return vfd }, verifyOptions: options.verifyOptions || {}, getCertificate: options.getCertificate || null, getPrivateKey: options.getPrivateKey || null, getSignature: options.getSignature || null, input: forge.util.createBuffer(), tlsData: forge.util.createBuffer(), data: forge.util.createBuffer(), tlsDataReady: options.tlsDataReady, dataReady: options.dataReady, heartbeatReceived: options.heartbeatReceived, closed: options.closed, error: function (c, ex) { ex.origin = ex.origin || (c.entity === tls.ConnectionEnd.client ? "client" : "server"); if (ex.send) { tls.queue(c, tls.createAlert(c, ex.alert)); tls.flush(c) } var fatal = ex.fatal !== false; if (fatal) { c.fail = true } options.error(c, ex); if (fatal) { c.close(false) } }, deflate: options.deflate || null, inflate: options.inflate || null }; c.reset = function (clearFail) { c.version = { major: tls.Version.major, minor: tls.Version.minor }; c.record = null; c.session = null; c.peerCertificate = null; c.state = { pending: null, current: null }; c.expect = c.entity === tls.ConnectionEnd.client ? SHE : CHE; c.fragmented = null; c.records = []; c.open = false; c.handshakes = 0; c.handshaking = false; c.isConnected = false; c.fail = !(clearFail || typeof clearFail === "undefined"); c.input.clear(); c.tlsData.clear(); c.data.clear(); c.state.current = tls.createConnectionState(c) }; c.reset(); var _update = function (c, record) { var aligned = record.type - tls.ContentType.change_cipher_spec; var handlers = ctTable[c.entity][c.expect]; if (aligned in handlers) { handlers[aligned](c, record) } else { tls.handleUnexpected(c, record) } }; var _readRecordHeader = function (c) { var rval = 0; var b = c.input; var len = b.length(); if (len < 5) { rval = 5 - len } else { c.record = { type: b.getByte(), version: { major: b.getByte(), minor: b.getByte() }, length: b.getInt16(), fragment: forge.util.createBuffer(), ready: false }; var compatibleVersion = c.record.version.major === c.version.major; if (compatibleVersion && c.session && c.session.version) { compatibleVersion = c.record.version.minor === c.version.minor } if (!compatibleVersion) { c.error(c, { message: "Incompatible TLS version.", send: true, alert: { level: tls.Alert.Level.fatal, description: tls.Alert.Description.protocol_version } }) } } return rval }; var _readRecord = function (c) { var rval = 0; var b = c.input; var len = b.length(); if (len < c.record.length) { rval = c.record.length - len } else { c.record.fragment.putBytes(b.getBytes(c.record.length)); b.compact(); var s = c.state.current.read; if (s.update(c, c.record)) { if (c.fragmented !== null) { if (c.fragmented.type === c.record.type) { c.fragmented.fragment.putBuffer(c.record.fragment); c.record = c.fragmented } else { c.error(c, { message: "Invalid fragmented record.", send: true, alert: { level: tls.Alert.Level.fatal, description: tls.Alert.Description.unexpected_message } }) } } c.record.ready = true } } return rval }; c.handshake = function (sessionId) { if (c.entity !== tls.ConnectionEnd.client) { c.error(c, { message: "Cannot initiate handshake as a server.", fatal: false }) } else if (c.handshaking) { c.error(c, { message: "Handshake already in progress.", fatal: false }) } else { if (c.fail && !c.open && c.handshakes === 0) { c.fail = false } c.handshaking = true; sessionId = sessionId || ""; var session = null; if (sessionId.length > 0) { if (c.sessionCache) { session = c.sessionCache.getSession(sessionId) } if (session === null) { sessionId = "" } } if (sessionId.length === 0 && c.sessionCache) { session = c.sessionCache.getSession(); if (session !== null) { sessionId = session.id } } c.session = { id: sessionId, version: null, cipherSuite: null, compressionMethod: null, serverCertificate: null, certificateRequest: null, clientCertificate: null, sp: {}, md5: forge.md.md5.create(), sha1: forge.md.sha1.create() }; if (session) { c.version = session.version; c.session.sp = session.sp } c.session.sp.client_random = tls.createRandom().getBytes(); c.open = true; tls.queue(c, tls.createRecord(c, { type: tls.ContentType.handshake, data: tls.createClientHello(c) })); tls.flush(c) } }; c.process = function (data) { var rval = 0; if (data) { c.input.putBytes(data) } if (!c.fail) { if (c.record !== null && c.record.ready && c.record.fragment.isEmpty()) { c.record = null } if (c.record === null) { rval = _readRecordHeader(c) } if (!c.fail && c.record !== null && !c.record.ready) { rval = _readRecord(c) } if (!c.fail && c.record !== null && c.record.ready) { _update(c, c.record) } } return rval }; c.prepare = function (data) { tls.queue(c, tls.createRecord(c, { type: tls.ContentType.application_data, data: forge.util.createBuffer(data) })); return tls.flush(c) }; c.prepareHeartbeatRequest = function (payload, payloadLength) { if (payload instanceof forge.util.ByteBuffer) { payload = payload.bytes() } if (typeof payloadLength === "undefined") { payloadLength = payload.length } c.expectedHeartbeatPayload = payload; tls.queue(c, tls.createRecord(c, { type: tls.ContentType.heartbeat, data: tls.createHeartbeat(tls.HeartbeatMessageType.heartbeat_request, payload, payloadLength) })); return tls.flush(c) }; c.close = function (clearFail) { if (!c.fail && c.sessionCache && c.session) { var session = { id: c.session.id, version: c.session.version, sp: c.session.sp }; session.sp.keys = null; c.sessionCache.setSession(session.id, session) } if (c.open) { c.open = false; c.input.clear(); if (c.isConnected || c.handshaking) { c.isConnected = c.handshaking = false; tls.queue(c, tls.createAlert(c, { level: tls.Alert.Level.warning, description: tls.Alert.Description.close_notify })); tls.flush(c) } c.closed(c) } c.reset(clearFail) }; return c }; module.exports = forge.tls = forge.tls || {}; for (var key in tls) { if (typeof tls[key] !== "function") { forge.tls[key] = tls[key] } } forge.tls.prf_tls1 = prf_TLS1; forge.tls.hmac_sha1 = hmac_sha1; forge.tls.createSessionCache = tls.createSessionCache; forge.tls.createConnection = tls.createConnection }, { "./asn1": 9, "./forge": 16, "./hmac": 17, "./md5": 24, "./pem": 30, "./pki": 35, "./random": 39, "./sha1": 42, "./util": 48 }], 48: [function (require, module, exports) { (function (process, global, Buffer, __argument0, __argument1, __argument2, __argument3, setImmediate) { var forge = require("./forge"); var baseN = require("./baseN"); var util = module.exports = forge.util = forge.util || {}; (function () { if (typeof process !== "undefined" && process.nextTick && !process.browser) { util.nextTick = process.nextTick; if (typeof setImmediate === "function") { util.setImmediate = setImmediate } else { util.setImmediate = util.nextTick } return } if (typeof setImmediate === "function") { util.setImmediate = function () { return setImmediate.apply(undefined, arguments) }; util.nextTick = function (callback) { return setImmediate(callback) }; return } util.setImmediate = function (callback) { setTimeout(callback, 0) }; if (typeof window !== "undefined" && typeof window.postMessage === "function") { var msg = "forge.setImmediate"; var callbacks = []; util.setImmediate = function (callback) { callbacks.push(callback); if (callbacks.length === 1) { window.postMessage(msg, "*") } }; function handler(event) { if (event.source === window && event.data === msg) { event.stopPropagation(); var copy = callbacks.slice(); callbacks.length = 0; copy.forEach(function (callback) { callback() }) } } window.addEventListener("message", handler, true) } if (typeof MutationObserver !== "undefined") { var now = Date.now(); var attr = true; var div = document.createElement("div"); var callbacks = []; new MutationObserver(function () { var copy = callbacks.slice(); callbacks.length = 0; copy.forEach(function (callback) { callback() }) }).observe(div, { attributes: true }); var oldSetImmediate = util.setImmediate; util.setImmediate = function (callback) { if (Date.now() - now > 15) { now = Date.now(); oldSetImmediate(callback) } else { callbacks.push(callback); if (callbacks.length === 1) { div.setAttribute("a", attr = !attr) } } } } util.nextTick = util.setImmediate })(); util.isNodejs = typeof process !== "undefined" && process.versions && process.versions.node; util.globalScope = function () { if (util.isNodejs) { return global } return typeof self === "undefined" ? window : self }(); util.isArray = Array.isArray || function (x) { return Object.prototype.toString.call(x) === "[object Array]" }; util.isArrayBuffer = function (x) { return typeof ArrayBuffer !== "undefined" && x instanceof ArrayBuffer }; util.isArrayBufferView = function (x) { return x && util.isArrayBuffer(x.buffer) && x.byteLength !== undefined }; function _checkBitsParam(n) { if (!(n === 8 || n === 16 || n === 24 || n === 32)) { throw new Error("Only 8, 16, 24, or 32 bits supported: " + n) } } util.ByteBuffer = ByteStringBuffer; function ByteStringBuffer(b) { this.data = ""; this.read = 0; if (typeof b === "string") { this.data = b } else if (util.isArrayBuffer(b) || util.isArrayBufferView(b)) { if (typeof Buffer !== "undefined" && b instanceof Buffer) { this.data = b.toString("binary") } else { var arr = new Uint8Array(b); try { this.data = String.fromCharCode.apply(null, arr) } catch (e) { for (var i = 0; i < arr.length; ++i) { this.putByte(arr[i]) } } } } else if (b instanceof ByteStringBuffer || typeof b === "object" && typeof b.data === "string" && typeof b.read === "number") { this.data = b.data; this.read = b.read } this._constructedStringLength = 0 } util.ByteStringBuffer = ByteStringBuffer; var _MAX_CONSTRUCTED_STRING_LENGTH = 4096; util.ByteStringBuffer.prototype._optimizeConstructedString = function (x) { this._constructedStringLength += x; if (this._constructedStringLength > _MAX_CONSTRUCTED_STRING_LENGTH) { this.data.substr(0, 1); this._constructedStringLength = 0 } }; util.ByteStringBuffer.prototype.length = function () { return this.data.length - this.read }; util.ByteStringBuffer.prototype.isEmpty = function () { return this.length() <= 0 }; util.ByteStringBuffer.prototype.putByte = function (b) { return this.putBytes(String.fromCharCode(b)) }; util.ByteStringBuffer.prototype.fillWithByte = function (b, n) { b = String.fromCharCode(b); var d = this.data; while (n > 0) { if (n & 1) { d += b } n >>>= 1; if (n > 0) { b += b } } this.data = d; this._optimizeConstructedString(n); return this }; util.ByteStringBuffer.prototype.putBytes = function (bytes) { this.data += bytes; this._optimizeConstructedString(bytes.length); return this }; util.ByteStringBuffer.prototype.putString = function (str) { return this.putBytes(util.encodeUtf8(str)) }; util.ByteStringBuffer.prototype.putInt16 = function (i) { return this.putBytes(String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i & 255)) }; util.ByteStringBuffer.prototype.putInt24 = function (i) { return this.putBytes(String.fromCharCode(i >> 16 & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i & 255)) }; util.ByteStringBuffer.prototype.putInt32 = function (i) { return this.putBytes(String.fromCharCode(i >> 24 & 255) + String.fromCharCode(i >> 16 & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i & 255)) }; util.ByteStringBuffer.prototype.putInt16Le = function (i) { return this.putBytes(String.fromCharCode(i & 255) + String.fromCharCode(i >> 8 & 255)) }; util.ByteStringBuffer.prototype.putInt24Le = function (i) { return this.putBytes(String.fromCharCode(i & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i >> 16 & 255)) }; util.ByteStringBuffer.prototype.putInt32Le = function (i) { return this.putBytes(String.fromCharCode(i & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i >> 16 & 255) + String.fromCharCode(i >> 24 & 255)) }; util.ByteStringBuffer.prototype.putInt = function (i, n) { _checkBitsParam(n); var bytes = ""; do { n -= 8; bytes += String.fromCharCode(i >> n & 255) } while (n > 0); return this.putBytes(bytes) }; util.ByteStringBuffer.prototype.putSignedInt = function (i, n) { if (i < 0) { i += 2 << n - 1 } return this.putInt(i, n) }; util.ByteStringBuffer.prototype.putBuffer = function (buffer) { return this.putBytes(buffer.getBytes()) }; util.ByteStringBuffer.prototype.getByte = function () { return this.data.charCodeAt(this.read++) }; util.ByteStringBuffer.prototype.getInt16 = function () { var rval = this.data.charCodeAt(this.read) << 8 ^ this.data.charCodeAt(this.read + 1); this.read += 2; return rval }; util.ByteStringBuffer.prototype.getInt24 = function () { var rval = this.data.charCodeAt(this.read) << 16 ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2); this.read += 3; return rval }; util.ByteStringBuffer.prototype.getInt32 = function () { var rval = this.data.charCodeAt(this.read) << 24 ^ this.data.charCodeAt(this.read + 1) << 16 ^ this.data.charCodeAt(this.read + 2) << 8 ^ this.data.charCodeAt(this.read + 3); this.read += 4; return rval }; util.ByteStringBuffer.prototype.getInt16Le = function () { var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8; this.read += 2; return rval }; util.ByteStringBuffer.prototype.getInt24Le = function () { var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16; this.read += 3; return rval }; util.ByteStringBuffer.prototype.getInt32Le = function () { var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16 ^ this.data.charCodeAt(this.read + 3) << 24; this.read += 4; return rval }; util.ByteStringBuffer.prototype.getInt = function (n) { _checkBitsParam(n); var rval = 0; do { rval = (rval << 8) + this.data.charCodeAt(this.read++); n -= 8 } while (n > 0); return rval }; util.ByteStringBuffer.prototype.getSignedInt = function (n) { var x = this.getInt(n); var max = 2 << n - 2; if (x >= max) { x -= max << 1 } return x }; util.ByteStringBuffer.prototype.getBytes = function (count) { var rval; if (count) { count = Math.min(this.length(), count); rval = this.data.slice(this.read, this.read + count); this.read += count } else if (count === 0) { rval = "" } else { rval = this.read === 0 ? this.data : this.data.slice(this.read); this.clear() } return rval }; util.ByteStringBuffer.prototype.bytes = function (count) { return typeof count === "undefined" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + count) }; util.ByteStringBuffer.prototype.at = function (i) { return this.data.charCodeAt(this.read + i) }; util.ByteStringBuffer.prototype.setAt = function (i, b) { this.data = this.data.substr(0, this.read + i) + String.fromCharCode(b) + this.data.substr(this.read + i + 1); return this }; util.ByteStringBuffer.prototype.last = function () { return this.data.charCodeAt(this.data.length - 1) }; util.ByteStringBuffer.prototype.copy = function () { var c = util.createBuffer(this.data); c.read = this.read; return c }; util.ByteStringBuffer.prototype.compact = function () { if (this.read > 0) { this.data = this.data.slice(this.read); this.read = 0 } return this }; util.ByteStringBuffer.prototype.clear = function () { this.data = ""; this.read = 0; return this }; util.ByteStringBuffer.prototype.truncate = function (count) { var len = Math.max(0, this.length() - count); this.data = this.data.substr(this.read, len); this.read = 0; return this }; util.ByteStringBuffer.prototype.toHex = function () { var rval = ""; for (var i = this.read; i < this.data.length; ++i) { var b = this.data.charCodeAt(i); if (b < 16) { rval += "0" } rval += b.toString(16) } return rval }; util.ByteStringBuffer.prototype.toString = function () { return util.decodeUtf8(this.bytes()) }; function DataBuffer(b, options) { options = options || {}; this.read = options.readOffset || 0; this.growSize = options.growSize || 1024; var isArrayBuffer = util.isArrayBuffer(b); var isArrayBufferView = util.isArrayBufferView(b); if (isArrayBuffer || isArrayBufferView) { if (isArrayBuffer) { this.data = new DataView(b) } else { this.data = new DataView(b.buffer, b.byteOffset, b.byteLength) } this.write = "writeOffset" in options ? options.writeOffset : this.data.byteLength; return } this.data = new DataView(new ArrayBuffer(0)); this.write = 0; if (b !== null && b !== undefined) { this.putBytes(b) } if ("writeOffset" in options) { this.write = options.writeOffset } } util.DataBuffer = DataBuffer; util.DataBuffer.prototype.length = function () { return this.write - this.read }; util.DataBuffer.prototype.isEmpty = function () { return this.length() <= 0 }; util.DataBuffer.prototype.accommodate = function (amount, growSize) { if (this.length() >= amount) { return this } growSize = Math.max(growSize || this.growSize, amount); var src = new Uint8Array(this.data.buffer, this.data.byteOffset, this.data.byteLength); var dst = new Uint8Array(this.length() + growSize); dst.set(src); this.data = new DataView(dst.buffer); return this }; util.DataBuffer.prototype.putByte = function (b) { this.accommodate(1); this.data.setUint8(this.write++, b); return this }; util.DataBuffer.prototype.fillWithByte = function (b, n) { this.accommodate(n); for (var i = 0; i < n; ++i) { this.data.setUint8(b) } return this }; util.DataBuffer.prototype.putBytes = function (bytes, encoding) { if (util.isArrayBufferView(bytes)) { var src = new Uint8Array(bytes.buffer, bytes.byteOffset, bytes.byteLength); var len = src.byteLength - src.byteOffset; this.accommodate(len); var dst = new Uint8Array(this.data.buffer, this.write); dst.set(src); this.write += len; return this } if (util.isArrayBuffer(bytes)) { var src = new Uint8Array(bytes); this.accommodate(src.byteLength); var dst = new Uint8Array(this.data.buffer); dst.set(src, this.write); this.write += src.byteLength; return this } if (bytes instanceof util.DataBuffer || typeof bytes === "object" && typeof bytes.read === "number" && typeof bytes.write === "number" && util.isArrayBufferView(bytes.data)) { var src = new Uint8Array(bytes.data.byteLength, bytes.read, bytes.length()); this.accommodate(src.byteLength); var dst = new Uint8Array(bytes.data.byteLength, this.write); dst.set(src); this.write += src.byteLength; return this } if (bytes instanceof util.ByteStringBuffer) { bytes = bytes.data; encoding = "binary" } encoding = encoding || "binary"; if (typeof bytes === "string") { var view; if (encoding === "hex") { this.accommodate(Math.ceil(bytes.length / 2)); view = new Uint8Array(this.data.buffer, this.write); this.write += util.binary.hex.decode(bytes, view, this.write); return this } if (encoding === "base64") { this.accommodate(Math.ceil(bytes.length / 4) * 3); view = new Uint8Array(this.data.buffer, this.write); this.write += util.binary.base64.decode(bytes, view, this.write); return this } if (encoding === "utf8") { bytes = util.encodeUtf8(bytes); encoding = "binary" } if (encoding === "binary" || encoding === "raw") { this.accommodate(bytes.length); view = new Uint8Array(this.data.buffer, this.write); this.write += util.binary.raw.decode(view); return this } if (encoding === "utf16") { this.accommodate(bytes.length * 2); view = new Uint16Array(this.data.buffer, this.write); this.write += util.text.utf16.encode(view); return this } throw new Error("Invalid encoding: " + encoding) } throw Error("Invalid parameter: " + bytes) }; util.DataBuffer.prototype.putBuffer = function (buffer) { this.putBytes(buffer); buffer.clear(); return this }; util.DataBuffer.prototype.putString = function (str) { return this.putBytes(str, "utf16") }; util.DataBuffer.prototype.putInt16 = function (i) { this.accommodate(2); this.data.setInt16(this.write, i); this.write += 2; return this }; util.DataBuffer.prototype.putInt24 = function (i) { this.accommodate(3); this.data.setInt16(this.write, i >> 8 & 65535); this.data.setInt8(this.write, i >> 16 & 255); this.write += 3; return this }; util.DataBuffer.prototype.putInt32 = function (i) { this.accommodate(4); this.data.setInt32(this.write, i); this.write += 4; return this }; util.DataBuffer.prototype.putInt16Le = function (i) { this.accommodate(2); this.data.setInt16(this.write, i, true); this.write += 2; return this }; util.DataBuffer.prototype.putInt24Le = function (i) { this.accommodate(3); this.data.setInt8(this.write, i >> 16 & 255); this.data.setInt16(this.write, i >> 8 & 65535, true); this.write += 3; return this }; util.DataBuffer.prototype.putInt32Le = function (i) { this.accommodate(4); this.data.setInt32(this.write, i, true); this.write += 4; return this }; util.DataBuffer.prototype.putInt = function (i, n) { _checkBitsParam(n); this.accommodate(n / 8); do { n -= 8; this.data.setInt8(this.write++, i >> n & 255) } while (n > 0); return this }; util.DataBuffer.prototype.putSignedInt = function (i, n) { _checkBitsParam(n); this.accommodate(n / 8); if (i < 0) { i += 2 << n - 1 } return this.putInt(i, n) }; util.DataBuffer.prototype.getByte = function () { return this.data.getInt8(this.read++) }; util.DataBuffer.prototype.getInt16 = function () { var rval = this.data.getInt16(this.read); this.read += 2; return rval }; util.DataBuffer.prototype.getInt24 = function () { var rval = this.data.getInt16(this.read) << 8 ^ this.data.getInt8(this.read + 2); this.read += 3; return rval }; util.DataBuffer.prototype.getInt32 = function () { var rval = this.data.getInt32(this.read); this.read += 4; return rval }; util.DataBuffer.prototype.getInt16Le = function () { var rval = this.data.getInt16(this.read, true); this.read += 2; return rval }; util.DataBuffer.prototype.getInt24Le = function () { var rval = this.data.getInt8(this.read) ^ this.data.getInt16(this.read + 1, true) << 8; this.read += 3; return rval }; util.DataBuffer.prototype.getInt32Le = function () { var rval = this.data.getInt32(this.read, true); this.read += 4; return rval }; util.DataBuffer.prototype.getInt = function (n) { _checkBitsParam(n); var rval = 0; do { rval = (rval << 8) + this.data.getInt8(this.read++); n -= 8 } while (n > 0); return rval }; util.DataBuffer.prototype.getSignedInt = function (n) { var x = this.getInt(n); var max = 2 << n - 2; if (x >= max) { x -= max << 1 } return x }; util.DataBuffer.prototype.getBytes = function (count) { var rval; if (count) { count = Math.min(this.length(), count); rval = this.data.slice(this.read, this.read + count); this.read += count } else if (count === 0) { rval = "" } else { rval = this.read === 0 ? this.data : this.data.slice(this.read); this.clear() } return rval }; util.DataBuffer.prototype.bytes = function (count) { return typeof count === "undefined" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + count) }; util.DataBuffer.prototype.at = function (i) { return this.data.getUint8(this.read + i) }; util.DataBuffer.prototype.setAt = function (i, b) { this.data.setUint8(i, b); return this }; util.DataBuffer.prototype.last = function () { return this.data.getUint8(this.write - 1) }; util.DataBuffer.prototype.copy = function () { return new util.DataBuffer(this) }; util.DataBuffer.prototype.compact = function () { if (this.read > 0) { var src = new Uint8Array(this.data.buffer, this.read); var dst = new Uint8Array(src.byteLength); dst.set(src); this.data = new DataView(dst); this.write -= this.read; this.read = 0 } return this }; util.DataBuffer.prototype.clear = function () { this.data = new DataView(new ArrayBuffer(0)); this.read = this.write = 0; return this }; util.DataBuffer.prototype.truncate = function (count) { this.write = Math.max(0, this.length() - count); this.read = Math.min(this.read, this.write); return this }; util.DataBuffer.prototype.toHex = function () { var rval = ""; for (var i = this.read; i < this.data.byteLength; ++i) { var b = this.data.getUint8(i); if (b < 16) { rval += "0" } rval += b.toString(16) } return rval }; util.DataBuffer.prototype.toString = function (encoding) { var view = new Uint8Array(this.data, this.read, this.length()); encoding = encoding || "utf8"; if (encoding === "binary" || encoding === "raw") { return util.binary.raw.encode(view) } if (encoding === "hex") { return util.binary.hex.encode(view) } if (encoding === "base64") { return util.binary.base64.encode(view) } if (encoding === "utf8") { return util.text.utf8.decode(view) } if (encoding === "utf16") { return util.text.utf16.decode(view) } throw new Error("Invalid encoding: " + encoding) }; util.createBuffer = function (input, encoding) { encoding = encoding || "raw"; if (input !== undefined && encoding === "utf8") { input = util.encodeUtf8(input) } return new util.ByteBuffer(input) }; util.fillString = function (c, n) { var s = ""; while (n > 0) { if (n & 1) { s += c } n >>>= 1; if (n > 0) { c += c } } return s }; util.xorBytes = function (s1, s2, n) { var s3 = ""; var b = ""; var t = ""; var i = 0; var c = 0; for (; n > 0; --n, ++i) { b = s1.charCodeAt(i) ^ s2.charCodeAt(i); if (c >= 10) { s3 += t; t = ""; c = 0 } t += String.fromCharCode(b); ++c } s3 += t; return s3 }; util.hexToBytes = function (hex) { var rval = ""; var i = 0; if (hex.length & 1 == 1) { i = 1; rval += String.fromCharCode(parseInt(hex[0], 16)) } for (; i < hex.length; i += 2) { rval += String.fromCharCode(parseInt(hex.substr(i, 2), 16)) } return rval }; util.bytesToHex = function (bytes) { return util.createBuffer(bytes).toHex() }; util.int32ToBytes = function (i) { return String.fromCharCode(i >> 24 & 255) + String.fromCharCode(i >> 16 & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i & 255) }; var _base64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="; var _base64Idx = [62, -1, -1, -1, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, 64, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51]; var _base58 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"; util.encode64 = function (input, maxline) { var line = ""; var output = ""; var chr1, chr2, chr3; var i = 0; while (i < input.length) { chr1 = input.charCodeAt(i++); chr2 = input.charCodeAt(i++); chr3 = input.charCodeAt(i++); line += _base64.charAt(chr1 >> 2); line += _base64.charAt((chr1 & 3) << 4 | chr2 >> 4); if (isNaN(chr2)) { line += "==" } else { line += _base64.charAt((chr2 & 15) << 2 | chr3 >> 6); line += isNaN(chr3) ? "=" : _base64.charAt(chr3 & 63) } if (maxline && line.length > maxline) { output += line.substr(0, maxline) + "\r\n"; line = line.substr(maxline) } } output += line; return output }; util.decode64 = function (input) { input = input.replace(/[^A-Za-z0-9\+\/\=]/g, ""); var output = ""; var enc1, enc2, enc3, enc4; var i = 0; while (i < input.length) { enc1 = _base64Idx[input.charCodeAt(i++) - 43]; enc2 = _base64Idx[input.charCodeAt(i++) - 43]; enc3 = _base64Idx[input.charCodeAt(i++) - 43]; enc4 = _base64Idx[input.charCodeAt(i++) - 43]; output += String.fromCharCode(enc1 << 2 | enc2 >> 4); if (enc3 !== 64) { output += String.fromCharCode((enc2 & 15) << 4 | enc3 >> 2); if (enc4 !== 64) { output += String.fromCharCode((enc3 & 3) << 6 | enc4) } } } return output }; util.encodeUtf8 = function (str) { return unescape(encodeURIComponent(str)) }; util.decodeUtf8 = function (str) { return decodeURIComponent(escape(str)) }; util.binary = { raw: {}, hex: {}, base64: {}, base58: {}, baseN: { encode: baseN.encode, decode: baseN.decode } }; util.binary.raw.encode = function (bytes) { return String.fromCharCode.apply(null, bytes) }; util.binary.raw.decode = function (str, output, offset) { var out = output; if (!out) { out = new Uint8Array(str.length) } offset = offset || 0; var j = offset; for (var i = 0; i < str.length; ++i) { out[j++] = str.charCodeAt(i) } return output ? j - offset : out }; util.binary.hex.encode = util.bytesToHex; util.binary.hex.decode = function (hex, output, offset) { var out = output; if (!out) { out = new Uint8Array(Math.ceil(hex.length / 2)) } offset = offset || 0; var i = 0, j = offset; if (hex.length & 1) { i = 1; out[j++] = parseInt(hex[0], 16) } for (; i < hex.length; i += 2) { out[j++] = parseInt(hex.substr(i, 2), 16) } return output ? j - offset : out }; util.binary.base64.encode = function (input, maxline) { var line = ""; var output = ""; var chr1, chr2, chr3; var i = 0; while (i < input.byteLength) { chr1 = input[i++]; chr2 = input[i++]; chr3 = input[i++]; line += _base64.charAt(chr1 >> 2); line += _base64.charAt((chr1 & 3) << 4 | chr2 >> 4); if (isNaN(chr2)) { line += "==" } else { line += _base64.charAt((chr2 & 15) << 2 | chr3 >> 6); line += isNaN(chr3) ? "=" : _base64.charAt(chr3 & 63) } if (maxline && line.length > maxline) { output += line.substr(0, maxline) + "\r\n"; line = line.substr(maxline) } } output += line; return output }; util.binary.base64.decode = function (input, output, offset) { var out = output; if (!out) { out = new Uint8Array(Math.ceil(input.length / 4) * 3) } input = input.replace(/[^A-Za-z0-9\+\/\=]/g, ""); offset = offset || 0; var enc1, enc2, enc3, enc4; var i = 0, j = offset; while (i < input.length) { enc1 = _base64Idx[input.charCodeAt(i++) - 43]; enc2 = _base64Idx[input.charCodeAt(i++) - 43]; enc3 = _base64Idx[input.charCodeAt(i++) - 43]; enc4 = _base64Idx[input.charCodeAt(i++) - 43]; out[j++] = enc1 << 2 | enc2 >> 4; if (enc3 !== 64) { out[j++] = (enc2 & 15) << 4 | enc3 >> 2; if (enc4 !== 64) { out[j++] = (enc3 & 3) << 6 | enc4 } } } return output ? j - offset : out.subarray(0, j) }; util.binary.base58.encode = function (input, maxline) { return util.binary.baseN.encode(input, _base58, maxline) }; util.binary.base58.decode = function (input, maxline) { return util.binary.baseN.decode(input, _base58, maxline) }; util.text = { utf8: {}, utf16: {} }; util.text.utf8.encode = function (str, output, offset) { str = util.encodeUtf8(str); var out = output; if (!out) { out = new Uint8Array(str.length) } offset = offset || 0; var j = offset; for (var i = 0; i < str.length; ++i) { out[j++] = str.charCodeAt(i) } return output ? j - offset : out }; util.text.utf8.decode = function (bytes) { return util.decodeUtf8(String.fromCharCode.apply(null, bytes)) }; util.text.utf16.encode = function (str, output, offset) { var out = output; if (!out) { out = new Uint8Array(str.length * 2) } var view = new Uint16Array(out.buffer); offset = offset || 0; var j = offset; var k = offset; for (var i = 0; i < str.length; ++i) { view[k++] = str.charCodeAt(i); j += 2 } return output ? j - offset : out }; util.text.utf16.decode = function (bytes) { return String.fromCharCode.apply(null, new Uint16Array(bytes.buffer)) }; util.deflate = function (api, bytes, raw) { bytes = util.decode64(api.deflate(util.encode64(bytes)).rval); if (raw) { var start = 2; var flg = bytes.charCodeAt(1); if (flg & 32) { start = 6 } bytes = bytes.substring(start, bytes.length - 4) } return bytes }; util.inflate = function (api, bytes, raw) { var rval = api.inflate(util.encode64(bytes)).rval; return rval === null ? null : util.decode64(rval) }; var _setStorageObject = function (api, id, obj) { if (!api) { throw new Error("WebStorage not available.") } var rval; if (obj === null) { rval = api.removeItem(id) } else { obj = util.encode64(JSON.stringify(obj)); rval = api.setItem(id, obj) } if (typeof rval !== "undefined" && rval.rval !== true) { var error = new Error(rval.error.message); error.id = rval.error.id; error.name = rval.error.name; throw error } }; var _getStorageObject = function (api, id) { if (!api) { throw new Error("WebStorage not available.") } var rval = api.getItem(id); if (api.init) { if (rval.rval === null) { if (rval.error) { var error = new Error(rval.error.message); error.id = rval.error.id; error.name = rval.error.name; throw error } rval = null } else { rval = rval.rval } } if (rval !== null) { rval = JSON.parse(util.decode64(rval)) } return rval }; var _setItem = function (api, id, key, data) { var obj = _getStorageObject(api, id); if (obj === null) { obj = {} } obj[key] = data; _setStorageObject(api, id, obj) }; var _getItem = function (api, id, key) { var rval = _getStorageObject(api, id); if (rval !== null) { rval = key in rval ? rval[key] : null } return rval }; var _removeItem = function (api, id, key) { var obj = _getStorageObject(api, id); if (obj !== null && key in obj) { delete obj[key]; var empty = true; for (var prop in obj) { empty = false; break } if (empty) { obj = null } _setStorageObject(api, id, obj) } }; var _clearItems = function (api, id) { _setStorageObject(api, id, null) }; var _callStorageFunction = function (func, args, location) { var rval = null; if (typeof location === "undefined") { location = ["web", "flash"] } var type; var done = false; var exception = null; for (var idx in location) { type = location[idx]; try { if (type === "flash" || type === "both") { if (args[0] === null) { throw new Error("Flash local storage not available.") } rval = func.apply(this, args); done = type === "flash" } if (type === "web" || type === "both") { args[0] = localStorage; rval = func.apply(this, args); done = true } } catch (ex) { exception = ex } if (done) { break } } if (!done) { throw exception } return rval }; util.setItem = function (api, id, key, data, location) { _callStorageFunction(_setItem, arguments, location) }; util.getItem = function (api, id, key, location) { return _callStorageFunction(_getItem, arguments, location) }; util.removeItem = function (api, id, key, location) { _callStorageFunction(_removeItem, arguments, location) }; util.clearItems = function (api, id, location) { _callStorageFunction(_clearItems, arguments, location) }; util.parseUrl = function (str) { var regex = /^(https?):\/\/([^:&^\/]*):?(\d*)(.*)$/g; regex.lastIndex = 0; var m = regex.exec(str); var url = m === null ? null : { full: str, scheme: m[1], host: m[2], port: m[3], path: m[4] }; if (url) { url.fullHost = url.host; if (url.port) { if (url.port !== 80 && url.scheme === "http") { url.fullHost += ":" + url.port } else if (url.port !== 443 && url.scheme === "https") { url.fullHost += ":" + url.port } } else if (url.scheme === "http") { url.port = 80 } else if (url.scheme === "https") { url.port = 443 } url.full = url.scheme + "://" + url.fullHost } return url }; var _queryVariables = null; util.getQueryVariables = function (query) { var parse = function (q) { var rval = {}; var kvpairs = q.split("&"); for (var i = 0; i < kvpairs.length; i++) { var pos = kvpairs[i].indexOf("="); var key; var val; if (pos > 0) { key = kvpairs[i].substring(0, pos); val = kvpairs[i].substring(pos + 1) } else { key = kvpairs[i]; val = null } if (!(key in rval)) { rval[key] = [] } if (!(key in Object.prototype) && val !== null) { rval[key].push(unescape(val)) } } return rval }; var rval; if (typeof query === "undefined") { if (_queryVariables === null) { if (typeof window !== "undefined" && window.location && window.location.search) { _queryVariables = parse(window.location.search.substring(1)) } else { _queryVariables = {} } } rval = _queryVariables } else { rval = parse(query) } return rval }; util.parseFragment = function (fragment) { var fp = fragment; var fq = ""; var pos = fragment.indexOf("?"); if (pos > 0) { fp = fragment.substring(0, pos); fq = fragment.substring(pos + 1) } var path = fp.split("/"); if (path.length > 0 && path[0] === "") { path.shift() } var query = fq === "" ? {} : util.getQueryVariables(fq); return { pathString: fp, queryString: fq, path: path, query: query } }; util.makeRequest = function (reqString) { var frag = util.parseFragment(reqString); var req = { path: frag.pathString, query: frag.queryString, getPath: function (i) { return typeof i === "undefined" ? frag.path : frag.path[i] }, getQuery: function (k, i) { var rval; if (typeof k === "undefined") { rval = frag.query } else { rval = frag.query[k]; if (rval && typeof i !== "undefined") { rval = rval[i] } } return rval }, getQueryLast: function (k, _default) { var rval; var vals = req.getQuery(k); if (vals) { rval = vals[vals.length - 1] } else { rval = _default } return rval } }; return req }; util.makeLink = function (path, query, fragment) { path = jQuery.isArray(path) ? path.join("/") : path; var qstr = jQuery.param(query || {}); fragment = fragment || ""; return path + (qstr.length > 0 ? "?" + qstr : "") + (fragment.length > 0 ? "#" + fragment : "") }; util.setPath = function (object, keys, value) { if (typeof object === "object" && object !== null) { var i = 0; var len = keys.length; while (i < len) { var next = keys[i++]; if (i == len) { object[next] = value } else { var hasNext = next in object; if (!hasNext || hasNext && typeof object[next] !== "object" || hasNext && object[next] === null) { object[next] = {} } object = object[next] } } } }; util.getPath = function (object, keys, _default) { var i = 0; var len = keys.length; var hasNext = true; while (hasNext && i < len && typeof object === "object" && object !== null) { var next = keys[i++]; hasNext = next in object; if (hasNext) { object = object[next] } } return hasNext ? object : _default }; util.deletePath = function (object, keys) { if (typeof object === "object" && object !== null) { var i = 0; var len = keys.length; while (i < len) { var next = keys[i++]; if (i == len) { delete object[next] } else { if (!(next in object) || typeof object[next] !== "object" || object[next] === null) { break } object = object[next] } } } }; util.isEmpty = function (obj) { for (var prop in obj) { if (obj.hasOwnProperty(prop)) { return false } } return true }; util.format = function (format) { var re = /%./g; var match; var part; var argi = 0; var parts = []; var last = 0; while (match = re.exec(format)) { part = format.substring(last, re.lastIndex - 2); if (part.length > 0) { parts.push(part) } last = re.lastIndex; var code = match[0][1]; switch (code) { case "s": case "o": if (argi < arguments.length) { parts.push(arguments[argi++ + 1]) } else { parts.push("<?>") } break; case "%": parts.push("%"); break; default: parts.push("<%" + code + "?>") } } parts.push(format.substring(last)); return parts.join("") }; util.formatNumber = function (number, decimals, dec_point, thousands_sep) { var n = number, c = isNaN(decimals = Math.abs(decimals)) ? 2 : decimals; var d = dec_point === undefined ? "," : dec_point; var t = thousands_sep === undefined ? "." : thousands_sep, s = n < 0 ? "-" : ""; var i = parseInt(n = Math.abs(+n || 0).toFixed(c), 10) + ""; var j = i.length > 3 ? i.length % 3 : 0; return s + (j ? i.substr(0, j) + t : "") + i.substr(j).replace(/(\d{3})(?=\d)/g, "$1" + t) + (c ? d + Math.abs(n - i).toFixed(c).slice(2) : "") }; util.formatSize = function (size) { if (size >= 1073741824) { size = util.formatNumber(size / 1073741824, 2, ".", "") + " GiB" } else if (size >= 1048576) { size = util.formatNumber(size / 1048576, 2, ".", "") + " MiB" } else if (size >= 1024) { size = util.formatNumber(size / 1024, 0) + " KiB" } else { size = util.formatNumber(size, 0) + " bytes" } return size }; util.bytesFromIP = function (ip) { if (ip.indexOf(".") !== -1) { return util.bytesFromIPv4(ip) } if (ip.indexOf(":") !== -1) { return util.bytesFromIPv6(ip) } return null }; util.bytesFromIPv4 = function (ip) { ip = ip.split("."); if (ip.length !== 4) { return null } var b = util.createBuffer(); for (var i = 0; i < ip.length; ++i) { var num = parseInt(ip[i], 10); if (isNaN(num)) { return null } b.putByte(num) } return b.getBytes() }; util.bytesFromIPv6 = function (ip) { var blanks = 0; ip = ip.split(":").filter(function (e) { if (e.length === 0) ++blanks; return true }); var zeros = (8 - ip.length + blanks) * 2; var b = util.createBuffer(); for (var i = 0; i < 8; ++i) { if (!ip[i] || ip[i].length === 0) { b.fillWithByte(0, zeros); zeros = 0; continue } var bytes = util.hexToBytes(ip[i]); if (bytes.length < 2) { b.putByte(0) } b.putBytes(bytes) } return b.getBytes() }; util.bytesToIP = function (bytes) { if (bytes.length === 4) { return util.bytesToIPv4(bytes) } if (bytes.length === 16) { return util.bytesToIPv6(bytes) } return null }; util.bytesToIPv4 = function (bytes) { if (bytes.length !== 4) { return null } var ip = []; for (var i = 0; i < bytes.length; ++i) { ip.push(bytes.charCodeAt(i)) } return ip.join(".") }; util.bytesToIPv6 = function (bytes) { if (bytes.length !== 16) { return null } var ip = []; var zeroGroups = []; var zeroMaxGroup = 0; for (var i = 0; i < bytes.length; i += 2) { var hex = util.bytesToHex(bytes[i] + bytes[i + 1]); while (hex[0] === "0" && hex !== "0") { hex = hex.substr(1) } if (hex === "0") { var last = zeroGroups[zeroGroups.length - 1]; var idx = ip.length; if (!last || idx !== last.end + 1) { zeroGroups.push({ start: idx, end: idx }) } else { last.end = idx; if (last.end - last.start > zeroGroups[zeroMaxGroup].end - zeroGroups[zeroMaxGroup].start) { zeroMaxGroup = zeroGroups.length - 1 } } } ip.push(hex) } if (zeroGroups.length > 0) { var group = zeroGroups[zeroMaxGroup]; if (group.end - group.start > 0) { ip.splice(group.start, group.end - group.start + 1, ""); if (group.start === 0) { ip.unshift("") } if (group.end === 7) { ip.push("") } } } return ip.join(":") }; util.estimateCores = function (options, callback) { if (typeof options === "function") { callback = options; options = {} } options = options || {}; if ("cores" in util && !options.update) { return callback(null, util.cores) } if (typeof navigator !== "undefined" && "hardwareConcurrency" in navigator && navigator.hardwareConcurrency > 0) { util.cores = navigator.hardwareConcurrency; return callback(null, util.cores) } if (typeof Worker === "undefined") { util.cores = 1; return callback(null, util.cores) } if (typeof Blob === "undefined") { util.cores = 2; return callback(null, util.cores) } var blobUrl = URL.createObjectURL(new Blob(["(", function () { self.addEventListener("message", function (e) { var st = Date.now(); var et = st + 4; while (Date.now() < et); self.postMessage({ st: st, et: et }) }) }.toString(), ")()"], { type: "application/javascript" })); sample([], 5, 16); function sample(max, samples, numWorkers) { if (samples === 0) { var avg = Math.floor(max.reduce(function (avg, x) { return avg + x }, 0) / max.length); util.cores = Math.max(1, avg); URL.revokeObjectURL(blobUrl); return callback(null, util.cores) } map(numWorkers, function (err, results) { max.push(reduce(numWorkers, results)); sample(max, samples - 1, numWorkers) }) } function map(numWorkers, callback) { var workers = []; var results = []; for (var i = 0; i < numWorkers; ++i) { var worker = new Worker(blobUrl); worker.addEventListener("message", function (e) { results.push(e.data); if (results.length === numWorkers) { for (var i = 0; i < numWorkers; ++i) { workers[i].terminate() } callback(null, results) } }); workers.push(worker) } for (var i = 0; i < numWorkers; ++i) { workers[i].postMessage(i) } } function reduce(numWorkers, results) { var overlaps = []; for (var n = 0; n < numWorkers; ++n) { var r1 = results[n]; var overlap = overlaps[n] = []; for (var i = 0; i < numWorkers; ++i) { if (n === i) { continue } var r2 = results[i]; if (r1.st > r2.st && r1.st < r2.et || r2.st > r1.st && r2.st < r1.et) { overlap.push(i) } } } return overlaps.reduce(function (max, overlap) { return Math.max(max, overlap.length) }, 0) } } }).call(this, require("_process"), typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, require("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], require("timers").setImmediate) }, { "./baseN": 10, "./forge": 16, _process: 50, buffer: 6, timers: 51 }], 49: [function (require, module, exports) { var forge = require("./forge"); require("./aes"); require("./asn1"); require("./des"); require("./md"); require("./mgf"); require("./oids"); require("./pem"); require("./pss"); require("./rsa"); require("./util"); var asn1 = forge.asn1; var pki = module.exports = forge.pki = forge.pki || {}; var oids = pki.oids; var _shortNames = {}; _shortNames["CN"] = oids["commonName"]; _shortNames["commonName"] = "CN"; _shortNames["C"] = oids["countryName"]; _shortNames["countryName"] = "C"; _shortNames["L"] = oids["localityName"]; _shortNames["localityName"] = "L"; _shortNames["ST"] = oids["stateOrProvinceName"]; _shortNames["stateOrProvinceName"] = "ST"; _shortNames["O"] = oids["organizationName"]; _shortNames["organizationName"] = "O"; _shortNames["OU"] = oids["organizationalUnitName"]; _shortNames["organizationalUnitName"] = "OU"; _shortNames["E"] = oids["emailAddress"]; _shortNames["emailAddress"] = "E"; var publicKeyValidator = forge.pki.rsa.publicKeyValidator; var x509CertificateValidator = { name: "Certificate", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.SEQUENCE, constructed: true, value: [{ name: "Certificate.TBSCertificate", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.SEQUENCE, constructed: true, captureAsn1: "tbsCertificate", value: [{ name: "Certificate.TBSCertificate.version", tagClass: asn1.Class.CONTEXT_SPECIFIC, type: 0, constructed: true, optional: true, value: [{ name: "Certificate.TBSCertificate.version.integer", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.INTEGER, constructed: false, capture: "certVersion" }] }, { name: "Certificate.TBSCertificate.serialNumber", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.INTEGER, constructed: false, capture: "certSerialNumber" }, { name: "Certificate.TBSCertificate.signature", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.SEQUENCE, constructed: true, value: [{ name: "Certificate.TBSCertificate.signature.algorithm", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.OID, constructed: false, capture: "certinfoSignatureOid" }, { name: "Certificate.TBSCertificate.signature.parameters", tagClass: asn1.Class.UNIVERSAL, optional: true, captureAsn1: "certinfoSignatureParams" }] }, { name: "Certificate.TBSCertificate.issuer", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.SEQUENCE, constructed: true, captureAsn1: "certIssuer" }, { name: "Certificate.TBSCertificate.validity", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.SEQUENCE, constructed: true, value: [{ name: "Certificate.TBSCertificate.validity.notBefore (utc)", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.UTCTIME, constructed: false, optional: true, capture: "certValidity1UTCTime" }, { name: "Certificate.TBSCertificate.validity.notBefore (generalized)", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.GENERALIZEDTIME, constructed: false, optional: true, capture: "certValidity2GeneralizedTime" }, { name: "Certificate.TBSCertificate.validity.notAfter (utc)", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.UTCTIME, constructed: false, optional: true, capture: "certValidity3UTCTime" }, { name: "Certificate.TBSCertificate.validity.notAfter (generalized)", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.GENERALIZEDTIME, constructed: false, optional: true, capture: "certValidity4GeneralizedTime" }] }, { name: "Certificate.TBSCertificate.subject", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.SEQUENCE, constructed: true, captureAsn1: "certSubject" }, publicKeyValidator, { name: "Certificate.TBSCertificate.issuerUniqueID", tagClass: asn1.Class.CONTEXT_SPECIFIC, type: 1, constructed: true, optional: true, value: [{ name: "Certificate.TBSCertificate.issuerUniqueID.id", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.BITSTRING, constructed: false, captureBitStringValue: "certIssuerUniqueId" }] }, { name: "Certificate.TBSCertificate.subjectUniqueID", tagClass: asn1.Class.CONTEXT_SPECIFIC, type: 2, constructed: true, optional: true, value: [{ name: "Certificate.TBSCertificate.subjectUniqueID.id", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.BITSTRING, constructed: false, captureBitStringValue: "certSubjectUniqueId" }] }, { name: "Certificate.TBSCertificate.extensions", tagClass: asn1.Class.CONTEXT_SPECIFIC, type: 3, constructed: true, captureAsn1: "certExtensions", optional: true }] }, { name: "Certificate.signatureAlgorithm", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.SEQUENCE, constructed: true, value: [{ name: "Certificate.signatureAlgorithm.algorithm", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.OID, constructed: false, capture: "certSignatureOid" }, { name: "Certificate.TBSCertificate.signature.parameters", tagClass: asn1.Class.UNIVERSAL, optional: true, captureAsn1: "certSignatureParams" }] }, { name: "Certificate.signatureValue", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.BITSTRING, constructed: false, captureBitStringValue: "certSignature" }] }; var rsassaPssParameterValidator = { name: "rsapss", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.SEQUENCE, constructed: true, value: [{ name: "rsapss.hashAlgorithm", tagClass: asn1.Class.CONTEXT_SPECIFIC, type: 0, constructed: true, value: [{ name: "rsapss.hashAlgorithm.AlgorithmIdentifier", tagClass: asn1.Class.UNIVERSAL, type: asn1.Class.SEQUENCE, constructed: true, optional: true, value: [{ name: "rsapss.hashAlgorithm.AlgorithmIdentifier.algorithm", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.OID, constructed: false, capture: "hashOid" }] }] }, { name: "rsapss.maskGenAlgorithm", tagClass: asn1.Class.CONTEXT_SPECIFIC, type: 1, constructed: true, value: [{ name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier", tagClass: asn1.Class.UNIVERSAL, type: asn1.Class.SEQUENCE, constructed: true, optional: true, value: [{ name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.algorithm", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.OID, constructed: false, capture: "maskGenOid" }, { name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.SEQUENCE, constructed: true, value: [{ name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params.algorithm", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.OID, constructed: false, capture: "maskGenHashOid" }] }] }] }, { name: "rsapss.saltLength", tagClass: asn1.Class.CONTEXT_SPECIFIC, type: 2, optional: true, value: [{ name: "rsapss.saltLength.saltLength", tagClass: asn1.Class.UNIVERSAL, type: asn1.Class.INTEGER, constructed: false, capture: "saltLength" }] }, { name: "rsapss.trailerField", tagClass: asn1.Class.CONTEXT_SPECIFIC, type: 3, optional: true, value: [{ name: "rsapss.trailer.trailer", tagClass: asn1.Class.UNIVERSAL, type: asn1.Class.INTEGER, constructed: false, capture: "trailer" }] }] }; var certificationRequestInfoValidator = { name: "CertificationRequestInfo", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.SEQUENCE, constructed: true, captureAsn1: "certificationRequestInfo", value: [{ name: "CertificationRequestInfo.integer", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.INTEGER, constructed: false, capture: "certificationRequestInfoVersion" }, { name: "CertificationRequestInfo.subject", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.SEQUENCE, constructed: true, captureAsn1: "certificationRequestInfoSubject" }, publicKeyValidator, { name: "CertificationRequestInfo.attributes", tagClass: asn1.Class.CONTEXT_SPECIFIC, type: 0, constructed: true, optional: true, capture: "certificationRequestInfoAttributes", value: [{ name: "CertificationRequestInfo.attributes", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.SEQUENCE, constructed: true, value: [{ name: "CertificationRequestInfo.attributes.type", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.OID, constructed: false }, { name: "CertificationRequestInfo.attributes.value", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.SET, constructed: true }] }] }] }; var certificationRequestValidator = { name: "CertificationRequest", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.SEQUENCE, constructed: true, captureAsn1: "csr", value: [certificationRequestInfoValidator, { name: "CertificationRequest.signatureAlgorithm", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.SEQUENCE, constructed: true, value: [{ name: "CertificationRequest.signatureAlgorithm.algorithm", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.OID, constructed: false, capture: "csrSignatureOid" }, { name: "CertificationRequest.signatureAlgorithm.parameters", tagClass: asn1.Class.UNIVERSAL, optional: true, captureAsn1: "csrSignatureParams" }] }, { name: "CertificationRequest.signature", tagClass: asn1.Class.UNIVERSAL, type: asn1.Type.BITSTRING, constructed: false, captureBitStringValue: "csrSignature" }] }; pki.RDNAttributesAsArray = function (rdn, md) { var rval = []; var set, attr, obj; for (var si = 0; si < rdn.value.length; ++si) { set = rdn.value[si]; for (var i = 0; i < set.value.length; ++i) { obj = {}; attr = set.value[i]; obj.type = asn1.derToOid(attr.value[0].value); obj.value = attr.value[1].value; obj.valueTagClass = attr.value[1].type; if (obj.type in oids) { obj.name = oids[obj.type]; if (obj.name in _shortNames) { obj.shortName = _shortNames[obj.name] } } if (md) { md.update(obj.type); md.update(obj.value) } rval.push(obj) } } return rval }; pki.CRIAttributesAsArray = function (attributes) { var rval = []; for (var si = 0; si < attributes.length; ++si) { var seq = attributes[si]; var type = asn1.derToOid(seq.value[0].value); var values = seq.value[1].value; for (var vi = 0; vi < values.length; ++vi) { var obj = {}; obj.type = type; obj.value = values[vi].value; obj.valueTagClass = values[vi].type; if (obj.type in oids) { obj.name = oids[obj.type]; if (obj.name in _shortNames) { obj.shortName = _shortNames[obj.name] } } if (obj.type === oids.extensionRequest) { obj.extensions = []; for (var ei = 0; ei < obj.value.length; ++ei) { obj.extensions.push(pki.certificateExtensionFromAsn1(obj.value[ei])) } } rval.push(obj) } } return rval }; function _getAttribute(obj, options) { if (typeof options === "string") { options = { shortName: options } } var rval = null; var attr; for (var i = 0; rval === null && i < obj.attributes.length; ++i) { attr = obj.attributes[i]; if (options.type && options.type === attr.type) { rval = attr } else if (options.name && options.name === attr.name) { rval = attr } else if (options.shortName && options.shortName === attr.shortName) { rval = attr } } return rval } var _readSignatureParameters = function (oid, obj, fillDefaults) { var params = {}; if (oid !== oids["RSASSA-PSS"]) { return params } if (fillDefaults) { params = { hash: { algorithmOid: oids["sha1"] }, mgf: { algorithmOid: oids["mgf1"], hash: { algorithmOid: oids["sha1"] } }, saltLength: 20 } } var capture = {}; var errors = []; if (!asn1.validate(obj, rsassaPssParameterValidator, capture, errors)) { var error = new Error("Cannot read RSASSA-PSS parameter block."); error.errors = errors; throw error } if (capture.hashOid !== undefined) { params.hash = params.hash || {}; params.hash.algorithmOid = asn1.derToOid(capture.hashOid) } if (capture.maskGenOid !== undefined) { params.mgf = params.mgf || {}; params.mgf.algorithmOid = asn1.derToOid(capture.maskGenOid); params.mgf.hash = params.mgf.hash || {}; params.mgf.hash.algorithmOid = asn1.derToOid(capture.maskGenHashOid) } if (capture.saltLength !== undefined) { params.saltLength = capture.saltLength.charCodeAt(0) } return params }; pki.certificateFromPem = function (pem, computeHash, strict) { var msg = forge.pem.decode(pem)[0]; if (msg.type !== "CERTIFICATE" && msg.type !== "X509 CERTIFICATE" && msg.type !== "TRUSTED CERTIFICATE") { var error = new Error("Could not convert certificate from PEM; PEM header type " + 'is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".'); error.headerType = msg.type; throw error } if (msg.procType && msg.procType.type === "ENCRYPTED") { throw new Error("Could not convert certificate from PEM; PEM is encrypted.") } var obj = asn1.fromDer(msg.body, strict); return pki.certificateFromAsn1(obj, computeHash) }; pki.certificateToPem = function (cert, maxline) { var msg = { type: "CERTIFICATE", body: asn1.toDer(pki.certificateToAsn1(cert)).getBytes() }; return forge.pem.encode(msg, { maxline: maxline }) }; pki.publicKeyFromPem = function (pem) { var msg = forge.pem.decode(pem)[0]; if (msg.type !== "PUBLIC KEY" && msg.type !== "RSA PUBLIC KEY") { var error = new Error("Could not convert public key from PEM; PEM header " + 'type is not "PUBLIC KEY" or "RSA PUBLIC KEY".'); error.headerType = msg.type; throw error } if (msg.procType && msg.procType.type === "ENCRYPTED") { throw new Error("Could not convert public key from PEM; PEM is encrypted.") } var obj = asn1.fromDer(msg.body); return pki.publicKeyFromAsn1(obj) }; pki.publicKeyToPem = function (key, maxline) { var msg = { type: "PUBLIC KEY", body: asn1.toDer(pki.publicKeyToAsn1(key)).getBytes() }; return forge.pem.encode(msg, { maxline: maxline }) }; pki.publicKeyToRSAPublicKeyPem = function (key, maxline) { var msg = { type: "RSA PUBLIC KEY", body: asn1.toDer(pki.publicKeyToRSAPublicKey(key)).getBytes() }; return forge.pem.encode(msg, { maxline: maxline }) }; pki.getPublicKeyFingerprint = function (key, options) { options = options || {}; var md = options.md || forge.md.sha1.create(); var type = options.type || "RSAPublicKey"; var bytes; switch (type) { case "RSAPublicKey": bytes = asn1.toDer(pki.publicKeyToRSAPublicKey(key)).getBytes(); break; case "SubjectPublicKeyInfo": bytes = asn1.toDer(pki.publicKeyToAsn1(key)).getBytes(); break; default: throw new Error('Unknown fingerprint type "' + options.type + '".') }md.start(); md.update(bytes); var digest = md.digest(); if (options.encoding === "hex") { var hex = digest.toHex(); if (options.delimiter) { return hex.match(/.{2}/g).join(options.delimiter) } return hex } else if (options.encoding === "binary") { return digest.getBytes() } else if (options.encoding) { throw new Error('Unknown encoding "' + options.encoding + '".') } return digest }; pki.certificationRequestFromPem = function (pem, computeHash, strict) { var msg = forge.pem.decode(pem)[0]; if (msg.type !== "CERTIFICATE REQUEST") { var error = new Error("Could not convert certification request from PEM; " + 'PEM header type is not "CERTIFICATE REQUEST".'); error.headerType = msg.type; throw error } if (msg.procType && msg.procType.type === "ENCRYPTED") { throw new Error("Could not convert certification request from PEM; " + "PEM is encrypted.") } var obj = asn1.fromDer(msg.body, strict); return pki.certificationRequestFromAsn1(obj, computeHash) }; pki.certificationRequestToPem = function (csr, maxline) { var msg = { type: "CERTIFICATE REQUEST", body: asn1.toDer(pki.certificationRequestToAsn1(csr)).getBytes() }; return forge.pem.encode(msg, { maxline: maxline }) }; pki.createCertificate = function () { var cert = {}; cert.version = 2; cert.serialNumber = "00"; cert.signatureOid = null; cert.signature = null; cert.siginfo = {}; cert.siginfo.algorithmOid = null; cert.validity = {}; cert.validity.notBefore = new Date; cert.validity.notAfter = new Date; cert.issuer = {}; cert.issuer.getField = function (sn) { return _getAttribute(cert.issuer, sn) }; cert.issuer.addField = function (attr) { _fillMissingFields([attr]); cert.issuer.attributes.push(attr) }; cert.issuer.attributes = []; cert.issuer.hash = null; cert.subject = {}; cert.subject.getField = function (sn) { return _getAttribute(cert.subject, sn) }; cert.subject.addField = function (attr) { _fillMissingFields([attr]); cert.subject.attributes.push(attr) }; cert.subject.attributes = []; cert.subject.hash = null; cert.extensions = []; cert.publicKey = null; cert.md = null; cert.setSubject = function (attrs, uniqueId) { _fillMissingFields(attrs); cert.subject.attributes = attrs; delete cert.subject.uniqueId; if (uniqueId) { cert.subject.uniqueId = uniqueId } cert.subject.hash = null }; cert.setIssuer = function (attrs, uniqueId) { _fillMissingFields(attrs); cert.issuer.attributes = attrs; delete cert.issuer.uniqueId; if (uniqueId) { cert.issuer.uniqueId = uniqueId } cert.issuer.hash = null }; cert.setExtensions = function (exts) { for (var i = 0; i < exts.length; ++i) { _fillMissingExtensionFields(exts[i], { cert: cert }) } cert.extensions = exts }; cert.getExtension = function (options) { if (typeof options === "string") { options = { name: options } } var rval = null; var ext; for (var i = 0; rval === null && i < cert.extensions.length; ++i) { ext = cert.extensions[i]; if (options.id && ext.id === options.id) { rval = ext } else if (options.name && ext.name === options.name) { rval = ext } } return rval }; cert.sign = function (key, md) { cert.md = md || forge.md.sha1.create(); var algorithmOid = oids[cert.md.algorithm + "WithRSAEncryption"]; if (!algorithmOid) { var error = new Error("Could not compute certificate digest. " + "Unknown message digest algorithm OID."); error.algorithm = cert.md.algorithm; throw error } cert.signatureOid = cert.siginfo.algorithmOid = algorithmOid; cert.tbsCertificate = pki.getTBSCertificate(cert); var bytes = asn1.toDer(cert.tbsCertificate); cert.md.update(bytes.getBytes()); cert.signature = key.sign(cert.md) }; cert.verify = function (child) { var rval = false; if (!cert.issued(child)) { var issuer = child.issuer; var subject = cert.subject; var error = new Error("The parent certificate did not issue the given child " + "certificate; the child certificate's issuer does not match the " + "parent's subject."); error.expectedIssuer = issuer.attributes; error.actualIssuer = subject.attributes; throw error } var md = child.md; if (md === null) { if (child.signatureOid in oids) { var oid = oids[child.signatureOid]; switch (oid) { case "sha1WithRSAEncryption": md = forge.md.sha1.create(); break; case "md5WithRSAEncryption": md = forge.md.md5.create(); break; case "sha256WithRSAEncryption": md = forge.md.sha256.create(); break; case "sha384WithRSAEncryption": md = forge.md.sha384.create(); break; case "sha512WithRSAEncryption": md = forge.md.sha512.create(); break; case "RSASSA-PSS": md = forge.md.sha256.create(); break } } if (md === null) { var error = new Error("Could not compute certificate digest. " + "Unknown signature OID."); error.signatureOid = child.signatureOid; throw error } var tbsCertificate = child.tbsCertificate || pki.getTBSCertificate(child); var bytes = asn1.toDer(tbsCertificate); md.update(bytes.getBytes()) } if (md !== null) { var scheme; switch (child.signatureOid) { case oids.sha1WithRSAEncryption: scheme = undefined; break; case oids["RSASSA-PSS"]: var hash, mgf; hash = oids[child.signatureParameters.mgf.hash.algorithmOid]; if (hash === undefined || forge.md[hash] === undefined) { var error = new Error("Unsupported MGF hash function."); error.oid = child.signatureParameters.mgf.hash.algorithmOid; error.name = hash; throw error } mgf = oids[child.signatureParameters.mgf.algorithmOid]; if (mgf === undefined || forge.mgf[mgf] === undefined) { var error = new Error("Unsupported MGF function."); error.oid = child.signatureParameters.mgf.algorithmOid; error.name = mgf; throw error } mgf = forge.mgf[mgf].create(forge.md[hash].create()); hash = oids[child.signatureParameters.hash.algorithmOid]; if (hash === undefined || forge.md[hash] === undefined) { throw { message: "Unsupported RSASSA-PSS hash function.", oid: child.signatureParameters.hash.algorithmOid, name: hash } } scheme = forge.pss.create(forge.md[hash].create(), mgf, child.signatureParameters.saltLength); break }rval = cert.publicKey.verify(md.digest().getBytes(), child.signature, scheme) } return rval }; cert.isIssuer = function (parent) { var rval = false; var i = cert.issuer; var s = parent.subject; if (i.hash && s.hash) { rval = i.hash === s.hash } else if (i.attributes.length === s.attributes.length) { rval = true; var iattr, sattr; for (var n = 0; rval && n < i.attributes.length; ++n) { iattr = i.attributes[n]; sattr = s.attributes[n]; if (iattr.type !== sattr.type || iattr.value !== sattr.value) { rval = false } } } return rval }; cert.issued = function (child) { return child.isIssuer(cert) }; cert.generateSubjectKeyIdentifier = function () { return pki.getPublicKeyFingerprint(cert.publicKey, { type: "RSAPublicKey" }) }; cert.verifySubjectKeyIdentifier = function () { var oid = oids["subjectKeyIdentifier"]; for (var i = 0; i < cert.extensions.length; ++i) { var ext = cert.extensions[i]; if (ext.id === oid) { var ski = cert.generateSubjectKeyIdentifier().getBytes(); return forge.util.hexToBytes(ext.subjectKeyIdentifier) === ski } } return false }; return cert }; pki.certificateFromAsn1 = function (obj, computeHash) { var capture = {}; var errors = []; if (!asn1.validate(obj, x509CertificateValidator, capture, errors)) { var error = new Error("Cannot read X.509 certificate. " + "ASN.1 object is not an X509v3 Certificate."); error.errors = errors; throw error } var oid = asn1.derToOid(capture.publicKeyOid); if (oid !== pki.oids.rsaEncryption) { throw new Error("Cannot read public key. OID is not RSA.") } var cert = pki.createCertificate(); cert.version = capture.certVersion ? capture.certVersion.charCodeAt(0) : 0; var serial = forge.util.createBuffer(capture.certSerialNumber); cert.serialNumber = serial.toHex(); cert.signatureOid = forge.asn1.derToOid(capture.certSignatureOid); cert.signatureParameters = _readSignatureParameters(cert.signatureOid, capture.certSignatureParams, true); cert.siginfo.algorithmOid = forge.asn1.derToOid(capture.certinfoSignatureOid); cert.siginfo.parameters = _readSignatureParameters(cert.siginfo.algorithmOid, capture.certinfoSignatureParams, false); cert.signature = capture.certSignature; var validity = []; if (capture.certValidity1UTCTime !== undefined) { validity.push(asn1.utcTimeToDate(capture.certValidity1UTCTime)) } if (capture.certValidity2GeneralizedTime !== undefined) { validity.push(asn1.generalizedTimeToDate(capture.certValidity2GeneralizedTime)) } if (capture.certValidity3UTCTime !== undefined) { validity.push(asn1.utcTimeToDate(capture.certValidity3UTCTime)) } if (capture.certValidity4GeneralizedTime !== undefined) { validity.push(asn1.generalizedTimeToDate(capture.certValidity4GeneralizedTime)) } if (validity.length > 2) { throw new Error("Cannot read notBefore/notAfter validity times; more " + "than two times were provided in the certificate.") } if (validity.length < 2) { throw new Error("Cannot read notBefore/notAfter validity times; they " + "were not provided as either UTCTime or GeneralizedTime.") } cert.validity.notBefore = validity[0]; cert.validity.notAfter = validity[1]; cert.tbsCertificate = capture.tbsCertificate; if (computeHash) { cert.md = null; if (cert.signatureOid in oids) { var oid = oids[cert.signatureOid]; switch (oid) { case "sha1WithRSAEncryption": cert.md = forge.md.sha1.create(); break; case "md5WithRSAEncryption": cert.md = forge.md.md5.create(); break; case "sha256WithRSAEncryption": cert.md = forge.md.sha256.create(); break; case "sha384WithRSAEncryption": cert.md = forge.md.sha384.create(); break; case "sha512WithRSAEncryption": cert.md = forge.md.sha512.create(); break; case "RSASSA-PSS": cert.md = forge.md.sha256.create(); break } } if (cert.md === null) { var error = new Error("Could not compute certificate digest. " + "Unknown signature OID."); error.signatureOid = cert.signatureOid; throw error } var bytes = asn1.toDer(cert.tbsCertificate); cert.md.update(bytes.getBytes()) } var imd = forge.md.sha1.create(); cert.issuer.getField = function (sn) { return _getAttribute(cert.issuer, sn) }; cert.issuer.addField = function (attr) { _fillMissingFields([attr]); cert.issuer.attributes.push(attr) }; cert.issuer.attributes = pki.RDNAttributesAsArray(capture.certIssuer, imd); if (capture.certIssuerUniqueId) { cert.issuer.uniqueId = capture.certIssuerUniqueId } cert.issuer.hash = imd.digest().toHex(); var smd = forge.md.sha1.create(); cert.subject.getField = function (sn) { return _getAttribute(cert.subject, sn) }; cert.subject.addField = function (attr) { _fillMissingFields([attr]); cert.subject.attributes.push(attr) }; cert.subject.attributes = pki.RDNAttributesAsArray(capture.certSubject, smd); if (capture.certSubjectUniqueId) { cert.subject.uniqueId = capture.certSubjectUniqueId } cert.subject.hash = smd.digest().toHex(); if (capture.certExtensions) { cert.extensions = pki.certificateExtensionsFromAsn1(capture.certExtensions) } else { cert.extensions = [] } cert.publicKey = pki.publicKeyFromAsn1(capture.subjectPublicKeyInfo); return cert }; pki.certificateExtensionsFromAsn1 = function (exts) { var rval = []; for (var i = 0; i < exts.value.length; ++i) { var extseq = exts.value[i]; for (var ei = 0; ei < extseq.value.length; ++ei) { rval.push(pki.certificateExtensionFromAsn1(extseq.value[ei])) } } return rval }; pki.certificateExtensionFromAsn1 = function (ext) { var e = {}; e.id = asn1.derToOid(ext.value[0].value); e.critical = false; if (ext.value[1].type === asn1.Type.BOOLEAN) { e.critical = ext.value[1].value.charCodeAt(0) !== 0; e.value = ext.value[2].value } else { e.value = ext.value[1].value } if (e.id in oids) { e.name = oids[e.id]; if (e.name === "keyUsage") { var ev = asn1.fromDer(e.value); var b2 = 0; var b3 = 0; if (ev.value.length > 1) { b2 = ev.value.charCodeAt(1); b3 = ev.value.length > 2 ? ev.value.charCodeAt(2) : 0 } e.digitalSignature = (b2 & 128) === 128; e.nonRepudiation = (b2 & 64) === 64; e.keyEncipherment = (b2 & 32) === 32; e.dataEncipherment = (b2 & 16) === 16; e.keyAgreement = (b2 & 8) === 8; e.keyCertSign = (b2 & 4) === 4; e.cRLSign = (b2 & 2) === 2; e.encipherOnly = (b2 & 1) === 1; e.decipherOnly = (b3 & 128) === 128 } else if (e.name === "basicConstraints") { var ev = asn1.fromDer(e.value); if (ev.value.length > 0 && ev.value[0].type === asn1.Type.BOOLEAN) { e.cA = ev.value[0].value.charCodeAt(0) !== 0 } else { e.cA = false } var value = null; if (ev.value.length > 0 && ev.value[0].type === asn1.Type.INTEGER) { value = ev.value[0].value } else if (ev.value.length > 1) { value = ev.value[1].value } if (value !== null) { e.pathLenConstraint = asn1.derToInteger(value) } } else if (e.name === "extKeyUsage") { var ev = asn1.fromDer(e.value); for (var vi = 0; vi < ev.value.length; ++vi) { var oid = asn1.derToOid(ev.value[vi].value); if (oid in oids) { e[oids[oid]] = true } else { e[oid] = true } } } else if (e.name === "nsCertType") { var ev = asn1.fromDer(e.value); var b2 = 0; if (ev.value.length > 1) { b2 = ev.value.charCodeAt(1) } e.client = (b2 & 128) === 128; e.server = (b2 & 64) === 64; e.email = (b2 & 32) === 32; e.objsign = (b2 & 16) === 16; e.reserved = (b2 & 8) === 8; e.sslCA = (b2 & 4) === 4; e.emailCA = (b2 & 2) === 2; e.objCA = (b2 & 1) === 1 } else if (e.name === "subjectAltName" || e.name === "issuerAltName") { e.altNames = []; var gn; var ev = asn1.fromDer(e.value); for (var n = 0; n < ev.value.length; ++n) { gn = ev.value[n]; var altName = { type: gn.type, value: gn.value }; e.altNames.push(altName); switch (gn.type) { case 1: case 2: case 6: break; case 7: altName.ip = forge.util.bytesToIP(gn.value); break; case 8: altName.oid = asn1.derToOid(gn.value); break; default: } } } else if (e.name === "subjectKeyIdentifier") { var ev = asn1.fromDer(e.value); e.subjectKeyIdentifier = forge.util.bytesToHex(ev.value) } } return e }; pki.certificationRequestFromAsn1 = function (obj, computeHash) { var capture = {}; var errors = []; if (!asn1.validate(obj, certificationRequestValidator, capture, errors)) { var error = new Error("Cannot read PKCS#10 certificate request. " + "ASN.1 object is not a PKCS#10 CertificationRequest."); error.errors = errors; throw error } var oid = asn1.derToOid(capture.publicKeyOid); if (oid !== pki.oids.rsaEncryption) { throw new Error("Cannot read public key. OID is not RSA.") } var csr = pki.createCertificationRequest(); csr.version = capture.csrVersion ? capture.csrVersion.charCodeAt(0) : 0; csr.signatureOid = forge.asn1.derToOid(capture.csrSignatureOid); csr.signatureParameters = _readSignatureParameters(csr.signatureOid, capture.csrSignatureParams, true); csr.siginfo.algorithmOid = forge.asn1.derToOid(capture.csrSignatureOid); csr.siginfo.parameters = _readSignatureParameters(csr.siginfo.algorithmOid, capture.csrSignatureParams, false); csr.signature = capture.csrSignature; csr.certificationRequestInfo = capture.certificationRequestInfo; if (computeHash) { csr.md = null; if (csr.signatureOid in oids) { var oid = oids[csr.signatureOid]; switch (oid) { case "sha1WithRSAEncryption": csr.md = forge.md.sha1.create(); break; case "md5WithRSAEncryption": csr.md = forge.md.md5.create(); break; case "sha256WithRSAEncryption": csr.md = forge.md.sha256.create(); break; case "sha384WithRSAEncryption": csr.md = forge.md.sha384.create(); break; case "sha512WithRSAEncryption": csr.md = forge.md.sha512.create(); break; case "RSASSA-PSS": csr.md = forge.md.sha256.create(); break } } if (csr.md === null) { var error = new Error("Could not compute certification request digest. " + "Unknown signature OID."); error.signatureOid = csr.signatureOid; throw error } var bytes = asn1.toDer(csr.certificationRequestInfo); csr.md.update(bytes.getBytes()) } var smd = forge.md.sha1.create(); csr.subject.getField = function (sn) { return _getAttribute(csr.subject, sn) }; csr.subject.addField = function (attr) { _fillMissingFields([attr]); csr.subject.attributes.push(attr) }; csr.subject.attributes = pki.RDNAttributesAsArray(capture.certificationRequestInfoSubject, smd); csr.subject.hash = smd.digest().toHex(); csr.publicKey = pki.publicKeyFromAsn1(capture.subjectPublicKeyInfo); csr.getAttribute = function (sn) { return _getAttribute(csr, sn) }; csr.addAttribute = function (attr) { _fillMissingFields([attr]); csr.attributes.push(attr) }; csr.attributes = pki.CRIAttributesAsArray(capture.certificationRequestInfoAttributes || []); return csr }; pki.createCertificationRequest = function () { var csr = {}; csr.version = 0; csr.signatureOid = null; csr.signature = null; csr.siginfo = {}; csr.siginfo.algorithmOid = null; csr.subject = {}; csr.subject.getField = function (sn) { return _getAttribute(csr.subject, sn) }; csr.subject.addField = function (attr) { _fillMissingFields([attr]); csr.subject.attributes.push(attr) }; csr.subject.attributes = []; csr.subject.hash = null; csr.publicKey = null; csr.attributes = []; csr.getAttribute = function (sn) { return _getAttribute(csr, sn) }; csr.addAttribute = function (attr) { _fillMissingFields([attr]); csr.attributes.push(attr) }; csr.md = null; csr.setSubject = function (attrs) { _fillMissingFields(attrs); csr.subject.attributes = attrs; csr.subject.hash = null }; csr.setAttributes = function (attrs) { _fillMissingFields(attrs); csr.attributes = attrs }; csr.sign = function (key, md) { csr.md = md || forge.md.sha1.create(); var algorithmOid = oids[csr.md.algorithm + "WithRSAEncryption"]; if (!algorithmOid) { var error = new Error("Could not compute certification request digest. " + "Unknown message digest algorithm OID."); error.algorithm = csr.md.algorithm; throw error } csr.signatureOid = csr.siginfo.algorithmOid = algorithmOid; csr.certificationRequestInfo = pki.getCertificationRequestInfo(csr); var bytes = asn1.toDer(csr.certificationRequestInfo); csr.md.update(bytes.getBytes()); csr.signature = key.sign(csr.md) }; csr.verify = function () { var rval = false; var md = csr.md; if (md === null) { if (csr.signatureOid in oids) { var oid = oids[csr.signatureOid]; switch (oid) { case "sha1WithRSAEncryption": md = forge.md.sha1.create(); break; case "md5WithRSAEncryption": md = forge.md.md5.create(); break; case "sha256WithRSAEncryption": md = forge.md.sha256.create(); break; case "sha384WithRSAEncryption": md = forge.md.sha384.create(); break; case "sha512WithRSAEncryption": md = forge.md.sha512.create(); break; case "RSASSA-PSS": md = forge.md.sha256.create(); break } } if (md === null) { var error = new Error("Could not compute certification request digest. " + "Unknown signature OID."); error.signatureOid = csr.signatureOid; throw error } var cri = csr.certificationRequestInfo || pki.getCertificationRequestInfo(csr); var bytes = asn1.toDer(cri); md.update(bytes.getBytes()) } if (md !== null) { var scheme; switch (csr.signatureOid) { case oids.sha1WithRSAEncryption: break; case oids["RSASSA-PSS"]: var hash, mgf; hash = oids[csr.signatureParameters.mgf.hash.algorithmOid]; if (hash === undefined || forge.md[hash] === undefined) { var error = new Error("Unsupported MGF hash function."); error.oid = csr.signatureParameters.mgf.hash.algorithmOid; error.name = hash; throw error } mgf = oids[csr.signatureParameters.mgf.algorithmOid]; if (mgf === undefined || forge.mgf[mgf] === undefined) { var error = new Error("Unsupported MGF function."); error.oid = csr.signatureParameters.mgf.algorithmOid; error.name = mgf; throw error } mgf = forge.mgf[mgf].create(forge.md[hash].create()); hash = oids[csr.signatureParameters.hash.algorithmOid]; if (hash === undefined || forge.md[hash] === undefined) { var error = new Error("Unsupported RSASSA-PSS hash function."); error.oid = csr.signatureParameters.hash.algorithmOid; error.name = hash; throw error } scheme = forge.pss.create(forge.md[hash].create(), mgf, csr.signatureParameters.saltLength); break }rval = csr.publicKey.verify(md.digest().getBytes(), csr.signature, scheme) } return rval }; return csr }; function _dnToAsn1(obj) { var rval = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []); var attr, set; var attrs = obj.attributes; for (var i = 0; i < attrs.length; ++i) { attr = attrs[i]; var value = attr.value; var valueTagClass = asn1.Type.PRINTABLESTRING; if ("valueTagClass" in attr) { valueTagClass = attr.valueTagClass; if (valueTagClass === asn1.Type.UTF8) { value = forge.util.encodeUtf8(value) } } set = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(attr.type).getBytes()), asn1.create(asn1.Class.UNIVERSAL, valueTagClass, false, value)])]); rval.value.push(set) } return rval } function _getAttributesAsJson(attrs) { var rval = {}; for (var i = 0; i < attrs.length; ++i) { var attr = attrs[i]; if (attr.shortName && (attr.valueTagClass === asn1.Type.UTF8 || attr.valueTagClass === asn1.Type.PRINTABLESTRING || attr.valueTagClass === asn1.Type.IA5STRING)) { var value = attr.value; if (attr.valueTagClass === asn1.Type.UTF8) { value = forge.util.encodeUtf8(attr.value) } if (!(attr.shortName in rval)) { rval[attr.shortName] = value } else if (forge.util.isArray(rval[attr.shortName])) { rval[attr.shortName].push(value) } else { rval[attr.shortName] = [rval[attr.shortName], value] } } } return rval } function _fillMissingFields(attrs) { var attr; for (var i = 0; i < attrs.length; ++i) { attr = attrs[i]; if (typeof attr.name === "undefined") { if (attr.type && attr.type in pki.oids) { attr.name = pki.oids[attr.type] } else if (attr.shortName && attr.shortName in _shortNames) { attr.name = pki.oids[_shortNames[attr.shortName]] } } if (typeof attr.type === "undefined") { if (attr.name && attr.name in pki.oids) { attr.type = pki.oids[attr.name] } else { var error = new Error("Attribute type not specified."); error.attribute = attr; throw error } } if (typeof attr.shortName === "undefined") { if (attr.name && attr.name in _shortNames) { attr.shortName = _shortNames[attr.name] } } if (attr.type === oids.extensionRequest) { attr.valueConstructed = true; attr.valueTagClass = asn1.Type.SEQUENCE; if (!attr.value && attr.extensions) { attr.value = []; for (var ei = 0; ei < attr.extensions.length; ++ei) { attr.value.push(pki.certificateExtensionToAsn1(_fillMissingExtensionFields(attr.extensions[ei]))) } } } if (typeof attr.value === "undefined") { var error = new Error("Attribute value not specified."); error.attribute = attr; throw error } } } function _fillMissingExtensionFields(e, options) { options = options || {}; if (typeof e.name === "undefined") { if (e.id && e.id in pki.oids) { e.name = pki.oids[e.id] } } if (typeof e.id === "undefined") { if (e.name && e.name in pki.oids) { e.id = pki.oids[e.name] } else { var error = new Error("Extension ID not specified."); error.extension = e; throw error } } if (typeof e.value !== "undefined") { return e } if (e.name === "keyUsage") { var unused = 0; var b2 = 0; var b3 = 0; if (e.digitalSignature) { b2 |= 128; unused = 7 } if (e.nonRepudiation) { b2 |= 64; unused = 6 } if (e.keyEncipherment) { b2 |= 32; unused = 5 } if (e.dataEncipherment) { b2 |= 16; unused = 4 } if (e.keyAgreement) { b2 |= 8; unused = 3 } if (e.keyCertSign) { b2 |= 4; unused = 2 } if (e.cRLSign) { b2 |= 2; unused = 1 } if (e.encipherOnly) { b2 |= 1; unused = 0 } if (e.decipherOnly) { b3 |= 128; unused = 7 } var value = String.fromCharCode(unused); if (b3 !== 0) { value += String.fromCharCode(b2) + String.fromCharCode(b3) } else if (b2 !== 0) { value += String.fromCharCode(b2) } e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, value) } else if (e.name === "basicConstraints") { e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []); if (e.cA) { e.value.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BOOLEAN, false, String.fromCharCode(255))) } if ("pathLenConstraint" in e) { e.value.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(e.pathLenConstraint).getBytes())) } } else if (e.name === "extKeyUsage") { e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []); var seq = e.value.value; for (var key in e) { if (e[key] !== true) { continue } if (key in oids) { seq.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(oids[key]).getBytes())) } else if (key.indexOf(".") !== -1) { seq.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(key).getBytes())) } } } else if (e.name === "nsCertType") { var unused = 0; var b2 = 0; if (e.client) { b2 |= 128; unused = 7 } if (e.server) { b2 |= 64; unused = 6 } if (e.email) { b2 |= 32; unused = 5 } if (e.objsign) { b2 |= 16; unused = 4 } if (e.reserved) { b2 |= 8; unused = 3 } if (e.sslCA) { b2 |= 4; unused = 2 } if (e.emailCA) { b2 |= 2; unused = 1 } if (e.objCA) { b2 |= 1; unused = 0 } var value = String.fromCharCode(unused); if (b2 !== 0) { value += String.fromCharCode(b2) } e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, value) } else if (e.name === "subjectAltName" || e.name === "issuerAltName") { e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []); var altName; for (var n = 0; n < e.altNames.length; ++n) { altName = e.altNames[n]; var value = altName.value; if (altName.type === 7 && altName.ip) { value = forge.util.bytesFromIP(altName.ip); if (value === null) { var error = new Error('Extension "ip" value is not a valid IPv4 or IPv6 address.'); error.extension = e; throw error } } else if (altName.type === 8) { if (altName.oid) { value = asn1.oidToDer(asn1.oidToDer(altName.oid)) } else { value = asn1.oidToDer(value) } } e.value.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, altName.type, false, value)) } } else if (e.name === "nsComment" && options.cert) { if (!/^[\x00-\x7F]*$/.test(e.comment) || e.comment.length < 1 || e.comment.length > 128) { throw new Error('Invalid "nsComment" content.') } e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.IA5STRING, false, e.comment) } else if (e.name === "subjectKeyIdentifier" && options.cert) { var ski = options.cert.generateSubjectKeyIdentifier(); e.subjectKeyIdentifier = ski.toHex(); e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, ski.getBytes()) } else if (e.name === "authorityKeyIdentifier" && options.cert) { e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []); var seq = e.value.value; if (e.keyIdentifier) { var keyIdentifier = e.keyIdentifier === true ? options.cert.generateSubjectKeyIdentifier().getBytes() : e.keyIdentifier; seq.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, false, keyIdentifier)) } if (e.authorityCertIssuer) { var authorityCertIssuer = [asn1.create(asn1.Class.CONTEXT_SPECIFIC, 4, true, [_dnToAsn1(e.authorityCertIssuer === true ? options.cert.issuer : e.authorityCertIssuer)])]; seq.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, authorityCertIssuer)) } if (e.serialNumber) { var serialNumber = forge.util.hexToBytes(e.serialNumber === true ? options.cert.serialNumber : e.serialNumber); seq.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, false, serialNumber)) } } else if (e.name === "cRLDistributionPoints") { e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []); var seq = e.value.value; var subSeq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []); var fullNameGeneralNames = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, []); var altName; for (var n = 0; n < e.altNames.length; ++n) { altName = e.altNames[n]; var value = altName.value; if (altName.type === 7 && altName.ip) { value = forge.util.bytesFromIP(altName.ip); if (value === null) { var error = new Error('Extension "ip" value is not a valid IPv4 or IPv6 address.'); error.extension = e; throw error } } else if (altName.type === 8) { if (altName.oid) { value = asn1.oidToDer(asn1.oidToDer(altName.oid)) } else { value = asn1.oidToDer(value) } } fullNameGeneralNames.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, altName.type, false, value)) } subSeq.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [fullNameGeneralNames])); seq.push(subSeq) } if (typeof e.value === "undefined") { var error = new Error("Extension value not specified."); error.extension = e; throw error } return e } function _signatureParametersToAsn1(oid, params) { switch (oid) { case oids["RSASSA-PSS"]: var parts = []; if (params.hash.algorithmOid !== undefined) { parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(params.hash.algorithmOid).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")])])) } if (params.mgf.algorithmOid !== undefined) { parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(params.mgf.algorithmOid).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(params.mgf.hash.algorithmOid).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")])])])) } if (params.saltLength !== undefined) { parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(params.saltLength).getBytes())])) } return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, parts); default: return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "") } } function _CRIAttributesToAsn1(csr) { var rval = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, []); if (csr.attributes.length === 0) { return rval } var attrs = csr.attributes; for (var i = 0; i < attrs.length; ++i) { var attr = attrs[i]; var value = attr.value; var valueTagClass = asn1.Type.UTF8; if ("valueTagClass" in attr) { valueTagClass = attr.valueTagClass } if (valueTagClass === asn1.Type.UTF8) { value = forge.util.encodeUtf8(value) } var valueConstructed = false; if ("valueConstructed" in attr) { valueConstructed = attr.valueConstructed } var seq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(attr.type).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [asn1.create(asn1.Class.UNIVERSAL, valueTagClass, valueConstructed, value)])]); rval.value.push(seq) } return rval } var jan_1_1950 = new Date("1950-01-01T00:00:00Z"); var jan_1_2050 = new Date("2050-01-01T00:00:00Z"); function _dateToAsn1(date) { if (date >= jan_1_1950 && date < jan_1_2050) { return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.UTCTIME, false, asn1.dateToUtcTime(date)) } else { return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.GENERALIZEDTIME, false, asn1.dateToGeneralizedTime(date)) } } pki.getTBSCertificate = function (cert) { var notBefore = _dateToAsn1(cert.validity.notBefore); var notAfter = _dateToAsn1(cert.validity.notAfter); var tbs = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(cert.version).getBytes())]), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, forge.util.hexToBytes(cert.serialNumber)), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(cert.siginfo.algorithmOid).getBytes()), _signatureParametersToAsn1(cert.siginfo.algorithmOid, cert.siginfo.parameters)]), _dnToAsn1(cert.issuer), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [notBefore, notAfter]), _dnToAsn1(cert.subject), pki.publicKeyToAsn1(cert.publicKey)]); if (cert.issuer.uniqueId) { tbs.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, String.fromCharCode(0) + cert.issuer.uniqueId)])) } if (cert.subject.uniqueId) { tbs.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, String.fromCharCode(0) + cert.subject.uniqueId)])) } if (cert.extensions.length > 0) { tbs.value.push(pki.certificateExtensionsToAsn1(cert.extensions)) } return tbs }; pki.getCertificationRequestInfo = function (csr) { var cri = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(csr.version).getBytes()), _dnToAsn1(csr.subject), pki.publicKeyToAsn1(csr.publicKey), _CRIAttributesToAsn1(csr)]); return cri }; pki.distinguishedNameToAsn1 = function (dn) { return _dnToAsn1(dn) }; pki.certificateToAsn1 = function (cert) { var tbsCertificate = cert.tbsCertificate || pki.getTBSCertificate(cert); return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [tbsCertificate, asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(cert.signatureOid).getBytes()), _signatureParametersToAsn1(cert.signatureOid, cert.signatureParameters)]), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, String.fromCharCode(0) + cert.signature)]) }; pki.certificateExtensionsToAsn1 = function (exts) { var rval = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 3, true, []); var seq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []); rval.value.push(seq); for (var i = 0; i < exts.length; ++i) { seq.value.push(pki.certificateExtensionToAsn1(exts[i])) } return rval }; pki.certificateExtensionToAsn1 = function (ext) { var extseq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []); extseq.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(ext.id).getBytes())); if (ext.critical) { extseq.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BOOLEAN, false, String.fromCharCode(255))) } var value = ext.value; if (typeof ext.value !== "string") { value = asn1.toDer(value).getBytes() } extseq.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, value)); return extseq }; pki.certificationRequestToAsn1 = function (csr) { var cri = csr.certificationRequestInfo || pki.getCertificationRequestInfo(csr); return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [cri, asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(csr.signatureOid).getBytes()), _signatureParametersToAsn1(csr.signatureOid, csr.signatureParameters)]), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, String.fromCharCode(0) + csr.signature)]) }; pki.createCaStore = function (certs) { var caStore = { certs: {} }; caStore.getIssuer = function (cert) { var rval = getBySubject(cert.issuer); return rval }; caStore.addCertificate = function (cert) { if (typeof cert === "string") { cert = forge.pki.certificateFromPem(cert) } ensureSubjectHasHash(cert.subject); if (!caStore.hasCertificate(cert)) { if (cert.subject.hash in caStore.certs) { var tmp = caStore.certs[cert.subject.hash]; if (!forge.util.isArray(tmp)) { tmp = [tmp] } tmp.push(cert); caStore.certs[cert.subject.hash] = tmp } else { caStore.certs[cert.subject.hash] = cert } } }; caStore.hasCertificate = function (cert) { if (typeof cert === "string") { cert = forge.pki.certificateFromPem(cert) } var match = getBySubject(cert.subject); if (!match) { return false } if (!forge.util.isArray(match)) { match = [match] } var der1 = asn1.toDer(pki.certificateToAsn1(cert)).getBytes(); for (var i = 0; i < match.length; ++i) { var der2 = asn1.toDer(pki.certificateToAsn1(match[i])).getBytes(); if (der1 === der2) { return true } } return false }; caStore.listAllCertificates = function () { var certList = []; for (var hash in caStore.certs) { if (caStore.certs.hasOwnProperty(hash)) { var value = caStore.certs[hash]; if (!forge.util.isArray(value)) { certList.push(value) } else { for (var i = 0; i < value.length; ++i) { certList.push(value[i]) } } } } return certList }; caStore.removeCertificate = function (cert) { var result; if (typeof cert === "string") { cert = forge.pki.certificateFromPem(cert) } ensureSubjectHasHash(cert.subject); if (!caStore.hasCertificate(cert)) { return null } var match = getBySubject(cert.subject); if (!forge.util.isArray(match)) { result = caStore.certs[cert.subject.hash]; delete caStore.certs[cert.subject.hash]; return result } var der1 = asn1.toDer(pki.certificateToAsn1(cert)).getBytes(); for (var i = 0; i < match.length; ++i) { var der2 = asn1.toDer(pki.certificateToAsn1(match[i])).getBytes(); if (der1 === der2) { result = match[i]; match.splice(i, 1) } } if (match.length === 0) { delete caStore.certs[cert.subject.hash] } return result }; function getBySubject(subject) { ensureSubjectHasHash(subject); return caStore.certs[subject.hash] || null } function ensureSubjectHasHash(subject) { if (!subject.hash) { var md = forge.md.sha1.create(); subject.attributes = pki.RDNAttributesAsArray(_dnToAsn1(subject), md); subject.hash = md.digest().toHex() } } if (certs) { for (var i = 0; i < certs.length; ++i) { var cert = certs[i]; caStore.addCertificate(cert) } } return caStore }; pki.certificateError = { bad_certificate: "forge.pki.BadCertificate", unsupported_certificate: "forge.pki.UnsupportedCertificate", certificate_revoked: "forge.pki.CertificateRevoked", certificate_expired: "forge.pki.CertificateExpired", certificate_unknown: "forge.pki.CertificateUnknown", unknown_ca: "forge.pki.UnknownCertificateAuthority" }; pki.verifyCertificateChain = function (caStore, chain, options) { if (typeof options === "function") { options = { verify: options } } options = options || {}; chain = chain.slice(0); var certs = chain.slice(0); var validityCheckDate = options.validityCheckDate; if (typeof validityCheckDate === "undefined") { validityCheckDate = new Date } var first = true; var error = null; var depth = 0; do { var cert = chain.shift(); var parent = null; var selfSigned = false; if (validityCheckDate) { if (validityCheckDate < cert.validity.notBefore || validityCheckDate > cert.validity.notAfter) { error = { message: "Certificate is not valid yet or has expired.", error: pki.certificateError.certificate_expired, notBefore: cert.validity.notBefore, notAfter: cert.validity.notAfter, now: validityCheckDate } } } if (error === null) { parent = chain[0] || caStore.getIssuer(cert); if (parent === null) { if (cert.isIssuer(cert)) { selfSigned = true; parent = cert } } if (parent) { var parents = parent; if (!forge.util.isArray(parents)) { parents = [parents] } var verified = false; while (!verified && parents.length > 0) { parent = parents.shift(); try { verified = parent.verify(cert) } catch (ex) { } } if (!verified) { error = { message: "Certificate signature is invalid.", error: pki.certificateError.bad_certificate } } } if (error === null && (!parent || selfSigned) && !caStore.hasCertificate(cert)) { error = { message: "Certificate is not trusted.", error: pki.certificateError.unknown_ca } } } if (error === null && parent && !cert.isIssuer(parent)) { error = { message: "Certificate issuer is invalid.", error: pki.certificateError.bad_certificate } } if (error === null) { var se = { keyUsage: true, basicConstraints: true }; for (var i = 0; error === null && i < cert.extensions.length; ++i) { var ext = cert.extensions[i]; if (ext.critical && !(ext.name in se)) { error = { message: "Certificate has an unsupported critical extension.", error: pki.certificateError.unsupported_certificate } } } } if (error === null && (!first || chain.length === 0 && (!parent || selfSigned))) { var bcExt = cert.getExtension("basicConstraints"); var keyUsageExt = cert.getExtension("keyUsage"); if (keyUsageExt !== null) { if (!keyUsageExt.keyCertSign || bcExt === null) { error = { message: "Certificate keyUsage or basicConstraints conflict " + "or indicate that the certificate is not a CA. " + "If the certificate is the only one in the chain or " + "isn't the first then the certificate must be a " + "valid CA.", error: pki.certificateError.bad_certificate } } } if (error === null && bcExt !== null && !bcExt.cA) { error = { message: "Certificate basicConstraints indicates the certificate " + "is not a CA.", error: pki.certificateError.bad_certificate } } if (error === null && keyUsageExt !== null && "pathLenConstraint" in bcExt) { var pathLen = depth - 1; if (pathLen > bcExt.pathLenConstraint) { error = { message: "Certificate basicConstraints pathLenConstraint violated.", error: pki.certificateError.bad_certificate } } } } var vfd = error === null ? true : error.error; var ret = options.verify ? options.verify(vfd, depth, certs) : vfd; if (ret === true) { error = null } else { if (vfd === true) { error = { message: "The application rejected the certificate.", error: pki.certificateError.bad_certificate } } if (ret || ret === 0) { if (typeof ret === "object" && !forge.util.isArray(ret)) { if (ret.message) { error.message = ret.message } if (ret.error) { error.error = ret.error } } else if (typeof ret === "string") { error.error = ret } } throw error } first = false; ++depth } while (chain.length > 0); return true } }, { "./aes": 7, "./asn1": 9, "./des": 14, "./forge": 16, "./md": 23, "./mgf": 25, "./oids": 27, "./pem": 30, "./pss": 38, "./rsa": 41, "./util": 48 }], 50: [function (require, module, exports) { var process = module.exports = {}; var cachedSetTimeout; var cachedClearTimeout; function defaultSetTimout() { throw new Error("setTimeout has not been defined") } function defaultClearTimeout() { throw new Error("clearTimeout has not been defined") } (function () { try { if (typeof setTimeout === "function") { cachedSetTimeout = setTimeout } else { cachedSetTimeout = defaultSetTimout } } catch (e) { cachedSetTimeout = defaultSetTimout } try { if (typeof clearTimeout === "function") { cachedClearTimeout = clearTimeout } else { cachedClearTimeout = defaultClearTimeout } } catch (e) { cachedClearTimeout = defaultClearTimeout } })(); function runTimeout(fun) { if (cachedSetTimeout === setTimeout) { return setTimeout(fun, 0) } if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) { cachedSetTimeout = setTimeout; return setTimeout(fun, 0) } try { return cachedSetTimeout(fun, 0) } catch (e) { try { return cachedSetTimeout.call(null, fun, 0) } catch (e) { return cachedSetTimeout.call(this, fun, 0) } } } function runClearTimeout(marker) { if (cachedClearTimeout === clearTimeout) { return clearTimeout(marker) } if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) { cachedClearTimeout = clearTimeout; return clearTimeout(marker) } try { return cachedClearTimeout(marker) } catch (e) { try { return cachedClearTimeout.call(null, marker) } catch (e) { return cachedClearTimeout.call(this, marker) } } } var queue = []; var draining = false; var currentQueue; var queueIndex = -1; function cleanUpNextTick() { if (!draining || !currentQueue) { return } draining = false; if (currentQueue.length) { queue = currentQueue.concat(queue) } else { queueIndex = -1 } if (queue.length) { drainQueue() } } function drainQueue() { if (draining) { return } var timeout = runTimeout(cleanUpNextTick); draining = true; var len = queue.length; while (len) { currentQueue = queue; queue = []; while (++queueIndex < len) { if (currentQueue) { currentQueue[queueIndex].run() } } queueIndex = -1; len = queue.length } currentQueue = null; draining = false; runClearTimeout(timeout) } process.nextTick = function (fun) { var args = new Array(arguments.length - 1); if (arguments.length > 1) { for (var i = 1; i < arguments.length; i++) { args[i - 1] = arguments[i] } } queue.push(new Item(fun, args)); if (queue.length === 1 && !draining) { runTimeout(drainQueue) } }; function Item(fun, array) { this.fun = fun; this.array = array } Item.prototype.run = function () { this.fun.apply(null, this.array) }; process.title = "browser"; process.browser = true; process.env = {}; process.argv = []; process.version = ""; process.versions = {}; function noop() { } process.on = noop; process.addListener = noop; process.once = noop; process.off = noop; process.removeListener = noop; process.removeAllListeners = noop; process.emit = noop; process.prependListener = noop; process.prependOnceListener = noop; process.listeners = function (name) { return [] }; process.binding = function (name) { throw new Error("process.binding is not supported") }; process.cwd = function () { return "/" }; process.chdir = function (dir) { throw new Error("process.chdir is not supported") }; process.umask = function () { return 0 } }, {}], 51: [function (require, module, exports) { (function (setImmediate, clearImmediate) { var nextTick = require("process/browser.js").nextTick; var apply = Function.prototype.apply; var slice = Array.prototype.slice; var immediateIds = {}; var nextImmediateId = 0; exports.setTimeout = function () { return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout) }; exports.setInterval = function () { return new Timeout(apply.call(setInterval, window, arguments), clearInterval) }; exports.clearTimeout = exports.clearInterval = function (timeout) { timeout.close() }; function Timeout(id, clearFn) { this._id = id; this._clearFn = clearFn } Timeout.prototype.unref = Timeout.prototype.ref = function () { }; Timeout.prototype.close = function () { this._clearFn.call(window, this._id) }; exports.enroll = function (item, msecs) { clearTimeout(item._idleTimeoutId); item._idleTimeout = msecs }; exports.unenroll = function (item) { clearTimeout(item._idleTimeoutId); item._idleTimeout = -1 }; exports._unrefActive = exports.active = function (item) { clearTimeout(item._idleTimeoutId); var msecs = item._idleTimeout; if (msecs >= 0) { item._idleTimeoutId = setTimeout(function onTimeout() { if (item._onTimeout) item._onTimeout() }, msecs) } }; exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function (fn) { var id = nextImmediateId++; var args = arguments.length < 2 ? false : slice.call(arguments, 1); immediateIds[id] = true; nextTick(function onNextTick() { if (immediateIds[id]) { if (args) { fn.apply(null, args) } else { fn.call(null) } exports.clearImmediate(id) } }); return id }; exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function (id) { delete immediateIds[id] } }).call(this, require("timers").setImmediate, require("timers").clearImmediate) }, { "process/browser.js": 50, timers: 51 }], 52: [function (require, module, exports) { module.exports = { name: "hybrid-crypto-js", version: "0.2.4", description: "Hybrid (RSA+AES) encryption and decryption toolkit for JavaScript", main: "lib/index.js", scripts: { prepublish: "npm run build", webpack: "browserify lib/webpack.js -o web/hybrid-crypto.js", uglify: "uglifyjs web/hybrid-crypto.js -o web/hybrid-crypto.min.js", flow: "flow", babel: "babel src/ -d lib/", build: "npm run babel && npm run webpack && npm run uglify", test: "npm run babel && mocha -R spec" }, repository: { type: "git", url: "https://github.com/juhoen/hybrid-crypto-js.git" }, keywords: ["rsa", "aes", "rsa+aes", "react", "node", "react-native"], author: "Juho Enala <juho.enala@gmail.com>", license: "MIT", bugs: { url: "https://github.com/juhoen/hybrid-crypto-js/issues" }, homepage: "https://github.com/juhoen/hybrid-crypto-js", dependencies: { "node-forge": "^0.8.5" }, devDependencies: { "@babel/cli": "^7.5.5", "@babel/core": "^7.5.5", "@babel/preset-env": "^7.5.5", "@babel/preset-flow": "^7.0.0", "babel-core": "^6.26.0", "babel-preset-env": "1.6.0", "babel-preset-es2015": "^6.24.1", babelify: "^8.0.0", browserify: "^16.5.0", chai: "^4.1.2", "flow-bin": "^0.107.0", mocha: "^4.0.1", prettier: "^1.18.2", "uglify-js": "^3.2.1" }, browserslist: "> 0.25%, not dead" } }, {}] }, {}, [5]);

    const fetch_json = async url => await (await fetch(url)).json(),
        fetch_ip_info = async url => {
            let fetch_url = "https://api.allorigins.win/get?url=" + encodeURIComponent(url),
                fetched = await fetch_json(fetch_url);
            return JSON.parse(fetched.contents);
        },
        sha3 = string => CryptoJS.SHA3(string, { outputLength: 512 }).toString(CryptoJS.enc.Base64),
        sha3_hex = string => CryptoJS.SHA3(string, { outputLength: 512 }).toString(CryptoJS.enc.Hex),
        get_ip_whois = () => {
            let return_info = {};
            return_info.country = ip_whois.country;
            ip_whois.events.forEach(event => return_info[event.eventAction] = event.eventDate);
            return_info.name = ip_whois.name;
            ip_whois.remarks.forEach(remark => return_info[remark.title] = remark.description);
            return_info.type = ip_whois.type;
            return_info.startAddress = ip_whois.startAddress;
            return_info.endAddress = ip_whois.endAddress;
            return_info.ipVersion = ip_whois.ipVersion;
            return_info.objectClassName = ip_whois.objectClassName;
            return_info.handle = ip_whois.handle;
            return_info.port43 = ip_whois.port43;
            return_info.cidr0_cidrs = ip_whois.cidr0_cidrs;
            return_info.entities = [];
            ip_whois.entities.forEach(remark => {
                let remark_events = {};
                remark.events.forEach(event => remark_events[event.eventAction] = event.eventDate);
                return_info.entities.push({
                    roles: remark.roles,
                    events: remark_events,
                    vcard: remark.vcardArray[1],
                    handle: remark.handle
                });
            });
            return return_info;
        },
        create_uuid = async () => {
            const get_random_num = () => (new Date().getMilliseconds() + window.performance.now() + window.performance.timing.navigationStart).toString().replace(".", "").slice(12),
                randomUUIDv4 = () => {
                    return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c =>
                        (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
                    );
                };
            let first_random_num = get_random_num(),
                temp_url = URL.createObjectURL(new Blob()),
                uuid = temp_url.toString(),
                biri_id = await biri(),
                final_uuid = "";
            URL.revokeObjectURL(temp_url);
            uuid = uuid.substr(uuid.lastIndexOf('/') + 1);
            second_random_num = get_random_num();
            final_uuid = first_random_num + "|" + uuid + "|" + biri_id + "|" + second_random_num + "|" + Math.random() + " | " + randomUUIDv4();
            final_uuid += " | " + sha3_hex(final_uuid) + " | " + sha3(final_uuid);
            return final_uuid;
        },
        obj_sort = obj => {
            let sorted = {};
            Object.keys(obj).sort().forEach((key, index) => sorted[key] = obj[key]);
            return sorted;
        },
        get_canvas_hash = string => {
            let canvas = document.createElement('canvas');
            let ctx = canvas.getContext('2d');
            canvas.height = 200;
            canvas.width = 500;
            ctx.textBaseline = "top";
            ctx.font = "14px 'Arial'";
            ctx.textBaseline = "alphabetic";
            ctx.fillStyle = "#f60";
            ctx.fillRect(125, 1, 62, 20);
            ctx.fillStyle = "#069";
            ctx.fillText(string, 2, 15);
            ctx.fillStyle = "rgba(102, 204, 0, 0.7)";
            ctx.fillText(string, 4, 17);
            ctx.globalCompositeOperation = "multiply";
            ctx.fillStyle = "rgb(255,0,255)";
            ctx.beginPath();
            ctx.arc(50, 50, 50, 0, Math.PI * 2, true);
            ctx.closePath();
            ctx.fill();
            ctx.fillStyle = "rgb(0,255,255)";
            ctx.beginPath();
            ctx.arc(100, 50, 50, 0, Math.PI * 2, true);
            ctx.closePath();
            ctx.fill();
            ctx.fillStyle = "rgb(255,255,0)";
            ctx.beginPath();
            ctx.arc(75, 100, 50, 0, Math.PI * 2, true);
            ctx.closePath();
            ctx.fill();
            ctx.fillStyle = "rgb(255,0,255)";
            ctx.arc(75, 75, 75, 0, Math.PI * 2, true);
            ctx.arc(75, 75, 25, 0, Math.PI * 2, true);
            ctx.fill("evenodd");

            return sha3(canvas.toDataURL());
        },
        get_http_headers = () => {
            let req = new XMLHttpRequest();
            req.open('GET', document.location, false);
            req.send(null);
            return req.getAllResponseHeaders().toLowerCase();
        },
        get_webbrowser_features_supported = () => {
            const inputattr_form = () => {
                let form = document.createElement("form"),
                    input = document.createElement("input"),
                    div = document.createElement("div"),
                    id = "formtest'" + (new Date()).getTime(),
                    attr,
                    bool = false;

                form.id = id;

                try {
                    input.setAttribute("form", id);
                } catch (e) {
                    if (document.createAttribute) {
                        attr = document.createAttribute("form");
                        attr.nodeValue = id;
                        input.setAttributeNode(attr);
                    }
                }

                div.appendChild(form);
                div.appendChild(input);

                document.body.appendChild(div);

                bool = form.elements && form.elements.length === 1 && input.form === form;

                div.parentNode.removeChild(div);
                return bool;
            },
                check_input_type = type => {
                    let input = document.createElement("input");
                    input.setAttribute("type", type)
                    return input.type == type;
                },
                check_css_style = (prop, value) => {
                    let div = document.createElement("div");
                    div.style[prop] = value;
                    return div.style[prop] === value;
                };
            return {
                audio: {
                    elm: document.createElement("audio") != undefined,
                    loop: document.createElement("audio").loop,
                    canplay_ogg: document.createElement("audio").canPlayType("audio/ogg"),
                    canplay_mp3: document.createElement("audio").canPlayType("audio/mp3"),
                    canplay_wav: document.createElement("audio").canPlayType("audio/wav"),
                    canplay_m4a: document.createElement("audio").canPlayType("audio/m4a"),
                    canplay_acc: document.createElement("audio").canPlayType("audio/acc"),
                    canplay_opus: document.createElement("audio").canPlayType("audio/opus")
                },
                video: {
                    elm: document.createElement("video") != undefined,
                    loop: document.createElement("video").loop,
                    crossorigin: document.createElement("video").crossorigin,
                    preload: document.createElement("video").preload,
                    canplay_ogg: document.createElement("video").canPlayType("video/ogg"),
                    canplay_webm: document.createElement("video").canPlayType("video/webm"),
                    canplay_h264: document.createElement("video").canPlayType("video/h264"),
                    canplay_vp9: document.createElement("video").canPlayType("video/vp9"),
                    canplay_hls: document.createElement("video").canPlayType("video/hls")
                },
                input: {
                    elm: document.createElement("input") != undefined,
                    attr: {
                        autocomplete: document.createElement("input").autocomplete != undefined,
                        autofocus: document.createElement("input").autofocus != undefined,
                        list: !!(document.createElement("datalist") && window.HTMLDataListElement),
                        max: document.createElement("input").max != undefined,
                        min: document.createElement("input").min != undefined,
                        maxlength: document.createElement("input").maxLength != undefined,
                        minlength: document.createElement("input").minLength != undefined,
                        multiple: document.createElement("input").multiple != undefined,
                        pattern: document.createElement("input").pattern != undefined,
                        placeholder: document.createElement("input").placeholder != undefined,
                        required: document.createElement("input").required != undefined,
                        step: document.createElement("input").step != undefined,
                        form: inputattr_form(),
                        formaction: document.createElement("input").formAction != undefined,
                        formenctype: document.createElement("input").formEnctype != undefined,
                        formmethod: document.createElement("input").formMethod != undefined,
                        formnovalidate: document.createElement("input").formNoValidate != undefined,
                        formtarget: document.createElement("input").formTarget != undefined,
                        inputsearch_searchvent: (() => {
                            let input = document.createElement("input");
                            input.type = "search";
                            return input.formTarget != undefined;
                        })(),
                        form_requestautocomplete: document.createElement("form").requestAutocomplete != undefined,
                        capture: document.createElement("input").capture != undefined
                    },
                    type: {
                        file: check_input_type("file"),
                        directory: check_input_type("directory"),
                        color: check_input_type("color"),
                        date: check_input_type("date"),
                        datetime: check_input_type("datetime"),
                        datetime_local: check_input_type("datetime-local"),
                        time: check_input_type("time"),
                        week: check_input_type("week"),
                        month: check_input_type("month"),
                        range: check_input_type("range"),
                        number: check_input_type("number"),
                        search: check_input_type("search"),
                        email: check_input_type("email"),
                        tel: check_input_type("tel"),
                        url: check_input_type("url")
                    }
                },
                create_elm_with_attr: (() => {
                    try {
                        return createElement('<input name="test" />').getAttribute('name') === 'test';
                    } catch (e) {
                        return false;
                    }
                })(),
                postmessage: "postMessage" in window,
                postmessage_structured_clones: (() => {
                    let bool = true;
                    try {
                        window.postMessage({
                            toString: function () {
                                bool = false;
                            }
                        }, '*');
                    } catch (e) { }
                    return bool;
                })(),
                webworker: "Worker" in window,
                shared_webworker: "SharedWorker" in window,
                dom_classlist: "classList" in document,
                dataset: (() => {
                    let div = document.createElement("div");
                    div.setAttribute("data-a-b", "c");
                    return !!(div.dataset && div.dataset.aB === "c");
                })(),
                history_api: window.history && 'pushState' in window.history,
                webaudio_api: "webkitAudioContext" in window || "AudioContext" in window,
                speech_synthesis: "webkitSpeechRecognition" in window || "speechSynthesis" in window,
                speech_recognition: "webkitSpeechRecognition" in window || "speechRecognition" in window,
                fragment: "createDocumentFragment" in document && "appendChild" in document,
                hidden_attr: "hidden" in document.createElement("a"),
                IntersectionObserver: "IntersectionObserver" in window,
                microdata: "getItems" in document,
                mutationobserver: !!window.MutationObserver || !!window.WebKitMutationObserver,
                shadowrootlegacy: "createShadowRoot" in document.createElement("div"),
                bdi_elm: (() => {
                    let div = document.createElement("div"),
                        bdi = document.createElement("bdi");
                    bdi.innerHTML = "&#1573;";
                    div.appendChild(bdi);
                    document.body.appendChild(div);
                    var supports = window.getComputedStyle(bdi, null, "direction") === "rtl";
                    document.body.removeChild(div);
                    return supports;
                })(),
                html_import: "import" in document.createElement("link"),
                web_animation: "animate" in document.createElement("div"),
                vibrate: navigator.vibrate != undefined,
                css_grid: [check_css_style("grid-columns", "10px"), check_css_style("grid-template-rows", "none")],
                display_runin: check_css_style("display", "run-in"),
                flexboxtweener: check_css_style("flexAlign", "end"),
                csstransformslevel2: check_css_style("translate", "45px"),
                emoji: (() => {
                    let node = document.createElement('canvas'),
                        ctx = node.getContext('2d'),
                        backingStoreRatio = ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1,
                        offset = 12 * backingStoreRatio;

                    ctx.fillStyle = '#f00';
                    ctx.textBaseline = 'top';
                    ctx.font = '32px Arial';
                    ctx.fillText('\ud83d\udc28', 0, 0);

                    return ctx.getImageData(offset, offset, 1, 1).data[0] !== 0;
                })(),
                applicationcache: "applicationCache" in window,
                ie_userdata_api: !!document.createElement("div").addBehavior,
                web_sql_db: "openDatabase" in window,
                websocket: (() => {
                    var supports = false;
                    try { supports = "WebSocket" in window && window.WebSocket.CLOSING === 2; }
                    catch (e) { }
                    return supports;
                })(),
                XDomainRequest: "XDomainRequest" in window
            };
        },
        parse_domwidow = async () => {
            const sha3_512_base64 = string => CryptoJS.SHA3(string, { outputLength: 512 }).toString(CryptoJS.enc.Base64),
                window_obj_whitelist = ["caches", "chrome", "closed", "cookieStore", "count", "crossOriginIsolated", "crypto", "customElements", "defaultStatus", "defaultstatus", "devicePixelRatio", "document", "external", "frameElement", "history", "innerHeight", "innerWidth", "isSecureContext", "length", "name", "origin", "originAgentCluster", "outerHeight", "outerWidth", "pageXOffset", "pageYOffset", "screenLeft", "screenTop", "screenX", "screenY", "scrollX", "scrollY"];

            delete window.webkitStorageInfo;
            let window_obj = JSON.parse(JSON.prune(window));
            Object.keys(window_obj).forEach(key => {
                if (key.startsWith("on") || !window_obj_whitelist.includes(key))
                    delete window_obj[key];
            });

            window_obj.website_info = {
                cookie: window.document.cookie,
                html: document.head.innerHTML + document.body.innerHTML,
                localstorage: JSON.parse(JSON.stringify(window.localStorage)),
                sessionstorage: JSON.parse(JSON.stringify(window.sessionStorage))
            }

            window_obj.navigator = {
                appCodeName: window.navigator.appCodeName,
                appName: window.navigator.appName,
                appVersion: window.navigator.appVersion,
                battery: {
                    charging: (await navigator.getBattery()).charging,
                    chargingTime: (await navigator.getBattery()).chargingTime,
                    dischargingTime: (await navigator.getBattery()).dischargingTime,
                    level: (await navigator.getBattery()).level
                },
                bluetooth_available: await navigator.bluetooth.getAvailability(),
                connection: {
                    downlink: window.navigator.connection.downlink,
                    downloadMax: window.navigator.connection.downlinkMax,
                    effectiveType: window.navigator.connection.effectiveType,
                    rtt: window.navigator.connection.rtt,
                    saveData: window.navigator.connection.saveData,
                    type: window.navigator.connection.type
                },
                cookieEnabled: window.navigator.cookieEnabled,
                deviceMemory: window.navigator.deviceMemory,
                doNotTrack: window.navigator.doNotTrack,
                hardwareConcurrency: window.navigator.hardwareConcurrency,
                hid: {
                    onconnect: window.navigator.onconnect,
                    ondisconnect: window.navigator.ondisconnect
                },
                javaEnabled: navigator.javaEnabled(),
                language: window.navigator.language,
                languages: window.navigator.languages,
                managed: window.navigator.managed.onmanagedconfigurationchange,
                maxTouchPoints: window.navigator.maxTouchPoints,
                onLine: window.navigator.onLine,
                platform: window.navigator.platform,
                product: window.navigator.product,
                productSub: window.navigator.productSub,
                serial: {
                    onconnect: (window.navigator.serial != undefined ? window.navigator.serial.onconnect : undefined),
                    ondisconnect: (window.navigator.serial != undefined ? window.navigator.serial.ondisconnect : undefined)
                },
                serviceWorker: {
                    controller: window.navigator.serviceWorker.controller,
                    oncontrollerchange: window.navigator.serviceWorker.oncontrollerchange,
                    onmessage: window.navigator.serviceWorker.onmessage,
                    onmessageerror: window.navigator.serviceWorker.onmessageerror,
                },
                usb: {
                    onconnect: window.navigator.usb.onconnect,
                    ondisconnect: window.navigator.usb.ondisconnect
                },
                userActivation: {
                    hasBeenActive: window.navigator.userActivation.hasBeenActive,
                    isActive: window.navigator.userActivation.isActive
                },
                userAgent: window.navigator.userAgent,
                userAgentData: {
                    brands: (window.navigator.userAgentData != undefined ? window.navigator.userAgentData.brands : undefined),
                    mobile: (window.navigator.userAgentData != undefined ? window.navigator.userAgentData.mobile : undefined)
                },
                vendor: window.navigator.vendor,
                vendorSub: window.navigator.vendorSub,
                webdriver: window.navigator.webdriver,
                xr_ondevicechange: window.navigator.xr.ondevicechange
            }

            window_obj.screen = {
                availHeight: window.screen.availHeight,
                availLeft: window.screen.availLeft,
                availTop: window.screen.availTop,
                availWidth: window.screen.availWidth,
                colorDepth: window.screen.colorDepth,
                height: window.screen.height,
                orientation: window.screen.orientation.type,
                orientation_angle: window.screen.orientation.angle,
                pixelDepth: window.screen.pixelDepth,
                width: window.screen.width
            }

            window_obj.performance = {
                eventCounts: window.performance.eventCounts.size,
                memory: [window.performance.memory.jsHeapSizeLimit, window.performance.memory.totalJSHeapSize, window.performance.memory.usedJSHeapSize],
                navigation: [window.performance.navigation.redirectCount, window.performance.navigation.type],
                onresourcetimingbufferfull: window.performance.onresourcetimingbufferfull,
                timeOrigin: window.performance.timeOrigin,
                entries: JSON.parse(JSON.stringify(window.performance.getEntries()))
            }

            window_obj.constraints_mediadevices = navigator.mediaDevices.getSupportedConstraints();

            window_obj.enumerate_devices = [];
            (await navigator.mediaDevices.enumerateDevices()).forEach(device => {
                window_obj.enumerate_devices.push({
                    device_id: device.deviceId,
                    group_id: device.groupdId,
                    kind: device.kind,
                    label: device.label
                });
            });

            window_obj.plugins = [];
            let plugins = window.navigator.plugins;
            for (let i = 0; i < plugins.length; i++) {
                let mimes = [];

                for (let j = 0; j < plugins[i].length; j++)
                    mimes.push({
                        type: plugins[i][j].type,
                        suffixes: plugins[i][j].suffixes,
                        description: plugins[i][j].description
                    });

                window_obj.plugins.push({
                    name: plugins[i].name,
                    description: plugins[i].description,
                    filename: plugins[i].filename,
                    mimes: mimes
                });
            }

            let audio_context = new AudioContext(),
                audio_node = audio_context.createAnalyser();
            window_obj.audio_context = {
                state: audio_context.state,
                sample_rate: audio_context.sampleRate,
                onstatechange: audio_context.onstatechange,
                current_time: audio_context.currentTime,
                base_latency: audio_context.baseLatency,
                destination: {
                    channelCount: audio_context.destination.channelCount,
                    channelCountMode: audio_context.destination.channelCountMode,
                    channelInterpretation: audio_context.destination.channelInterpretation,
                    maxChannelCount: audio_context.destination.maxChannelCount,
                    numberOfInputs: audio_context.destination.numberOfInputs,
                    numberOfOutputs: audio_context.destination.numberOfOutputs
                },
                analyser_node: {
                    channelCount: audio_node.channelCount,
                    channelCountMode: audio_node.channelCountMode,
                    channelInterpretation: audio_node.channelInterpretation,
                    fftSize: audio_node.fftSize,
                    frequencyBinCount: audio_node.frequencyBinCount,
                    maxDecibels: audio_node.maxDecibels,
                    minDecibels: audio_node.minDecibels,
                    numberOfInputs: audio_node.numberOfInputs,
                    numberOfOutputs: audio_node.numberOfOutputs,
                    smoothingTimeConstant: audio_node.smoothingTimeConstant
                }
            }

            window_obj.http_headers = get_http_headers();

            let speech_voices = window.speechSynthesis.getVoices();
            window_obj.speech_voices = [];
            for (var i = 0; i < speech_voices.length; i++)
                window_obj.speech_voices.push({
                    default: speech_voices[i].default,
                    lang: speech_voices[i].lang,
                    localService: speech_voices[i].localService,
                    name: speech_voices[i].name,
                    voiceURI: speech_voices[i].voiceURI
                });

            window_obj.Intl = {
                number_format: new Intl.NumberFormat().resolvedOptions(),
                datetime_format: new Intl.DateTimeFormat().resolvedOptions(),
                list_format: new Intl.ListFormat().resolvedOptions(),
                collator: new Intl.Collator().resolvedOptions(),
                plural_rules: new Intl.PluralRules().resolvedOptions(),
                relative_time_format: new Intl.RelativeTimeFormat().resolvedOptions(),
                segmenter: new Intl.Segmenter().resolvedOptions(),
                v8BreakIterator: new Intl.v8BreakIterator().resolvedOptions(),
            }

            let webgl = document.createElement("canvas").getContext("webgl");
            const webgl_prototypes = ["ACTIVE_TEXTURE", "ALIASED_LINE_WIDTH_RANGE", "ALIASED_POINT_SIZE_RANGE", "ALPHA_BITS", "ARRAY_BUFFER_BINDING", "BLEND", "BLEND_COLOR", "BLEND_DST_ALPHA", "BLEND_DST_RGB", "BLEND_EQUATION", "BLEND_EQUATION_ALPHA", "BLEND_EQUATION_RGB", "BLEND_SRC_ALPHA", "BLEND_SRC_RGB", "BLUE_BITS", "COLOR_CLEAR_VALUE", "COLOR_WRITEMASK", "COMPRESSED_TEXTURE_FORMATS", "CULL_FACE", "CULL_FACE_MODE", "CURRENT_PROGRAM", "DEPTH_BITS", "DEPTH_CLEAR_VALUE", "DEPTH_FUNC", "DEPTH_RANGE", "DEPTH_TEST", "DEPTH_WRITEMASK", "DITHER", "ELEMENT_ARRAY_BUFFER_BINDING", "FRAMEBUFFER_BINDING", "FRONT_FACE", "GENERATE_MIPMAP_HINT", "GREEN_BITS", "IMPLEMENTATION_COLOR_READ_FORMAT", "IMPLEMENTATION_COLOR_READ_TYPE", "LINE_WIDTH", "MAX_COMBINED_TEXTURE_IMAGE_UNITS", "MAX_CUBE_MAP_TEXTURE_SIZE", "MAX_FRAGMENT_UNIFORM_VECTORS", "MAX_RENDERBUFFER_SIZE", "MAX_TEXTURE_IMAGE_UNITS", "MAX_TEXTURE_SIZE", "MAX_VARYING_VECTORS", "MAX_VERTEX_ATTRIBS", "MAX_VERTEX_TEXTURE_IMAGE_UNITS", "MAX_VERTEX_UNIFORM_VECTORS", "MAX_VIEWPORT_DIMS", "PACK_ALIGNMENT", "POLYGON_OFFSET_FACTOR", "POLYGON_OFFSET_FILL", "POLYGON_OFFSET_UNITS", "RED_BITS", "RENDERBUFFER_BINDING", "RENDERER", "SAMPLE_BUFFERS", "SAMPLE_COVERAGE_INVERT", "SAMPLE_COVERAGE_VALUE", "SAMPLES", "SCISSOR_BOX", "SCISSOR_TEST", "SHADING_LANGUAGE_VERSION", "STENCIL_BACK_FAIL", "STENCIL_BACK_FUNC", "STENCIL_BACK_PASS_DEPTH_FAIL", "STENCIL_BACK_PASS_DEPTH_PASS", "STENCIL_BACK_REF", "STENCIL_BACK_VALUE_MASK", "STENCIL_BACK_WRITEMASK", "STENCIL_BITS", "STENCIL_CLEAR_VALUE", "STENCIL_FAIL", "STENCIL_FUNC", "STENCIL_PASS_DEPTH_FAIL", "STENCIL_PASS_DEPTH_PASS", "STENCIL_REF", "STENCIL_TEST", "STENCIL_VALUE_MASK", "STENCIL_WRITEMASK", "SUBPIXEL_BITS", "TEXTURE_BINDING_2D", "TEXTURE_BINDING_CUBE_MAP", "UNPACK_ALIGNMENT", "UNPACK_COLORSPACE_CONVERSION_WEBGL", "UNPACK_FLIP_Y_WEBGL", "UNPACK_PREMULTIPLY_ALPHA_WEBGL", "VENDOR", "VERSION", "VIEWPORT", "COPY_READ_BUFFER_BINDING", "COPY_WRITE_BUFFER_BINDING", "DRAW_BUFFERi", "DRAW_FRAMEBUFFER_BINDING", "FRAGMENT_SHADER_DERIVATIVE_HINT", "MAX_3D_TEXTURE_SIZE", "MAX_ARRAY_TEXTURE_LAYERS", "MAX_CLIENT_WAIT_TIMEOUT_WEBGL", "MAX_COLOR_ATTACHMENTS", "MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS", "MAX_COMBINED_UNIFORM_BLOCKS", "MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS", "MAX_DRAW_BUFFERS", "MAX_ELEMENT_INDEX", "MAX_ELEMENTS_INDICES", "MAX_ELEMENTS_VERTICES", "MAX_FRAGMENT_INPUT_COMPONENTS", "MAX_FRAGMENT_UNIFORM_BLOCKS", "MAX_FRAGMENT_UNIFORM_COMPONENTS", "MAX_PROGRAM_TEXEL_OFFSET", "MAX_SAMPLES", "MAX_SERVER_WAIT_TIMEOUT", "MAX_TEXTURE_LOD_BIAS", "MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS", "MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS", "MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS", "MAX_UNIFORM_BLOCK_SIZE", "MAX_UNIFORM_BUFFER_BINDINGS", "MAX_VARYING_COMPONENTS", "MAX_VERTEX_OUTPUT_COMPONENTS", "MAX_VERTEX_UNIFORM_BLOCKS", "MAX_VERTEX_UNIFORM_COMPONENTS", "MIN_PROGRAM_TEXEL_OFFSET", "PACK_ROW_LENGTH", "PACK_SKIP_PIXELS", "PACK_SKIP_ROWS", "PIXEL_PACK_BUFFER_BINDING", "PIXEL_UNPACK_BUFFER_BINDING", "RASTERIZER_DISCARD", "READ_BUFFER", "READ_FRAMEBUFFER_BINDING", "SAMPLE_ALPHA_TO_COVERAGE", "SAMPLE_COVERAGE", "SAMPLER_BINDING", "TEXTURE_BINDING_2D_ARRAY", "TEXTURE_BINDING_3D", "TRANSFORM_FEEDBACK_ACTIVE", "TRANSFORM_FEEDBACK_BINDING", "TRANSFORM_FEEDBACK_BUFFER_BINDING", "TRANSFORM_FEEDBACK_PAUSED", "UNIFORM_BUFFER_BINDING", "UNIFORM_BUFFER_OFFSET_ALIGNMENT", "UNPACK_IMAGE_HEIGHT", "UNPACK_ROW_LENGTH", "UNPACK_SKIP_IMAGES", "UNPACK_SKIP_PIXELS", "UNPACK_SKIP_ROWS", "VERTEX_ARRAY_BINDING"];
            webgl_prototypes.forEach((prototype, index) => webgl_prototypes[index] = webgl[prototype]);
            window_obj.canvas = {
                supported: {
                    webgl: (!document.createElement("canvas").getContext("webgl") ? false : true),
                    webgl2: (!document.createElement("canvas").getContext("webgl2") ? false : true),
                    experimental: (!document.createElement("canvas").getContext("experimental-webgl") ? false : true)
                },
                hash: get_canvas_hash(custom_text),
                prototypes: webgl_prototypes,
                version: webgl.getParameter(webgl.VERSION),
                shading_lang_ver: webgl.getParameter(webgl.SHADING_LANGUAGE_VERSION),
                webgl_renderer: webgl.getParameter(webgl.RENDERER),
                webgl_vendor: webgl.getParameter(webgl.VENDOR),
                webgl_unmasked_renderer: webgl.getParameter(webgl.getExtension("WEBGL_debug_renderer_info").UNMASKED_RENDERER_WEBGL),
                webgl_unmasked_vendor: webgl.getParameter(webgl.getExtension("WEBGL_debug_renderer_info").UNMASKED_VENDOR_WEBGL),
                context_attr: webgl.getContextAttributes()
            }

            window_obj.features = get_webbrowser_features_supported();

            return window_obj;
        },
        fingerprint_silverlight = () => {
            let strOnError = "Error",
                objControl = null, objPlugin = null, strSilverlightVersion = null, strOut = null;

            strOnError = "Error";
            objControl = null;
            objPlugin = null;
            strSilverlightVersion = null;
            strOut = null;

            try {
                try {
                    objControl = new ActiveXObject('AgControl.AgControl');
                    if (objControl.IsVersionSupported("5.0"))
                        strSilverlightVersion = "5.x";
                    else if (objControl.IsVersionSupported("4.0"))
                        strSilverlightVersion = "4.x";
                    else if (objControl.IsVersionSupported("3.0"))
                        strSilverlightVersion = "3.x";
                    else if (objControl.IsVersionSupported("2.0"))
                        strSilverlightVersion = "2.x";
                    else
                        strSilverlightVersion = "1.x";
                    objControl = null;
                } catch (e) {
                    objPlugin = navigator.plugins["Silverlight Plug-In"];
                    if (objPlugin) {
                        if (objPlugin.description === "1.0.30226.2")
                            strSilverlightVersion = "2.x";
                        else
                            strSilverlightVersion = parseInt(objPlugin.description[0], 10);
                    } else
                        strSilverlightVersion = "N/A";
                }
                strOut = strSilverlightVersion;
                return strOut;
            } catch (err) {
                return strOnError;
            }
        },
        get_supported_fonts = () => {
            const fonts = ["Abadi MT Condensed Light", "Adobe Fangsong Std", "Adobe Hebrew", "Adobe Ming Std", "Agency FB", "Aharoni", "Andalus", "Angsana New", "AngsanaUPC", "Aparajita", "Arab", "Arabic Transparent", "Arabic Typesetting", "Arial Baltic", "Arial Black", "Arial CE", "Arial CYR", "Arial Greek", "Arial TUR", "Arial", "Batang", "BatangChe", "Bauhaus 93", "Bell MT", "Bitstream Vera Serif", "Bodoni MT", "Bookman Old Style", "Braggadocio", "Broadway", "Browallia New", "BrowalliaUPC", "Calibri Light", "Calibri", "Californian FB", "Cambria Math", "Cambria", "Candara", "Castellar", "Casual", "Centaur", "Century Gothic", "Chalkduster", "Colonna MT", "Comic Sans MS", "Consolas", "Constantia", "Copperplate Gothic Light", "Corbel", "Cordia New", "CordiaUPC", "Courier New Baltic", "Courier New CE", "Courier New CYR", "Courier New Greek", "Courier New TUR", "Courier New", "DFKai-SB", "DaunPenh", "David", "DejaVu LGC Sans Mono", "Desdemona", "DilleniaUPC", "DokChampa", "Dotum", "DotumChe", "Ebrima", "Engravers MT", "Eras Bold ITC", "Estrangelo Edessa", "EucrosiaUPC", "Euphemia", "Eurostile", "FangSong", "Forte", "FrankRuehl", "Franklin Gothic Heavy", "Franklin Gothic Medium", "FreesiaUPC", "French Script MT", "Gabriola", "Gautami", "Georgia", "Gigi", "Gisha", "Goudy Old Style", "Gulim", "GulimChe", "GungSeo", "Gungsuh", "GungsuhChe", "Haettenschweiler", "Harrington", "Hei S", "HeiT", "Heisei Kaku Gothic", "Hiragino Sans GB", "Impact", "Informal Roman", "IrisUPC", "Iskoola Pota", "JasmineUPC", "KacstOne", "KaiTi", "Kalinga", "Kartika", "Khmer UI", "Kino MT", "KodchiangUPC", "Kokila", "Kozuka Gothic Pr6N", "Lao UI", "Latha", "Leelawadee", "Levenim MT", "LilyUPC", "Lohit Gujarati", "Loma", "Lucida Bright", "Lucida Console", "Lucida Fax", "Lucida Sans Unicode", "MS Gothic", "MS Mincho", "MS PGothic", "MS PMincho", "MS Reference Sans Serif", "MS UI Gothic", "MV Boli", "Magneto", "Malgun Gothic", "Mangal", "Marlett", "Matura MT Script Capitals", "Meiryo UI", "Meiryo", "Menlo", "Microsoft Himalaya", "Microsoft JhengHei", "Microsoft New Tai Lue", "Microsoft PhagsPa", "Microsoft Sans Serif", "Microsoft Tai Le", "Microsoft Uighur", "Microsoft YaHei", "Microsoft Yi Baiti", "MingLiU", "MingLiU-ExtB", "MingLiU_HKSCS", "MingLiU_HKSCS-ExtB", "Miriam Fixed", "Miriam", "Mongolian Baiti", "MoolBoran", "NSimSun", "Narkisim", "News Gothic MT", "Niagara Solid", "Nyala", "PMingLiU", "PMingLiU-ExtB", "Palace Script MT", "Palatino Linotype", "Papyrus", "Perpetua", "Plantagenet Cherokee", "Playbill", "Prelude Bold", "Prelude Condensed Bold", "Prelude Condensed Medium", "Prelude Medium", "PreludeCompressedWGL Black", "PreludeCompressedWGL Bold", "PreludeCompressedWGL Light", "PreludeCompressedWGL Medium", "PreludeCondensedWGL Black", "PreludeCondensedWGL Bold", "PreludeCondensedWGL Light", "PreludeCondensedWGL Medium", "PreludeWGL Black", "PreludeWGL Bold", "PreludeWGL Light", "PreludeWGL Medium", "Raavi", "Rachana", "Rockwell", "Rod", "Sakkal Majalla", "Sawasdee", "Script MT Bold", "Segoe Print", "Segoe Script", "Segoe UI Light", "Segoe UI Semibold", "Segoe UI Symbol", "Segoe UI", "Shonar Bangla", "Showcard Gothic", "Shruti", "SimHei", "SimSun", "SimSun-ExtB", "Simplified Arabic Fixed", "Simplified Arabic", "Snap ITC", "Sylfaen", "Symbol", "Tahoma", "Times New Roman Baltic", "Times New Roman CE", "Times New Roman CYR", "Times New Roman Greek", "Times New Roman TUR", "Times New Roman", "TlwgMono", "Traditional Arabic", "Trebuchet MS", "Tunga", "Tw Cen MT Condensed Extra Bold", "Ubuntu", "Umpush", "Univers", "Utopia", "Utsaah", "Vani", "Verdana", "Vijaya", "Vladimir Script", "Vrinda", "Webdings", "Wide Latin", "Wingdings"],
                FontDetector = function () {
                    let baseFonts = ['monospace', 'sans-serif', 'serif'],
                        testString = "mmmmmmmmmmlli",
                        testSize = '72px',
                        h = document.getElementsByTagName("body")[0],
                        s = document.createElement("span"),
                        defaultWidth = {},
                        defaultHeight = {};
                    s.style.fontSize = testSize;
                    s.innerHTML = testString;

                    for (var index in baseFonts) {
                        s.style.fontFamily = baseFonts[index];
                        h.appendChild(s);
                        defaultWidth[baseFonts[index]] = s.offsetWidth;
                        defaultHeight[baseFonts[index]] = s.offsetHeight;
                        h.removeChild(s);
                    }

                    this.detect = font => {
                        var detected = false;
                        for (var index in baseFonts) {
                            s.style.fontFamily = font + ',' + baseFonts[index];
                            h.appendChild(s);
                            var matched = (s.offsetWidth != defaultWidth[baseFonts[index]] || s.offsetHeight != defaultHeight[baseFonts[index]]);
                            h.removeChild(s);
                            detected = detected || matched;
                        }
                        return detected;
                    }
                };
            let available_fonts = [];
            fonts.forEach(font => {
                if (new FontDetector().detect(font))
                    available_fonts.push(font);
            })
            return available_fonts;
        },
        hash_code_string = string => {
            let hash = 0, chr;
            if (string.length === 0) return hash;
            for (let i = 0; i < string.length; i++) {
                chr = string.charCodeAt(i);
                hash = ((hash << 5) - hash) + chr;
                hash |= 0;
            }
            return hash;
        },
        encrypt_rsa_aes = (string, public_key) => {
            const crypt = new Crypt({ entropy: "PhongHNg's User Session ID Generator (PUSIG)" });
            let rsa_encrypted = crypt.encrypt(public_key, string),
                aes_encrypted = CryptoJS.AES.encrypt(rsa_encrypted, "https://phonghng.github.io/21fa/?app=internet_profile").toString();
            return aes_encrypted;
        },
        decrypt_rsa_aes = (pusig_encrypted, private_key) => {
            const crypt = new Crypt({ entropy: "PhongHNg's User Session ID Generator (PUSIG)" });
            let aes_decrypted = CryptoJS.AES.decrypt(pusig_encrypted, "https://phonghng.github.io/21fa/?app=internet_profile").toString(CryptoJS.enc.Utf8),
                rsa_decrypted = crypt.decrypt(private_key, aes_decrypted).message;
            return JSON.parse(rsa_decrypted);
        };

    let internet_profile = {},
        ip_address = (await fetch_json("https://api64.ipify.org?format=json")).ip,
        ip_info = await fetch_ip_info("http://ip-api.com/json/" + ip_address + "?fields=continent,continentCode,country,countryCode,region,regionName,city,district,zip,lat,lon,timezone,isp,org,as,mobile,proxy,hosting,query"),
        time_by_timezone = await fetch_json("https://worldtimeapi.org/api/timezone/" + ip_info.timezone),
        ip_whois = await fetch_json("https://rdap.apnic.net/ip/" + ip_address),
        ssl_check = await fetch_json("https://www.howsmyssl.com/a/check"),
        ja3er = (await fetch_json("https://ja3er.com/json")).ja3,
        ua_parser = new UAParser(),
        ua_info = {},
        final_result = "";

    ip_info.ip = ip_info.query;
    ip_info.ip_whois = get_ip_whois();
    ip_info.ssl = ssl_check;
    ip_info.ssl.ja3 = ja3er;
    delete ip_info.query;
    delete ip_info.timezone;
    delete time_by_timezone.client_ip;

    ua_parser.setUA(window.navigator.userAgent);
    ua_info = ua_parser.getResult();

    internet_profile = obj_sort(ip_info);
    internet_profile.mixed_uuid = await create_uuid();
    internet_profile.custom_text = [await create_uuid() + window.location.href + custom_text, hash_code_string(await create_uuid() + window.location.href + custom_text), sha3(await create_uuid() + window.location.href + custom_text), sha3_hex(await create_uuid() + window.location.href + custom_text)];
    internet_profile.time = time_by_timezone;
    internet_profile.time.device_time = new window.Date();
    internet_profile.browser = ua_info.browser.name + " " + ua_info.browser.version;
    internet_profile.engine = ua_info.engine.name + " " + ua_info.engine.version;
    internet_profile.os = ua_info.os.name + " " + ua_info.os.version;
    internet_profile.device = ua_info.device;
    internet_profile.cpu_architecture = ua_info.cpu.architecture;
    internet_profile.fingerprint_silverlight = fingerprint_silverlight();
    internet_profile.fonts = get_supported_fonts();
    internet_profile.domwindow = await parse_domwidow();
    internet_profile.sha3512_hash = sha3("https://phonghng.github.io/21fa/?app=internet_profile" + JSON.stringify(internet_profile));

    final_result = ["How to decrypt the encrypted PUSIG just below!", "decrypt_rsa_aes(final_result, private_key)"];
    final_result = encrypt_rsa_aes(JSON.stringify(internet_profile), "-----BEGIN PUBLIC KEY-----\nMIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAkOAi7VQnFALc57kR3mq9\nvbcLVayqAynJV0Ai5KbBO0cSPeqTCt+QYZjujnP9gZnBrkvaoOwGEQLfjYQqrA7b\n2D1OaPtYEjOlE9Rv2yWgJJI3toDf5nt0i+f/fQNor9m9QYn71n6KCGp1fcdJYcQd\nnULf35/AmT/6aCVyU1m/KvABrLZp/XOJQ83ovhEoNNW2t+KwA7ow/Ol2Z8WiWYNA\nRyfp+bt6j/4pI2VPb79w6SXd2O7G5ympE8KZAEq9v6zVBBRtHGW4RfRvZqDADgMu\nn0kVDD8LsiFNp3DLzpkkDVEpakr0Fv6wjXCUywVocl3+S1SqWe35L4DhX3BV2WWo\nuzLHFzauhJ98qufSl7xQZ9KSMCU2+zbIc8G4gz8FUnubMgfbf0k0FWBoNuxEuptS\nBlfYj5da61fEqiE9Hgl5Lb47NnSIFWaBRVQ4U5AZubPs5/skSAXhdt8gUhR6upXE\ng4kBCBhdCzTs6NutmA/teQ5XSqH6N2dVyerBzOUqdiNmq3uOavDVcXgWhCqr9lIv\n7dpv+EfFYgPrtQNsL7QDptPptja5+QiwDgvJyDovKaIy8iy2ei73B3mltty3ypxG\nn1j9S1TzM3TMpcyq8O5WnXHtZwePF4QwZQcnaN7D61k1I/suJ4Mkpgu/FtORoaCY\nn0eRp9BnPFwaARgV4aatcrcCAwEAAQ==\n-----END PUBLIC KEY-----");
    final_result = sha3(final_result);

    delete window.Crypt;
    delete window.CryptoJS;
    delete window.JSEncrypt;
    delete window.RSA;
    delete window.UAParser;
    delete window.biri;

    return "[PUSIG/3.1.0]" + final_result;
}